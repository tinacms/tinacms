var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name2 in all2)
    __defProp(target, name2, { get: all2[name2], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../../node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "../../../node_modules/.pnpm/is-buffer@2.0.5/node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// ../../../node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js
var require_extend = __commonJS({
  "../../../node_modules/.pnpm/extend@3.0.2/node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn2 = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray2 = function isArray3(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject3 = function isPlainObject4(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn2.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn2.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn2.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name2) {
      if (name2 === "__proto__") {
        if (!hasOwn2.call(obj, name2)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name2).value;
        }
      }
      return obj[name2];
    };
    module.exports = function extend3() {
      var options, name2, src, copy, copyIsArray, clone;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name2 in options) {
            src = getProperty(target, name2);
            copy = getProperty(options, name2);
            if (target !== copy) {
              if (deep && copy && (isPlainObject3(copy) || (copyIsArray = isArray2(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && isArray2(src) ? src : [];
                } else {
                  clone = src && isPlainObject3(src) ? src : {};
                }
                setProperty(target, { name: name2, newValue: extend3(deep, clone, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name: name2, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// ../../../node_modules/.pnpm/acorn-jsx@5.3.2_acorn@8.8.2/node_modules/acorn-jsx/xhtml.js
var require_xhtml = __commonJS({
  "../../../node_modules/.pnpm/acorn-jsx@5.3.2_acorn@8.8.2/node_modules/acorn-jsx/xhtml.js"(exports, module) {
    module.exports = {
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      "int": "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
  }
});

// ../../../node_modules/.pnpm/acorn@8.8.2/node_modules/acorn/dist/acorn.js
var require_acorn = __commonJS({
  "../../../node_modules/.pnpm/acorn@8.8.2/node_modules/acorn/dist/acorn.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.acorn = {}));
    })(exports, function(exports2) {
      "use strict";
      var astralIdentifierCodes2 = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
      var astralIdentifierStartCodes2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
      var nonASCIIidentifierChars2 = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
      var nonASCIIidentifierStartChars2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
      var reservedWords2 = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };
      var ecma5AndLessKeywords2 = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
      var keywords$12 = {
        5: ecma5AndLessKeywords2,
        "5module": ecma5AndLessKeywords2 + " export import",
        6: ecma5AndLessKeywords2 + " const class extends export import super"
      };
      var keywordRelationalOperator2 = /^in(stanceof)?$/;
      var nonASCIIidentifierStart2 = new RegExp("[" + nonASCIIidentifierStartChars2 + "]");
      var nonASCIIidentifier2 = new RegExp("[" + nonASCIIidentifierStartChars2 + nonASCIIidentifierChars2 + "]");
      function isInAstralSet2(code3, set) {
        var pos = 65536;
        for (var i2 = 0; i2 < set.length; i2 += 2) {
          pos += set[i2];
          if (pos > code3) {
            return false;
          }
          pos += set[i2 + 1];
          if (pos >= code3) {
            return true;
          }
        }
        return false;
      }
      function isIdentifierStart2(code3, astral) {
        if (code3 < 65) {
          return code3 === 36;
        }
        if (code3 < 91) {
          return true;
        }
        if (code3 < 97) {
          return code3 === 95;
        }
        if (code3 < 123) {
          return true;
        }
        if (code3 <= 65535) {
          return code3 >= 170 && nonASCIIidentifierStart2.test(String.fromCharCode(code3));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet2(code3, astralIdentifierStartCodes2);
      }
      function isIdentifierChar2(code3, astral) {
        if (code3 < 48) {
          return code3 === 36;
        }
        if (code3 < 58) {
          return true;
        }
        if (code3 < 65) {
          return false;
        }
        if (code3 < 91) {
          return true;
        }
        if (code3 < 97) {
          return code3 === 95;
        }
        if (code3 < 123) {
          return true;
        }
        if (code3 <= 65535) {
          return code3 >= 170 && nonASCIIidentifier2.test(String.fromCharCode(code3));
        }
        if (astral === false) {
          return false;
        }
        return isInAstralSet2(code3, astralIdentifierStartCodes2) || isInAstralSet2(code3, astralIdentifierCodes2);
      }
      var TokenType3 = function TokenType4(label, conf) {
        if (conf === void 0) conf = {};
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };
      function binop2(name2, prec) {
        return new TokenType3(name2, { beforeExpr: true, binop: prec });
      }
      var beforeExpr2 = { beforeExpr: true }, startsExpr2 = { startsExpr: true };
      var keywords2 = {};
      function kw2(name2, options) {
        if (options === void 0) options = {};
        options.keyword = name2;
        return keywords2[name2] = new TokenType3(name2, options);
      }
      var types$12 = {
        num: new TokenType3("num", startsExpr2),
        regexp: new TokenType3("regexp", startsExpr2),
        string: new TokenType3("string", startsExpr2),
        name: new TokenType3("name", startsExpr2),
        privateId: new TokenType3("privateId", startsExpr2),
        eof: new TokenType3("eof"),
        // Punctuation token types.
        bracketL: new TokenType3("[", { beforeExpr: true, startsExpr: true }),
        bracketR: new TokenType3("]"),
        braceL: new TokenType3("{", { beforeExpr: true, startsExpr: true }),
        braceR: new TokenType3("}"),
        parenL: new TokenType3("(", { beforeExpr: true, startsExpr: true }),
        parenR: new TokenType3(")"),
        comma: new TokenType3(",", beforeExpr2),
        semi: new TokenType3(";", beforeExpr2),
        colon: new TokenType3(":", beforeExpr2),
        dot: new TokenType3("."),
        question: new TokenType3("?", beforeExpr2),
        questionDot: new TokenType3("?."),
        arrow: new TokenType3("=>", beforeExpr2),
        template: new TokenType3("template"),
        invalidTemplate: new TokenType3("invalidTemplate"),
        ellipsis: new TokenType3("...", beforeExpr2),
        backQuote: new TokenType3("`", startsExpr2),
        dollarBraceL: new TokenType3("${", { beforeExpr: true, startsExpr: true }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new TokenType3("=", { beforeExpr: true, isAssign: true }),
        assign: new TokenType3("_=", { beforeExpr: true, isAssign: true }),
        incDec: new TokenType3("++/--", { prefix: true, postfix: true, startsExpr: true }),
        prefix: new TokenType3("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
        logicalOR: binop2("||", 1),
        logicalAND: binop2("&&", 2),
        bitwiseOR: binop2("|", 3),
        bitwiseXOR: binop2("^", 4),
        bitwiseAND: binop2("&", 5),
        equality: binop2("==/!=/===/!==", 6),
        relational: binop2("</>/<=/>=", 7),
        bitShift: binop2("<</>>/>>>", 8),
        plusMin: new TokenType3("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
        modulo: binop2("%", 10),
        star: binop2("*", 10),
        slash: binop2("/", 10),
        starstar: new TokenType3("**", { beforeExpr: true }),
        coalesce: binop2("??", 1),
        // Keyword token types.
        _break: kw2("break"),
        _case: kw2("case", beforeExpr2),
        _catch: kw2("catch"),
        _continue: kw2("continue"),
        _debugger: kw2("debugger"),
        _default: kw2("default", beforeExpr2),
        _do: kw2("do", { isLoop: true, beforeExpr: true }),
        _else: kw2("else", beforeExpr2),
        _finally: kw2("finally"),
        _for: kw2("for", { isLoop: true }),
        _function: kw2("function", startsExpr2),
        _if: kw2("if"),
        _return: kw2("return", beforeExpr2),
        _switch: kw2("switch"),
        _throw: kw2("throw", beforeExpr2),
        _try: kw2("try"),
        _var: kw2("var"),
        _const: kw2("const"),
        _while: kw2("while", { isLoop: true }),
        _with: kw2("with"),
        _new: kw2("new", { beforeExpr: true, startsExpr: true }),
        _this: kw2("this", startsExpr2),
        _super: kw2("super", startsExpr2),
        _class: kw2("class", startsExpr2),
        _extends: kw2("extends", beforeExpr2),
        _export: kw2("export"),
        _import: kw2("import", startsExpr2),
        _null: kw2("null", startsExpr2),
        _true: kw2("true", startsExpr2),
        _false: kw2("false", startsExpr2),
        _in: kw2("in", { beforeExpr: true, binop: 7 }),
        _instanceof: kw2("instanceof", { beforeExpr: true, binop: 7 }),
        _typeof: kw2("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
        _void: kw2("void", { beforeExpr: true, prefix: true, startsExpr: true }),
        _delete: kw2("delete", { beforeExpr: true, prefix: true, startsExpr: true })
      };
      var lineBreak2 = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG2 = new RegExp(lineBreak2.source, "g");
      function isNewLine2(code3) {
        return code3 === 10 || code3 === 13 || code3 === 8232 || code3 === 8233;
      }
      function nextLineBreak2(code3, from, end) {
        if (end === void 0) end = code3.length;
        for (var i2 = from; i2 < end; i2++) {
          var next = code3.charCodeAt(i2);
          if (isNewLine2(next)) {
            return i2 < end - 1 && next === 13 && code3.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
          }
        }
        return -1;
      }
      var nonASCIIwhitespace2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
      var skipWhiteSpace2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
      var ref2 = Object.prototype;
      var hasOwnProperty3 = ref2.hasOwnProperty;
      var toString3 = ref2.toString;
      var hasOwn2 = Object.hasOwn || function(obj, propName) {
        return hasOwnProperty3.call(obj, propName);
      };
      var isArray2 = Array.isArray || function(obj) {
        return toString3.call(obj) === "[object Array]";
      };
      function wordsRegexp2(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
      }
      function codePointToString2(code3) {
        if (code3 <= 65535) {
          return String.fromCharCode(code3);
        }
        code3 -= 65536;
        return String.fromCharCode((code3 >> 10) + 55296, (code3 & 1023) + 56320);
      }
      var loneSurrogate2 = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
      var Position3 = function Position4(line2, col) {
        this.line = line2;
        this.column = col;
      };
      Position3.prototype.offset = function offset2(n) {
        return new Position3(this.line, this.column + n);
      };
      var SourceLocation3 = function SourceLocation4(p, start3, end) {
        this.start = start3;
        this.end = end;
        if (p.sourceFile !== null) {
          this.source = p.sourceFile;
        }
      };
      function getLineInfo2(input, offset2) {
        for (var line2 = 1, cur = 0; ; ) {
          var nextBreak = nextLineBreak2(input, cur, offset2);
          if (nextBreak < 0) {
            return new Position3(line2, offset2 - cur);
          }
          ++line2;
          cur = nextBreak;
        }
      }
      var defaultOptions2 = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called
        // when a semicolon is automatically inserted. It will be passed
        // the position of the comma as an offset, and if `locations` is
        // enabled, it is given the location as a `{line, column}` object
        // as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: false,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: false,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: false,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: false,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: false,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: false
      };
      var warnedAboutEcmaVersion2 = false;
      function getOptions2(opts) {
        var options = {};
        for (var opt in defaultOptions2) {
          options[opt] = opts && hasOwn2(opts, opt) ? opts[opt] : defaultOptions2[opt];
        }
        if (options.ecmaVersion === "latest") {
          options.ecmaVersion = 1e8;
        } else if (options.ecmaVersion == null) {
          if (!warnedAboutEcmaVersion2 && typeof console === "object" && console.warn) {
            warnedAboutEcmaVersion2 = true;
            console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
          }
          options.ecmaVersion = 11;
        } else if (options.ecmaVersion >= 2015) {
          options.ecmaVersion -= 2009;
        }
        if (options.allowReserved == null) {
          options.allowReserved = options.ecmaVersion < 5;
        }
        if (!opts || opts.allowHashBang == null) {
          options.allowHashBang = options.ecmaVersion >= 14;
        }
        if (isArray2(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function(token) {
            return tokens.push(token);
          };
        }
        if (isArray2(options.onComment)) {
          options.onComment = pushComment2(options, options.onComment);
        }
        return options;
      }
      function pushComment2(options, array) {
        return function(block, text7, start3, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text7,
            start: start3,
            end
          };
          if (options.locations) {
            comment.loc = new SourceLocation3(this, startLoc, endLoc);
          }
          if (options.ranges) {
            comment.range = [start3, end];
          }
          array.push(comment);
        };
      }
      var SCOPE_TOP2 = 1, SCOPE_FUNCTION2 = 2, SCOPE_ASYNC2 = 4, SCOPE_GENERATOR2 = 8, SCOPE_ARROW2 = 16, SCOPE_SIMPLE_CATCH2 = 32, SCOPE_SUPER2 = 64, SCOPE_DIRECT_SUPER2 = 128, SCOPE_CLASS_STATIC_BLOCK2 = 256, SCOPE_VAR2 = SCOPE_TOP2 | SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2;
      function functionFlags2(async, generator) {
        return SCOPE_FUNCTION2 | (async ? SCOPE_ASYNC2 : 0) | (generator ? SCOPE_GENERATOR2 : 0);
      }
      var BIND_NONE2 = 0, BIND_VAR2 = 1, BIND_LEXICAL2 = 2, BIND_FUNCTION2 = 3, BIND_SIMPLE_CATCH2 = 4, BIND_OUTSIDE2 = 5;
      var Parser3 = function Parser4(options, input, startPos) {
        this.options = options = getOptions2(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp2(keywords$12[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          reserved = reservedWords2[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
          if (options.sourceType === "module") {
            reserved += " await";
          }
        }
        this.reservedWords = wordsRegexp2(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords2.strict;
        this.reservedWordsStrict = wordsRegexp2(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp2(reservedStrict + " " + reservedWords2.strictBind);
        this.input = String(input);
        this.containsEsc = false;
        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak2).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }
        this.type = types$12.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();
        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;
        this.context = this.initialContext();
        this.exprAllowed = true;
        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);
        this.potentialArrowAt = -1;
        this.potentialArrowInForAwait = false;
        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = /* @__PURE__ */ Object.create(null);
        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
          this.skipLineComment(2);
        }
        this.scopeStack = [];
        this.enterScope(SCOPE_TOP2);
        this.regexpState = null;
        this.privateNameStack = [];
      };
      var prototypeAccessors2 = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
      Parser3.prototype.parse = function parse6() {
        var node2 = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node2);
      };
      prototypeAccessors2.inFunction.get = function() {
        return (this.currentVarScope().flags & SCOPE_FUNCTION2) > 0;
      };
      prototypeAccessors2.inGenerator.get = function() {
        return (this.currentVarScope().flags & SCOPE_GENERATOR2) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors2.inAsync.get = function() {
        return (this.currentVarScope().flags & SCOPE_ASYNC2) > 0 && !this.currentVarScope().inClassFieldInit;
      };
      prototypeAccessors2.canAwait.get = function() {
        for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK2) {
            return false;
          }
          if (scope.flags & SCOPE_FUNCTION2) {
            return (scope.flags & SCOPE_ASYNC2) > 0;
          }
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      };
      prototypeAccessors2.allowSuper.get = function() {
        var ref3 = this.currentThisScope();
        var flags = ref3.flags;
        var inClassFieldInit = ref3.inClassFieldInit;
        return (flags & SCOPE_SUPER2) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
      };
      prototypeAccessors2.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER2) > 0;
      };
      prototypeAccessors2.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      };
      prototypeAccessors2.allowNewDotTarget.get = function() {
        var ref3 = this.currentThisScope();
        var flags = ref3.flags;
        var inClassFieldInit = ref3.inClassFieldInit;
        return (flags & (SCOPE_FUNCTION2 | SCOPE_CLASS_STATIC_BLOCK2)) > 0 || inClassFieldInit;
      };
      prototypeAccessors2.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK2) > 0;
      };
      Parser3.extend = function extend3() {
        var plugins = [], len = arguments.length;
        while (len--) plugins[len] = arguments[len];
        var cls = this;
        for (var i2 = 0; i2 < plugins.length; i2++) {
          cls = plugins[i2](cls);
        }
        return cls;
      };
      Parser3.parse = function parse6(input, options) {
        return new this(options, input).parse();
      };
      Parser3.parseExpressionAt = function parseExpressionAt4(input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression();
      };
      Parser3.tokenizer = function tokenizer4(input, options) {
        return new this(options, input);
      };
      Object.defineProperties(Parser3.prototype, prototypeAccessors2);
      var pp$92 = Parser3.prototype;
      var literal2 = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      pp$92.strictDirective = function(start3) {
        if (this.options.ecmaVersion < 5) {
          return false;
        }
        for (; ; ) {
          skipWhiteSpace2.lastIndex = start3;
          start3 += skipWhiteSpace2.exec(this.input)[0].length;
          var match = literal2.exec(this.input.slice(start3));
          if (!match) {
            return false;
          }
          if ((match[1] || match[2]) === "use strict") {
            skipWhiteSpace2.lastIndex = start3 + match[0].length;
            var spaceAfter = skipWhiteSpace2.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
            var next = this.input.charAt(end);
            return next === ";" || next === "}" || lineBreak2.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
          }
          start3 += match[0].length;
          skipWhiteSpace2.lastIndex = start3;
          start3 += skipWhiteSpace2.exec(this.input)[0].length;
          if (this.input[start3] === ";") {
            start3++;
          }
        }
      };
      pp$92.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true;
        } else {
          return false;
        }
      };
      pp$92.isContextual = function(name2) {
        return this.type === types$12.name && this.value === name2 && !this.containsEsc;
      };
      pp$92.eatContextual = function(name2) {
        if (!this.isContextual(name2)) {
          return false;
        }
        this.next();
        return true;
      };
      pp$92.expectContextual = function(name2) {
        if (!this.eatContextual(name2)) {
          this.unexpected();
        }
      };
      pp$92.canInsertSemicolon = function() {
        return this.type === types$12.eof || this.type === types$12.braceR || lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$92.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon) {
            this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
          }
          return true;
        }
      };
      pp$92.semicolon = function() {
        if (!this.eat(types$12.semi) && !this.insertSemicolon()) {
          this.unexpected();
        }
      };
      pp$92.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma) {
            this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
          }
          if (!notNext) {
            this.next();
          }
          return true;
        }
      };
      pp$92.expect = function(type) {
        this.eat(type) || this.unexpected();
      };
      pp$92.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };
      var DestructuringErrors3 = function DestructuringErrors4() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      pp$92.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) {
          return;
        }
        if (refDestructuringErrors.trailingComma > -1) {
          this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
        }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) {
          this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      };
      pp$92.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) {
          return false;
        }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) {
          return shorthandAssign >= 0 || doubleProto >= 0;
        }
        if (shorthandAssign >= 0) {
          this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
        }
        if (doubleProto >= 0) {
          this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
        }
      };
      pp$92.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
          this.raise(this.yieldPos, "Yield expression cannot be a default value");
        }
        if (this.awaitPos) {
          this.raise(this.awaitPos, "Await expression cannot be a default value");
        }
      };
      pp$92.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression") {
          return this.isSimpleAssignTarget(expr.expression);
        }
        return expr.type === "Identifier" || expr.type === "MemberExpression";
      };
      var pp$82 = Parser3.prototype;
      pp$82.parseTopLevel = function(node2) {
        var exports3 = /* @__PURE__ */ Object.create(null);
        if (!node2.body) {
          node2.body = [];
        }
        while (this.type !== types$12.eof) {
          var stmt = this.parseStatement(null, true, exports3);
          node2.body.push(stmt);
        }
        if (this.inModule) {
          for (var i2 = 0, list4 = Object.keys(this.undefinedExports); i2 < list4.length; i2 += 1) {
            var name2 = list4[i2];
            this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
          }
        }
        this.adaptDirectivePrologue(node2.body);
        this.next();
        node2.sourceType = this.options.sourceType;
        return this.finishNode(node2, "Program");
      };
      var loopLabel2 = { kind: "loop" }, switchLabel2 = { kind: "switch" };
      pp$82.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
          return false;
        }
        skipWhiteSpace2.lastIndex = this.pos;
        var skip = skipWhiteSpace2.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91 || nextCh === 92) {
          return true;
        }
        if (context) {
          return false;
        }
        if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
          return true;
        }
        if (isIdentifierStart2(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar2(nextCh = this.input.charCodeAt(pos), true)) {
            ++pos;
          }
          if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
            return true;
          }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator2.test(ident)) {
            return true;
          }
        }
        return false;
      };
      pp$82.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
          return false;
        }
        skipWhiteSpace2.lastIndex = this.pos;
        var skip = skipWhiteSpace2.exec(this.input);
        var next = this.pos + skip[0].length, after;
        return !lineBreak2.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar2(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
      };
      pp$82.parseStatement = function(context, topLevel, exports3) {
        var starttype = this.type, node2 = this.startNode(), kind;
        if (this.isLet(context)) {
          starttype = types$12._var;
          kind = "let";
        }
        switch (starttype) {
          case types$12._break:
          case types$12._continue:
            return this.parseBreakContinueStatement(node2, starttype.keyword);
          case types$12._debugger:
            return this.parseDebuggerStatement(node2);
          case types$12._do:
            return this.parseDoStatement(node2);
          case types$12._for:
            return this.parseForStatement(node2);
          case types$12._function:
            if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
              this.unexpected();
            }
            return this.parseFunctionStatement(node2, false, !context);
          case types$12._class:
            if (context) {
              this.unexpected();
            }
            return this.parseClass(node2, true);
          case types$12._if:
            return this.parseIfStatement(node2);
          case types$12._return:
            return this.parseReturnStatement(node2);
          case types$12._switch:
            return this.parseSwitchStatement(node2);
          case types$12._throw:
            return this.parseThrowStatement(node2);
          case types$12._try:
            return this.parseTryStatement(node2);
          case types$12._const:
          case types$12._var:
            kind = kind || this.value;
            if (context && kind !== "var") {
              this.unexpected();
            }
            return this.parseVarStatement(node2, kind);
          case types$12._while:
            return this.parseWhileStatement(node2);
          case types$12._with:
            return this.parseWithStatement(node2);
          case types$12.braceL:
            return this.parseBlock(true, node2);
          case types$12.semi:
            return this.parseEmptyStatement(node2);
          case types$12._export:
          case types$12._import:
            if (this.options.ecmaVersion > 10 && starttype === types$12._import) {
              skipWhiteSpace2.lastIndex = this.pos;
              var skip = skipWhiteSpace2.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40 || nextCh === 46) {
                return this.parseExpressionStatement(node2, this.parseExpression());
              }
            }
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel) {
                this.raise(this.start, "'import' and 'export' may only appear at the top level");
              }
              if (!this.inModule) {
                this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
              }
            }
            return starttype === types$12._import ? this.parseImport(node2) : this.parseExport(node2, exports3);
          // If the statement does not start with a statement keyword or a
          // brace, it's an ExpressionStatement or LabeledStatement. We
          // simply start parsing an expression, and afterwards, if the
          // next token is a colon and the expression was a simple
          // Identifier node, we switch to interpreting it as a label.
          default:
            if (this.isAsyncFunction()) {
              if (context) {
                this.unexpected();
              }
              this.next();
              return this.parseFunctionStatement(node2, true, !context);
            }
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types$12.name && expr.type === "Identifier" && this.eat(types$12.colon)) {
              return this.parseLabeledStatement(node2, maybeName, expr, context);
            } else {
              return this.parseExpressionStatement(node2, expr);
            }
        }
      };
      pp$82.parseBreakContinueStatement = function(node2, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types$12.semi) || this.insertSemicolon()) {
          node2.label = null;
        } else if (this.type !== types$12.name) {
          this.unexpected();
        } else {
          node2.label = this.parseIdent();
          this.semicolon();
        }
        var i2 = 0;
        for (; i2 < this.labels.length; ++i2) {
          var lab = this.labels[i2];
          if (node2.label == null || lab.name === node2.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) {
              break;
            }
            if (node2.label && isBreak) {
              break;
            }
          }
        }
        if (i2 === this.labels.length) {
          this.raise(node2.start, "Unsyntactic " + keyword);
        }
        return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
      };
      pp$82.parseDebuggerStatement = function(node2) {
        this.next();
        this.semicolon();
        return this.finishNode(node2, "DebuggerStatement");
      };
      pp$82.parseDoStatement = function(node2) {
        this.next();
        this.labels.push(loopLabel2);
        node2.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types$12._while);
        node2.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6) {
          this.eat(types$12.semi);
        } else {
          this.semicolon();
        }
        return this.finishNode(node2, "DoWhileStatement");
      };
      pp$82.parseForStatement = function(node2) {
        this.next();
        var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        this.labels.push(loopLabel2);
        this.enterScope(0);
        this.expect(types$12.parenL);
        if (this.type === types$12.semi) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, null);
        }
        var isLet = this.isLet();
        if (this.type === types$12._var || this.type === types$12._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types$12._in) {
                if (awaitAt > -1) {
                  this.unexpected(awaitAt);
                }
              } else {
                node2.await = awaitAt > -1;
              }
            }
            return this.parseForIn(node2, init$1);
          }
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node2, init$1);
        }
        var startsWithLet = this.isContextual("let"), isForOf = false;
        var refDestructuringErrors = new DestructuringErrors3();
        var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
        if (this.type === types$12._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types$12._in) {
              if (awaitAt > -1) {
                this.unexpected(awaitAt);
              }
            } else {
              node2.await = awaitAt > -1;
            }
          }
          if (startsWithLet && isForOf) {
            this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
          }
          this.toAssignable(init2, false, refDestructuringErrors);
          this.checkLValPattern(init2);
          return this.parseForIn(node2, init2);
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node2, init2);
      };
      pp$82.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node2, FUNC_STATEMENT2 | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT2), false, isAsync);
      };
      pp$82.parseIfStatement = function(node2) {
        this.next();
        node2.test = this.parseParenExpression();
        node2.consequent = this.parseStatement("if");
        node2.alternate = this.eat(types$12._else) ? this.parseStatement("if") : null;
        return this.finishNode(node2, "IfStatement");
      };
      pp$82.parseReturnStatement = function(node2) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
          this.raise(this.start, "'return' outside of function");
        }
        this.next();
        if (this.eat(types$12.semi) || this.insertSemicolon()) {
          node2.argument = null;
        } else {
          node2.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node2, "ReturnStatement");
      };
      pp$82.parseSwitchStatement = function(node2) {
        this.next();
        node2.discriminant = this.parseParenExpression();
        node2.cases = [];
        this.expect(types$12.braceL);
        this.labels.push(switchLabel2);
        this.enterScope(0);
        var cur;
        for (var sawDefault = false; this.type !== types$12.braceR; ) {
          if (this.type === types$12._case || this.type === types$12._default) {
            var isCase = this.type === types$12._case;
            if (cur) {
              this.finishNode(cur, "SwitchCase");
            }
            node2.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types$12.colon);
          } else {
            if (!cur) {
              this.unexpected();
            }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) {
          this.finishNode(cur, "SwitchCase");
        }
        this.next();
        this.labels.pop();
        return this.finishNode(node2, "SwitchStatement");
      };
      pp$82.parseThrowStatement = function(node2) {
        this.next();
        if (lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) {
          this.raise(this.lastTokEnd, "Illegal newline after throw");
        }
        node2.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node2, "ThrowStatement");
      };
      var empty$12 = [];
      pp$82.parseTryStatement = function(node2) {
        this.next();
        node2.block = this.parseBlock();
        node2.handler = null;
        if (this.type === types$12._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types$12.parenL)) {
            clause.param = this.parseBindingAtom();
            var simple = clause.param.type === "Identifier";
            this.enterScope(simple ? SCOPE_SIMPLE_CATCH2 : 0);
            this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH2 : BIND_LEXICAL2);
            this.expect(types$12.parenR);
          } else {
            if (this.options.ecmaVersion < 10) {
              this.unexpected();
            }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node2.handler = this.finishNode(clause, "CatchClause");
        }
        node2.finalizer = this.eat(types$12._finally) ? this.parseBlock() : null;
        if (!node2.handler && !node2.finalizer) {
          this.raise(node2.start, "Missing catch or finally clause");
        }
        return this.finishNode(node2, "TryStatement");
      };
      pp$82.parseVarStatement = function(node2, kind) {
        this.next();
        this.parseVar(node2, false, kind);
        this.semicolon();
        return this.finishNode(node2, "VariableDeclaration");
      };
      pp$82.parseWhileStatement = function(node2) {
        this.next();
        node2.test = this.parseParenExpression();
        this.labels.push(loopLabel2);
        node2.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node2, "WhileStatement");
      };
      pp$82.parseWithStatement = function(node2) {
        if (this.strict) {
          this.raise(this.start, "'with' in strict mode");
        }
        this.next();
        node2.object = this.parseParenExpression();
        node2.body = this.parseStatement("with");
        return this.finishNode(node2, "WithStatement");
      };
      pp$82.parseEmptyStatement = function(node2) {
        this.next();
        return this.finishNode(node2, "EmptyStatement");
      };
      pp$82.parseLabeledStatement = function(node2, maybeName, expr, context) {
        for (var i$1 = 0, list4 = this.labels; i$1 < list4.length; i$1 += 1) {
          var label = list4[i$1];
          if (label.name === maybeName) {
            this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          }
        }
        var kind = this.type.isLoop ? "loop" : this.type === types$12._switch ? "switch" : null;
        for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
          var label$1 = this.labels[i2];
          if (label$1.statementStart === node2.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else {
            break;
          }
        }
        this.labels.push({ name: maybeName, kind, statementStart: this.start });
        node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node2.label = expr;
        return this.finishNode(node2, "LabeledStatement");
      };
      pp$82.parseExpressionStatement = function(node2, expr) {
        node2.expression = expr;
        this.semicolon();
        return this.finishNode(node2, "ExpressionStatement");
      };
      pp$82.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
        if (createNewLexicalScope === void 0) createNewLexicalScope = true;
        if (node2 === void 0) node2 = this.startNode();
        node2.body = [];
        this.expect(types$12.braceL);
        if (createNewLexicalScope) {
          this.enterScope(0);
        }
        while (this.type !== types$12.braceR) {
          var stmt = this.parseStatement(null);
          node2.body.push(stmt);
        }
        if (exitStrict) {
          this.strict = false;
        }
        this.next();
        if (createNewLexicalScope) {
          this.exitScope();
        }
        return this.finishNode(node2, "BlockStatement");
      };
      pp$82.parseFor = function(node2, init2) {
        node2.init = init2;
        this.expect(types$12.semi);
        node2.test = this.type === types$12.semi ? null : this.parseExpression();
        this.expect(types$12.semi);
        node2.update = this.type === types$12.parenR ? null : this.parseExpression();
        this.expect(types$12.parenR);
        node2.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node2, "ForStatement");
      };
      pp$82.parseForIn = function(node2, init2) {
        var isForIn = this.type === types$12._in;
        this.next();
        if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
          this.raise(
            init2.start,
            (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
          );
        }
        node2.left = init2;
        node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types$12.parenR);
        node2.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
      };
      pp$82.parseVar = function(node2, isFor, kind) {
        node2.declarations = [];
        node2.kind = kind;
        for (; ; ) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types$12.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (kind === "const" && !(this.type === types$12._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            this.unexpected();
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$12._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types$12.comma)) {
            break;
          }
        }
        return node2;
      };
      pp$82.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR2 : BIND_LEXICAL2, false);
      };
      var FUNC_STATEMENT2 = 1, FUNC_HANGING_STATEMENT2 = 2, FUNC_NULLABLE_ID2 = 4;
      pp$82.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types$12.star && statement & FUNC_HANGING_STATEMENT2) {
            this.unexpected();
          }
          node2.generator = this.eat(types$12.star);
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        if (statement & FUNC_STATEMENT2) {
          node2.id = statement & FUNC_NULLABLE_ID2 && this.type !== types$12.name ? null : this.parseIdent();
          if (node2.id && !(statement & FUNC_HANGING_STATEMENT2)) {
            this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR2 : BIND_LEXICAL2 : BIND_FUNCTION2);
          }
        }
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(node2.async, node2.generator));
        if (!(statement & FUNC_STATEMENT2)) {
          node2.id = this.type === types$12.name ? this.parseIdent() : null;
        }
        this.parseFunctionParams(node2);
        this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, statement & FUNC_STATEMENT2 ? "FunctionDeclaration" : "FunctionExpression");
      };
      pp$82.parseFunctionParams = function(node2) {
        this.expect(types$12.parenL);
        node2.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };
      pp$82.parseClass = function(node2, isStatement) {
        this.next();
        var oldStrict = this.strict;
        this.strict = true;
        this.parseClassId(node2, isStatement);
        this.parseClassSuper(node2);
        var privateNameMap = this.enterClassBody();
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types$12.braceL);
        while (this.type !== types$12.braceR) {
          var element2 = this.parseClassElement(node2.superClass !== null);
          if (element2) {
            classBody.body.push(element2);
            if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
              if (hadConstructor) {
                this.raise(element2.start, "Duplicate constructor in the same class");
              }
              hadConstructor = true;
            } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted2(privateNameMap, element2)) {
              this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
            }
          }
        }
        this.strict = oldStrict;
        this.next();
        node2.body = this.finishNode(classBody, "ClassBody");
        this.exitClassBody();
        return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
      };
      pp$82.parseClassElement = function(constructorAllowsSuper) {
        if (this.eat(types$12.semi)) {
          return null;
        }
        var ecmaVersion2 = this.options.ecmaVersion;
        var node2 = this.startNode();
        var keyName = "";
        var isGenerator = false;
        var isAsync = false;
        var kind = "method";
        var isStatic = false;
        if (this.eatContextual("static")) {
          if (ecmaVersion2 >= 13 && this.eat(types$12.braceL)) {
            this.parseClassStaticBlock(node2);
            return node2;
          }
          if (this.isClassElementNameStart() || this.type === types$12.star) {
            isStatic = true;
          } else {
            keyName = "static";
          }
        }
        node2.static = isStatic;
        if (!keyName && ecmaVersion2 >= 8 && this.eatContextual("async")) {
          if ((this.isClassElementNameStart() || this.type === types$12.star) && !this.canInsertSemicolon()) {
            isAsync = true;
          } else {
            keyName = "async";
          }
        }
        if (!keyName && (ecmaVersion2 >= 9 || !isAsync) && this.eat(types$12.star)) {
          isGenerator = true;
        }
        if (!keyName && !isAsync && !isGenerator) {
          var lastValue = this.value;
          if (this.eatContextual("get") || this.eatContextual("set")) {
            if (this.isClassElementNameStart()) {
              kind = lastValue;
            } else {
              keyName = lastValue;
            }
          }
        }
        if (keyName) {
          node2.computed = false;
          node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
          node2.key.name = keyName;
          this.finishNode(node2.key, "Identifier");
        } else {
          this.parseClassElementName(node2);
        }
        if (ecmaVersion2 < 13 || this.type === types$12.parenL || kind !== "method" || isGenerator || isAsync) {
          var isConstructor = !node2.static && checkKeyName2(node2, "constructor");
          var allowsDirectSuper = isConstructor && constructorAllowsSuper;
          if (isConstructor && kind !== "method") {
            this.raise(node2.key.start, "Constructor can't have get/set modifier");
          }
          node2.kind = isConstructor ? "constructor" : kind;
          this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
        } else {
          this.parseClassField(node2);
        }
        return node2;
      };
      pp$82.isClassElementNameStart = function() {
        return this.type === types$12.name || this.type === types$12.privateId || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword;
      };
      pp$82.parseClassElementName = function(element2) {
        if (this.type === types$12.privateId) {
          if (this.value === "constructor") {
            this.raise(this.start, "Classes can't have an element named '#constructor'");
          }
          element2.computed = false;
          element2.key = this.parsePrivateIdent();
        } else {
          this.parsePropertyName(element2);
        }
      };
      pp$82.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        var key = method.key;
        if (method.kind === "constructor") {
          if (isGenerator) {
            this.raise(key.start, "Constructor can't be a generator");
          }
          if (isAsync) {
            this.raise(key.start, "Constructor can't be an async method");
          }
        } else if (method.static && checkKeyName2(method, "prototype")) {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && value.params.length !== 0) {
          this.raiseRecoverable(value.start, "getter should have no params");
        }
        if (method.kind === "set" && value.params.length !== 1) {
          this.raiseRecoverable(value.start, "setter should have exactly one param");
        }
        if (method.kind === "set" && value.params[0].type === "RestElement") {
          this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
        }
        return this.finishNode(method, "MethodDefinition");
      };
      pp$82.parseClassField = function(field) {
        if (checkKeyName2(field, "constructor")) {
          this.raise(field.key.start, "Classes can't have a field named 'constructor'");
        } else if (field.static && checkKeyName2(field, "prototype")) {
          this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
        }
        if (this.eat(types$12.eq)) {
          var scope = this.currentThisScope();
          var inClassFieldInit = scope.inClassFieldInit;
          scope.inClassFieldInit = true;
          field.value = this.parseMaybeAssign();
          scope.inClassFieldInit = inClassFieldInit;
        } else {
          field.value = null;
        }
        this.semicolon();
        return this.finishNode(field, "PropertyDefinition");
      };
      pp$82.parseClassStaticBlock = function(node2) {
        node2.body = [];
        var oldLabels = this.labels;
        this.labels = [];
        this.enterScope(SCOPE_CLASS_STATIC_BLOCK2 | SCOPE_SUPER2);
        while (this.type !== types$12.braceR) {
          var stmt = this.parseStatement(null);
          node2.body.push(stmt);
        }
        this.next();
        this.exitScope();
        this.labels = oldLabels;
        return this.finishNode(node2, "StaticBlock");
      };
      pp$82.parseClassId = function(node2, isStatement) {
        if (this.type === types$12.name) {
          node2.id = this.parseIdent();
          if (isStatement) {
            this.checkLValSimple(node2.id, BIND_LEXICAL2, false);
          }
        } else {
          if (isStatement === true) {
            this.unexpected();
          }
          node2.id = null;
        }
      };
      pp$82.parseClassSuper = function(node2) {
        node2.superClass = this.eat(types$12._extends) ? this.parseExprSubscripts(null, false) : null;
      };
      pp$82.enterClassBody = function() {
        var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        this.privateNameStack.push(element2);
        return element2.declared;
      };
      pp$82.exitClassBody = function() {
        var ref3 = this.privateNameStack.pop();
        var declared = ref3.declared;
        var used = ref3.used;
        var len = this.privateNameStack.length;
        var parent = len === 0 ? null : this.privateNameStack[len - 1];
        for (var i2 = 0; i2 < used.length; ++i2) {
          var id2 = used[i2];
          if (!hasOwn2(declared, id2.name)) {
            if (parent) {
              parent.used.push(id2);
            } else {
              this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
            }
          }
        }
      };
      function isPrivateNameConflicted2(privateNameMap, element2) {
        var name2 = element2.key.name;
        var curr = privateNameMap[name2];
        var next = "true";
        if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
          next = (element2.static ? "s" : "i") + element2.kind;
        }
        if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
          privateNameMap[name2] = "true";
          return false;
        } else if (!curr) {
          privateNameMap[name2] = next;
          return false;
        } else {
          return true;
        }
      }
      function checkKeyName2(node2, name2) {
        var computed = node2.computed;
        var key = node2.key;
        return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
      }
      pp$82.parseExport = function(node2, exports3) {
        this.next();
        if (this.eat(types$12.star)) {
          if (this.options.ecmaVersion >= 11) {
            if (this.eatContextual("as")) {
              node2.exported = this.parseModuleExportName();
              this.checkExport(exports3, node2.exported, this.lastTokStart);
            } else {
              node2.exported = null;
            }
          }
          this.expectContextual("from");
          if (this.type !== types$12.string) {
            this.unexpected();
          }
          node2.source = this.parseExprAtom();
          this.semicolon();
          return this.finishNode(node2, "ExportAllDeclaration");
        }
        if (this.eat(types$12._default)) {
          this.checkExport(exports3, "default", this.lastTokStart);
          var isAsync;
          if (this.type === types$12._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) {
              this.next();
            }
            node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT2 | FUNC_NULLABLE_ID2, false, isAsync);
          } else if (this.type === types$12._class) {
            var cNode = this.startNode();
            node2.declaration = this.parseClass(cNode, "nullableID");
          } else {
            node2.declaration = this.parseMaybeAssign();
            this.semicolon();
          }
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        if (this.shouldParseExportStatement()) {
          node2.declaration = this.parseStatement(null);
          if (node2.declaration.type === "VariableDeclaration") {
            this.checkVariableExport(exports3, node2.declaration.declarations);
          } else {
            this.checkExport(exports3, node2.declaration.id, node2.declaration.id.start);
          }
          node2.specifiers = [];
          node2.source = null;
        } else {
          node2.declaration = null;
          node2.specifiers = this.parseExportSpecifiers(exports3);
          if (this.eatContextual("from")) {
            if (this.type !== types$12.string) {
              this.unexpected();
            }
            node2.source = this.parseExprAtom();
          } else {
            for (var i2 = 0, list4 = node2.specifiers; i2 < list4.length; i2 += 1) {
              var spec = list4[i2];
              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
              if (spec.local.type === "Literal") {
                this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
              }
            }
            node2.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node2, "ExportNamedDeclaration");
      };
      pp$82.checkExport = function(exports3, name2, pos) {
        if (!exports3) {
          return;
        }
        if (typeof name2 !== "string") {
          name2 = name2.type === "Identifier" ? name2.name : name2.value;
        }
        if (hasOwn2(exports3, name2)) {
          this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
        }
        exports3[name2] = true;
      };
      pp$82.checkPatternExport = function(exports3, pat) {
        var type = pat.type;
        if (type === "Identifier") {
          this.checkExport(exports3, pat, pat.start);
        } else if (type === "ObjectPattern") {
          for (var i2 = 0, list4 = pat.properties; i2 < list4.length; i2 += 1) {
            var prop = list4[i2];
            this.checkPatternExport(exports3, prop);
          }
        } else if (type === "ArrayPattern") {
          for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];
            if (elt) {
              this.checkPatternExport(exports3, elt);
            }
          }
        } else if (type === "Property") {
          this.checkPatternExport(exports3, pat.value);
        } else if (type === "AssignmentPattern") {
          this.checkPatternExport(exports3, pat.left);
        } else if (type === "RestElement") {
          this.checkPatternExport(exports3, pat.argument);
        } else if (type === "ParenthesizedExpression") {
          this.checkPatternExport(exports3, pat.expression);
        }
      };
      pp$82.checkVariableExport = function(exports3, decls) {
        if (!exports3) {
          return;
        }
        for (var i2 = 0, list4 = decls; i2 < list4.length; i2 += 1) {
          var decl = list4[i2];
          this.checkPatternExport(exports3, decl.id);
        }
      };
      pp$82.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      };
      pp$82.parseExportSpecifiers = function(exports3) {
        var nodes = [], first = true;
        this.expect(types$12.braceL);
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node2 = this.startNode();
          node2.local = this.parseModuleExportName();
          node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
          this.checkExport(
            exports3,
            node2.exported,
            node2.exported.start
          );
          nodes.push(this.finishNode(node2, "ExportSpecifier"));
        }
        return nodes;
      };
      pp$82.parseImport = function(node2) {
        this.next();
        if (this.type === types$12.string) {
          node2.specifiers = empty$12;
          node2.source = this.parseExprAtom();
        } else {
          node2.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node2.source = this.type === types$12.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node2, "ImportDeclaration");
      };
      pp$82.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types$12.name) {
          var node2 = this.startNode();
          node2.local = this.parseIdent();
          this.checkLValSimple(node2.local, BIND_LEXICAL2);
          nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
          if (!this.eat(types$12.comma)) {
            return nodes;
          }
        }
        if (this.type === types$12.star) {
          var node$1 = this.startNode();
          this.next();
          this.expectContextual("as");
          node$1.local = this.parseIdent();
          this.checkLValSimple(node$1.local, BIND_LEXICAL2);
          nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
          return nodes;
        }
        this.expect(types$12.braceL);
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var node$2 = this.startNode();
          node$2.imported = this.parseModuleExportName();
          if (this.eatContextual("as")) {
            node$2.local = this.parseIdent();
          } else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
          }
          this.checkLValSimple(node$2.local, BIND_LEXICAL2);
          nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes;
      };
      pp$82.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === types$12.string) {
          var stringLiteral = this.parseLiteral(this.value);
          if (loneSurrogate2.test(stringLiteral.value)) {
            this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
          }
          return stringLiteral;
        }
        return this.parseIdent(true);
      };
      pp$82.adaptDirectivePrologue = function(statements) {
        for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
          statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
        }
      };
      pp$82.isDirectiveCandidate = function(statement) {
        return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
        (this.input[statement.start] === '"' || this.input[statement.start] === "'");
      };
      var pp$72 = Parser3.prototype;
      pp$72.toAssignable = function(node2, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node2) {
          switch (node2.type) {
            case "Identifier":
              if (this.inAsync && node2.name === "await") {
                this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
              }
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              node2.type = "ObjectPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              for (var i2 = 0, list4 = node2.properties; i2 < list4.length; i2 += 1) {
                var prop = list4[i2];
                this.toAssignable(prop, isBinding);
                if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break;
            case "Property":
              if (node2.kind !== "init") {
                this.raise(node2.key.start, "Object pattern can't contain getter or setter");
              }
              this.toAssignable(node2.value, isBinding);
              break;
            case "ArrayExpression":
              node2.type = "ArrayPattern";
              if (refDestructuringErrors) {
                this.checkPatternErrors(refDestructuringErrors, true);
              }
              this.toAssignableList(node2.elements, isBinding);
              break;
            case "SpreadElement":
              node2.type = "RestElement";
              this.toAssignable(node2.argument, isBinding);
              if (node2.argument.type === "AssignmentPattern") {
                this.raise(node2.argument.start, "Rest elements cannot have a default value");
              }
              break;
            case "AssignmentExpression":
              if (node2.operator !== "=") {
                this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
              }
              node2.type = "AssignmentPattern";
              delete node2.operator;
              this.toAssignable(node2.left, isBinding);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
              break;
            case "ChainExpression":
              this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!isBinding) {
                break;
              }
            default:
              this.raise(node2.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        return node2;
      };
      pp$72.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i2 = 0; i2 < end; i2++) {
          var elt = exprList[i2];
          if (elt) {
            this.toAssignable(elt, isBinding);
          }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
            this.unexpected(last.argument.start);
          }
        }
        return exprList;
      };
      pp$72.parseSpread = function(refDestructuringErrors) {
        var node2 = this.startNode();
        this.next();
        node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node2, "SpreadElement");
      };
      pp$72.parseRestBinding = function() {
        var node2 = this.startNode();
        this.next();
        if (this.options.ecmaVersion === 6 && this.type !== types$12.name) {
          this.unexpected();
        }
        node2.argument = this.parseBindingAtom();
        return this.finishNode(node2, "RestElement");
      };
      pp$72.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
            case types$12.bracketL:
              var node2 = this.startNode();
              this.next();
              node2.elements = this.parseBindingList(types$12.bracketR, true, true);
              return this.finishNode(node2, "ArrayPattern");
            case types$12.braceL:
              return this.parseObj(true);
          }
        }
        return this.parseIdent();
      };
      pp$72.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(types$12.comma);
          }
          if (allowEmpty && this.type === types$12.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break;
          } else if (this.type === types$12.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types$12.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            this.expect(close);
            break;
          } else {
            var elem = this.parseMaybeDefault(this.start, this.startLoc);
            this.parseBindingListItem(elem);
            elts.push(elem);
          }
        }
        return elts;
      };
      pp$72.parseBindingListItem = function(param) {
        return param;
      };
      pp$72.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types$12.eq)) {
          return left;
        }
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.left = left;
        node2.right = this.parseMaybeAssign();
        return this.finishNode(node2, "AssignmentPattern");
      };
      pp$72.checkLValSimple = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        var isBind = bindingType !== BIND_NONE2;
        switch (expr.type) {
          case "Identifier":
            if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
              this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
            }
            if (isBind) {
              if (bindingType === BIND_LEXICAL2 && expr.name === "let") {
                this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
              }
              if (checkClashes) {
                if (hasOwn2(checkClashes, expr.name)) {
                  this.raiseRecoverable(expr.start, "Argument name clash");
                }
                checkClashes[expr.name] = true;
              }
              if (bindingType !== BIND_OUTSIDE2) {
                this.declareName(expr.name, bindingType, expr.start);
              }
            }
            break;
          case "ChainExpression":
            this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding member expression");
            }
            break;
          case "ParenthesizedExpression":
            if (isBind) {
              this.raiseRecoverable(expr.start, "Binding parenthesized expression");
            }
            return this.checkLValSimple(expr.expression, bindingType, checkClashes);
          default:
            this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
        }
      };
      pp$72.checkLValPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        switch (expr.type) {
          case "ObjectPattern":
            for (var i2 = 0, list4 = expr.properties; i2 < list4.length; i2 += 1) {
              var prop = list4[i2];
              this.checkLValInnerPattern(prop, bindingType, checkClashes);
            }
            break;
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
              if (elem) {
                this.checkLValInnerPattern(elem, bindingType, checkClashes);
              }
            }
            break;
          default:
            this.checkLValSimple(expr, bindingType, checkClashes);
        }
      };
      pp$72.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
        if (bindingType === void 0) bindingType = BIND_NONE2;
        switch (expr.type) {
          case "Property":
            this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(expr.left, bindingType, checkClashes);
            break;
          case "RestElement":
            this.checkLValPattern(expr.argument, bindingType, checkClashes);
            break;
          default:
            this.checkLValPattern(expr, bindingType, checkClashes);
        }
      };
      var TokContext3 = function TokContext4(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };
      var types3 = {
        b_stat: new TokContext3("{", false),
        b_expr: new TokContext3("{", true),
        b_tmpl: new TokContext3("${", false),
        p_stat: new TokContext3("(", false),
        p_expr: new TokContext3("(", true),
        q_tmpl: new TokContext3("`", true, true, function(p) {
          return p.tryReadTemplateToken();
        }),
        f_stat: new TokContext3("function", false),
        f_expr: new TokContext3("function", true),
        f_expr_gen: new TokContext3("function", true, false, null, true),
        f_gen: new TokContext3("function", false, false, null, true)
      };
      var pp$62 = Parser3.prototype;
      pp$62.initialContext = function() {
        return [types3.b_stat];
      };
      pp$62.curContext = function() {
        return this.context[this.context.length - 1];
      };
      pp$62.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types3.f_expr || parent === types3.f_stat) {
          return true;
        }
        if (prevType === types$12.colon && (parent === types3.b_stat || parent === types3.b_expr)) {
          return !parent.isExpr;
        }
        if (prevType === types$12._return || prevType === types$12.name && this.exprAllowed) {
          return lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
        }
        if (prevType === types$12._else || prevType === types$12.semi || prevType === types$12.eof || prevType === types$12.parenR || prevType === types$12.arrow) {
          return true;
        }
        if (prevType === types$12.braceL) {
          return parent === types3.b_stat;
        }
        if (prevType === types$12._var || prevType === types$12._const || prevType === types$12.name) {
          return false;
        }
        return !this.exprAllowed;
      };
      pp$62.inGeneratorContext = function() {
        for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
          var context = this.context[i2];
          if (context.token === "function") {
            return context.generator;
          }
        }
        return false;
      };
      pp$62.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types$12.dot) {
          this.exprAllowed = false;
        } else if (update = type.updateContext) {
          update.call(this, prevType);
        } else {
          this.exprAllowed = type.beforeExpr;
        }
      };
      pp$62.overrideContext = function(tokenCtx) {
        if (this.curContext() !== tokenCtx) {
          this.context[this.context.length - 1] = tokenCtx;
        }
      };
      types$12.parenR.updateContext = types$12.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return;
        }
        var out = this.context.pop();
        if (out === types3.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };
      types$12.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types3.b_stat : types3.b_expr);
        this.exprAllowed = true;
      };
      types$12.dollarBraceL.updateContext = function() {
        this.context.push(types3.b_tmpl);
        this.exprAllowed = true;
      };
      types$12.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types$12._if || prevType === types$12._for || prevType === types$12._with || prevType === types$12._while;
        this.context.push(statementParens ? types3.p_stat : types3.p_expr);
        this.exprAllowed = true;
      };
      types$12.incDec.updateContext = function() {
      };
      types$12._function.updateContext = types$12._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types$12._else && !(prevType === types$12.semi && this.curContext() !== types3.p_stat) && !(prevType === types$12._return && lineBreak2.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$12.colon || prevType === types$12.braceL) && this.curContext() === types3.b_stat)) {
          this.context.push(types3.f_expr);
        } else {
          this.context.push(types3.f_stat);
        }
        this.exprAllowed = false;
      };
      types$12.backQuote.updateContext = function() {
        if (this.curContext() === types3.q_tmpl) {
          this.context.pop();
        } else {
          this.context.push(types3.q_tmpl);
        }
        this.exprAllowed = false;
      };
      types$12.star.updateContext = function(prevType) {
        if (prevType === types$12._function) {
          var index2 = this.context.length - 1;
          if (this.context[index2] === types3.f_expr) {
            this.context[index2] = types3.f_expr_gen;
          } else {
            this.context[index2] = types3.f_gen;
          }
        }
        this.exprAllowed = true;
      };
      types$12.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types$12.dot) {
          if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
            allowed = true;
          }
        }
        this.exprAllowed = allowed;
      };
      var pp$52 = Parser3.prototype;
      pp$52.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
          return;
        }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
          return;
        }
        var key = prop.key;
        var name2;
        switch (key.type) {
          case "Identifier":
            name2 = key.name;
            break;
          case "Literal":
            name2 = String(key.value);
            break;
          default:
            return;
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name2 === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0) {
                  refDestructuringErrors.doubleProto = key.start;
                }
              } else {
                this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
              }
            }
            propHash.proto = true;
          }
          return;
        }
        name2 = "$" + name2;
        var other = propHash[name2];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition) {
            this.raiseRecoverable(key.start, "Redefinition of property");
          }
        } else {
          other = propHash[name2] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };
      pp$52.parseExpression = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
        if (this.type === types$12.comma) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.expressions = [expr];
          while (this.eat(types$12.comma)) {
            node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
          }
          return this.finishNode(node2, "SequenceExpression");
        }
        return expr;
      };
      pp$52.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) {
            return this.parseYield(forInit);
          } else {
            this.exprAllowed = false;
          }
        }
        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          oldDoubleProto = refDestructuringErrors.doubleProto;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors3();
          ownDestructuringErrors = true;
        }
        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types$12.parenL || this.type === types$12.name) {
          this.potentialArrowAt = this.start;
          this.potentialArrowInForAwait = forInit === "await";
        }
        var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startPos, startLoc);
        }
        if (this.type.isAssign) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.operator = this.value;
          if (this.type === types$12.eq) {
            left = this.toAssignable(left, false, refDestructuringErrors);
          }
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= left.start) {
            refDestructuringErrors.shorthandAssign = -1;
          }
          if (this.type === types$12.eq) {
            this.checkLValPattern(left);
          } else {
            this.checkLValSimple(left);
          }
          node2.left = left;
          this.next();
          node2.right = this.parseMaybeAssign(forInit);
          if (oldDoubleProto > -1) {
            refDestructuringErrors.doubleProto = oldDoubleProto;
          }
          return this.finishNode(node2, "AssignmentExpression");
        } else {
          if (ownDestructuringErrors) {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
        }
        if (oldParenAssign > -1) {
          refDestructuringErrors.parenthesizedAssign = oldParenAssign;
        }
        if (oldTrailingComma > -1) {
          refDestructuringErrors.trailingComma = oldTrailingComma;
        }
        return left;
      };
      pp$52.parseMaybeConditional = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(forInit, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        if (this.eat(types$12.question)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.test = expr;
          node2.consequent = this.parseMaybeAssign();
          this.expect(types$12.colon);
          node2.alternate = this.parseMaybeAssign(forInit);
          return this.finishNode(node2, "ConditionalExpression");
        }
        return expr;
      };
      pp$52.parseExprOps = function(forInit, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
        if (this.checkExpressionErrors(refDestructuringErrors)) {
          return expr;
        }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
      };
      pp$52.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
        var prec = this.type.binop;
        if (prec != null && (!forInit || this.type !== types$12._in)) {
          if (prec > minPrec) {
            var logical = this.type === types$12.logicalOR || this.type === types$12.logicalAND;
            var coalesce = this.type === types$12.coalesce;
            if (coalesce) {
              prec = types$12.logicalAND.binop;
            }
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
            var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
            if (logical && this.type === types$12.coalesce || coalesce && (this.type === types$12.logicalOR || this.type === types$12.logicalAND)) {
              this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
            }
            return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
          }
        }
        return left;
      };
      pp$52.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        if (right.type === "PrivateIdentifier") {
          this.raise(right.start, "Private identifier can only be left side of binary expression");
        }
        var node2 = this.startNodeAt(startPos, startLoc);
        node2.left = left;
        node2.operator = op;
        node2.right = right;
        return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
      };
      pp$52.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && this.canAwait) {
          expr = this.parseAwait(forInit);
          sawUnary = true;
        } else if (this.type.prefix) {
          var node2 = this.startNode(), update = this.type === types$12.incDec;
          node2.operator = this.value;
          node2.prefix = true;
          this.next();
          node2.argument = this.parseMaybeUnary(null, true, update, forInit);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) {
            this.checkLValSimple(node2.argument);
          } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
            this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
          } else if (node2.operator === "delete" && isPrivateFieldAccess2(node2.argument)) {
            this.raiseRecoverable(node2.start, "Private fields can not be deleted");
          } else {
            sawUnary = true;
          }
          expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
        } else if (!sawUnary && this.type === types$12.privateId) {
          if (forInit || this.privateNameStack.length === 0) {
            this.unexpected();
          }
          expr = this.parsePrivateIdent();
          if (this.type !== types$12._in) {
            this.unexpected();
          }
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
          if (this.checkExpressionErrors(refDestructuringErrors)) {
            return expr;
          }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLValSimple(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }
        if (!incDec && this.eat(types$12.starstar)) {
          if (sawUnary) {
            this.unexpected(this.lastTokStart);
          } else {
            return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
          }
        } else {
          return expr;
        }
      };
      function isPrivateFieldAccess2(node2) {
        return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess2(node2.expression);
      }
      pp$52.parseExprSubscripts = function(refDestructuringErrors, forInit) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors, forInit);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
          return expr;
        }
        var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) {
            refDestructuringErrors.parenthesizedAssign = -1;
          }
          if (refDestructuringErrors.parenthesizedBind >= result.start) {
            refDestructuringErrors.parenthesizedBind = -1;
          }
          if (refDestructuringErrors.trailingComma >= result.start) {
            refDestructuringErrors.trailingComma = -1;
          }
        }
        return result;
      };
      pp$52.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
        var optionalChained = false;
        while (true) {
          var element2 = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
          if (element2.optional) {
            optionalChained = true;
          }
          if (element2 === base2 || element2.type === "ArrowFunctionExpression") {
            if (optionalChained) {
              var chainNode = this.startNodeAt(startPos, startLoc);
              chainNode.expression = element2;
              element2 = this.finishNode(chainNode, "ChainExpression");
            }
            return element2;
          }
          base2 = element2;
        }
      };
      pp$52.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
        var optionalSupported = this.options.ecmaVersion >= 11;
        var optional = optionalSupported && this.eat(types$12.questionDot);
        if (noCalls && optional) {
          this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        }
        var computed = this.eat(types$12.bracketL);
        if (computed || optional && this.type !== types$12.parenL && this.type !== types$12.backQuote || this.eat(types$12.dot)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.object = base2;
          if (computed) {
            node2.property = this.parseExpression();
            this.expect(types$12.bracketR);
          } else if (this.type === types$12.privateId && base2.type !== "Super") {
            node2.property = this.parsePrivateIdent();
          } else {
            node2.property = this.parseIdent(this.options.allowReserved !== "never");
          }
          node2.computed = !!computed;
          if (optionalSupported) {
            node2.optional = optional;
          }
          base2 = this.finishNode(node2, "MemberExpression");
        } else if (!noCalls && this.eat(types$12.parenL)) {
          var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$12.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0) {
              this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
            }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base2;
          node$1.arguments = exprList;
          if (optionalSupported) {
            node$1.optional = optional;
          }
          base2 = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types$12.backQuote) {
          if (optional || optionalChained) {
            this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          }
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base2;
          node$2.quasi = this.parseTemplate({ isTagged: true });
          base2 = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base2;
      };
      pp$52.parseExprAtom = function(refDestructuringErrors, forInit) {
        if (this.type === types$12.slash) {
          this.readRegexp();
        }
        var node2, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
          case types$12._super:
            if (!this.allowSuper) {
              this.raise(this.start, "'super' keyword outside a method");
            }
            node2 = this.startNode();
            this.next();
            if (this.type === types$12.parenL && !this.allowDirectSuper) {
              this.raise(node2.start, "super() call outside constructor of a subclass");
            }
            if (this.type !== types$12.dot && this.type !== types$12.bracketL && this.type !== types$12.parenL) {
              this.unexpected();
            }
            return this.finishNode(node2, "Super");
          case types$12._this:
            node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "ThisExpression");
          case types$12.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id2 = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$12._function)) {
              this.overrideContext(types3.f_expr);
              return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
            }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types$12.arrow)) {
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
              }
              if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$12.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
                id2 = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types$12.arrow)) {
                  this.unexpected();
                }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
              }
            }
            return id2;
          case types$12.regexp:
            var value = this.value;
            node2 = this.parseLiteral(value.value);
            node2.regex = { pattern: value.pattern, flags: value.flags };
            return node2;
          case types$12.num:
          case types$12.string:
            return this.parseLiteral(this.value);
          case types$12._null:
          case types$12._true:
          case types$12._false:
            node2 = this.startNode();
            node2.value = this.type === types$12._null ? null : this.type === types$12._true;
            node2.raw = this.type.keyword;
            this.next();
            return this.finishNode(node2, "Literal");
          case types$12.parenL:
            var start3 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
                refDestructuringErrors.parenthesizedAssign = start3;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = start3;
              }
            }
            return expr;
          case types$12.bracketL:
            node2 = this.startNode();
            this.next();
            node2.elements = this.parseExprList(types$12.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node2, "ArrayExpression");
          case types$12.braceL:
            this.overrideContext(types3.b_expr);
            return this.parseObj(false, refDestructuringErrors);
          case types$12._function:
            node2 = this.startNode();
            this.next();
            return this.parseFunction(node2, 0);
          case types$12._class:
            return this.parseClass(this.startNode(), false);
          case types$12._new:
            return this.parseNew();
          case types$12.backQuote:
            return this.parseTemplate();
          case types$12._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport();
            } else {
              return this.unexpected();
            }
          default:
            this.unexpected();
        }
      };
      pp$52.parseExprImport = function() {
        var node2 = this.startNode();
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword import");
        }
        var meta = this.parseIdent(true);
        switch (this.type) {
          case types$12.parenL:
            return this.parseDynamicImport(node2);
          case types$12.dot:
            node2.meta = meta;
            return this.parseImportMeta(node2);
          default:
            this.unexpected();
        }
      };
      pp$52.parseDynamicImport = function(node2) {
        this.next();
        node2.source = this.parseMaybeAssign();
        if (!this.eat(types$12.parenR)) {
          var errorPos = this.start;
          if (this.eat(types$12.comma) && this.eat(types$12.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }
        return this.finishNode(node2, "ImportExpression");
      };
      pp$52.parseImportMeta = function(node2) {
        this.next();
        var containsEsc = this.containsEsc;
        node2.property = this.parseIdent(true);
        if (node2.property.name !== "meta") {
          this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
        }
        if (containsEsc) {
          this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
        }
        if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
          this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
        }
        return this.finishNode(node2, "MetaProperty");
      };
      pp$52.parseLiteral = function(value) {
        var node2 = this.startNode();
        node2.value = value;
        node2.raw = this.input.slice(this.start, this.end);
        if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
          node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
        }
        this.next();
        return this.finishNode(node2, "Literal");
      };
      pp$52.parseParenExpression = function() {
        this.expect(types$12.parenL);
        var val = this.parseExpression();
        this.expect(types$12.parenR);
        return val;
      };
      pp$52.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors3(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types$12.parenR) {
            first ? first = false : this.expect(types$12.comma);
            if (allowTrailingComma && this.afterTrailingComma(types$12.parenR, true)) {
              lastIsComma = true;
              break;
            } else if (this.type === types$12.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types$12.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              break;
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
          this.expect(types$12.parenR);
          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$12.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
          }
          if (!exprList.length || lastIsComma) {
            this.unexpected(this.lastTokStart);
          }
          if (spreadStart) {
            this.unexpected(spreadStart);
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }
        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression");
        } else {
          return val;
        }
      };
      pp$52.parseParenItem = function(item) {
        return item;
      };
      pp$52.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
      };
      var empty3 = [];
      pp$52.parseNew = function() {
        if (this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        }
        var node2 = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types$12.dot)) {
          node2.meta = meta;
          var containsEsc = this.containsEsc;
          node2.property = this.parseIdent(true);
          if (node2.property.name !== "target") {
            this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
          }
          if (containsEsc) {
            this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
          }
          if (!this.allowNewDotTarget) {
            this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
          }
          return this.finishNode(node2, "MetaProperty");
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$12._import;
        node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
        if (isImport && node2.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        if (this.eat(types$12.parenL)) {
          node2.arguments = this.parseExprList(types$12.parenR, this.options.ecmaVersion >= 8, false);
        } else {
          node2.arguments = empty3;
        }
        return this.finishNode(node2, "NewExpression");
      };
      pp$52.parseTemplateElement = function(ref3) {
        var isTagged = ref3.isTagged;
        var elem = this.startNode();
        if (this.type === types$12.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types$12.backQuote;
        return this.finishNode(elem, "TemplateElement");
      };
      pp$52.parseTemplate = function(ref3) {
        if (ref3 === void 0) ref3 = {};
        var isTagged = ref3.isTagged;
        if (isTagged === void 0) isTagged = false;
        var node2 = this.startNode();
        this.next();
        node2.expressions = [];
        var curElt = this.parseTemplateElement({ isTagged });
        node2.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types$12.eof) {
            this.raise(this.pos, "Unterminated template literal");
          }
          this.expect(types$12.dollarBraceL);
          node2.expressions.push(this.parseExpression());
          this.expect(types$12.braceR);
          node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
        }
        this.next();
        return this.finishNode(node2, "TemplateLiteral");
      };
      pp$52.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$12.name || this.type === types$12.num || this.type === types$12.string || this.type === types$12.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$12.star) && !lineBreak2.test(this.input.slice(this.lastTokEnd, this.start));
      };
      pp$52.parseObj = function(isPattern, refDestructuringErrors) {
        var node2 = this.startNode(), first = true, propHash = {};
        node2.properties = [];
        this.next();
        while (!this.eat(types$12.braceR)) {
          if (!first) {
            this.expect(types$12.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$12.braceR)) {
              break;
            }
          } else {
            first = false;
          }
          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) {
            this.checkPropClash(prop, propHash, refDestructuringErrors);
          }
          node2.properties.push(prop);
        }
        return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
      };
      pp$52.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types$12.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types$12.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement");
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types$12.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement");
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern) {
            isGenerator = this.eat(types$12.star);
          }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$12.star);
          this.parsePropertyName(prop);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property");
      };
      pp$52.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types$12.colon) {
          this.unexpected();
        }
        if (this.eat(types$12.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types$12.parenL) {
          if (isPattern) {
            this.unexpected();
          }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$12.comma && this.type !== types$12.braceR && this.type !== types$12.eq)) {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          prop.kind = prop.key.name;
          this.parsePropertyName(prop);
          prop.value = this.parseMethod(false);
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start3 = prop.value.start;
            if (prop.kind === "get") {
              this.raiseRecoverable(start3, "getter should have no params");
            } else {
              this.raiseRecoverable(start3, "setter should have exactly one param");
            }
          } else {
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
              this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
            }
          }
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) {
            this.unexpected();
          }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = startPos;
          }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else if (this.type === types$12.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0) {
              refDestructuringErrors.shorthandAssign = this.start;
            }
            prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
          } else {
            prop.value = this.copyNode(prop.key);
          }
          prop.shorthand = true;
        } else {
          this.unexpected();
        }
      };
      pp$52.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types$12.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types$12.bracketR);
            return prop.key;
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types$12.num || this.type === types$12.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      };
      pp$52.initFunction = function(node2) {
        node2.id = null;
        if (this.options.ecmaVersion >= 6) {
          node2.generator = node2.expression = false;
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = false;
        }
      };
      pp$52.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 6) {
          node2.generator = isGenerator;
        }
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags2(isAsync, node2.generator) | SCOPE_SUPER2 | (allowDirectSuper ? SCOPE_DIRECT_SUPER2 : 0));
        this.expect(types$12.parenL);
        node2.params = this.parseBindingList(types$12.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node2, false, true, false);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, "FunctionExpression");
      };
      pp$52.parseArrowExpression = function(node2, params, isAsync, forInit) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.enterScope(functionFlags2(isAsync, false) | SCOPE_ARROW2);
        this.initFunction(node2);
        if (this.options.ecmaVersion >= 8) {
          node2.async = !!isAsync;
        }
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        node2.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node2, true, false, forInit);
        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node2, "ArrowFunctionExpression");
      };
      pp$52.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
        var isExpression = isArrowFunction && this.type !== types$12.braceL;
        var oldStrict = this.strict, useStrict = false;
        if (isExpression) {
          node2.body = this.parseMaybeAssign(forInit);
          node2.expression = true;
          this.checkParams(node2, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple) {
              this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
            }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) {
            this.strict = true;
          }
          this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
          if (this.strict && node2.id) {
            this.checkLValSimple(node2.id, BIND_OUTSIDE2);
          }
          node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
          node2.expression = false;
          this.adaptDirectivePrologue(node2.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();
      };
      pp$52.isSimpleParamList = function(params) {
        for (var i2 = 0, list4 = params; i2 < list4.length; i2 += 1) {
          var param = list4[i2];
          if (param.type !== "Identifier") {
            return false;
          }
        }
        return true;
      };
      pp$52.checkParams = function(node2, allowDuplicates) {
        var nameHash = /* @__PURE__ */ Object.create(null);
        for (var i2 = 0, list4 = node2.params; i2 < list4.length; i2 += 1) {
          var param = list4[i2];
          this.checkLValInnerPattern(param, BIND_VAR2, allowDuplicates ? null : nameHash);
        }
      };
      pp$52.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types$12.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) {
              break;
            }
          } else {
            first = false;
          }
          var elt = void 0;
          if (allowEmpty && this.type === types$12.comma) {
            elt = null;
          } else if (this.type === types$12.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types$12.comma && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts;
      };
      pp$52.checkUnreserved = function(ref3) {
        var start3 = ref3.start;
        var end = ref3.end;
        var name2 = ref3.name;
        if (this.inGenerator && name2 === "yield") {
          this.raiseRecoverable(start3, "Cannot use 'yield' as identifier inside a generator");
        }
        if (this.inAsync && name2 === "await") {
          this.raiseRecoverable(start3, "Cannot use 'await' as identifier inside an async function");
        }
        if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
          this.raiseRecoverable(start3, "Cannot use 'arguments' in class field initializer");
        }
        if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
          this.raise(start3, "Cannot use " + name2 + " in class static initialization block");
        }
        if (this.keywords.test(name2)) {
          this.raise(start3, "Unexpected keyword '" + name2 + "'");
        }
        if (this.options.ecmaVersion < 6 && this.input.slice(start3, end).indexOf("\\") !== -1) {
          return;
        }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name2)) {
          if (!this.inAsync && name2 === "await") {
            this.raiseRecoverable(start3, "Cannot use keyword 'await' outside an async function");
          }
          this.raiseRecoverable(start3, "The keyword '" + name2 + "' is reserved");
        }
      };
      pp$52.parseIdent = function(liberal) {
        var node2 = this.startNode();
        if (this.type === types$12.name) {
          node2.name = this.value;
        } else if (this.type.keyword) {
          node2.name = this.type.keyword;
          if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
        } else {
          this.unexpected();
        }
        this.next(!!liberal);
        this.finishNode(node2, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node2);
          if (node2.name === "await" && !this.awaitIdentPos) {
            this.awaitIdentPos = node2.start;
          }
        }
        return node2;
      };
      pp$52.parsePrivateIdent = function() {
        var node2 = this.startNode();
        if (this.type === types$12.privateId) {
          node2.name = this.value;
        } else {
          this.unexpected();
        }
        this.next();
        this.finishNode(node2, "PrivateIdentifier");
        if (this.privateNameStack.length === 0) {
          this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
        } else {
          this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
        }
        return node2;
      };
      pp$52.parseYield = function(forInit) {
        if (!this.yieldPos) {
          this.yieldPos = this.start;
        }
        var node2 = this.startNode();
        this.next();
        if (this.type === types$12.semi || this.canInsertSemicolon() || this.type !== types$12.star && !this.type.startsExpr) {
          node2.delegate = false;
          node2.argument = null;
        } else {
          node2.delegate = this.eat(types$12.star);
          node2.argument = this.parseMaybeAssign(forInit);
        }
        return this.finishNode(node2, "YieldExpression");
      };
      pp$52.parseAwait = function(forInit) {
        if (!this.awaitPos) {
          this.awaitPos = this.start;
        }
        var node2 = this.startNode();
        this.next();
        node2.argument = this.parseMaybeUnary(null, true, false, forInit);
        return this.finishNode(node2, "AwaitExpression");
      };
      var pp$42 = Parser3.prototype;
      pp$42.raise = function(pos, message) {
        var loc = getLineInfo2(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos;
        err.loc = loc;
        err.raisedAt = this.pos;
        throw err;
      };
      pp$42.raiseRecoverable = pp$42.raise;
      pp$42.curPosition = function() {
        if (this.options.locations) {
          return new Position3(this.curLine, this.pos - this.lineStart);
        }
      };
      var pp$32 = Parser3.prototype;
      var Scope3 = function Scope4(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
        this.inClassFieldInit = false;
      };
      pp$32.enterScope = function(flags) {
        this.scopeStack.push(new Scope3(flags));
      };
      pp$32.exitScope = function() {
        this.scopeStack.pop();
      };
      pp$32.treatFunctionsAsVarInScope = function(scope) {
        return scope.flags & SCOPE_FUNCTION2 || !this.inModule && scope.flags & SCOPE_TOP2;
      };
      pp$32.declareName = function(name2, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL2) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
          scope.lexical.push(name2);
          if (this.inModule && scope.flags & SCOPE_TOP2) {
            delete this.undefinedExports[name2];
          }
        } else if (bindingType === BIND_SIMPLE_CATCH2) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name2);
        } else if (bindingType === BIND_FUNCTION2) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar) {
            redeclared = scope$2.lexical.indexOf(name2) > -1;
          } else {
            redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
          }
          scope$2.functions.push(name2);
        } else {
          for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
            var scope$3 = this.scopeStack[i2];
            if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH2 && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
              redeclared = true;
              break;
            }
            scope$3.var.push(name2);
            if (this.inModule && scope$3.flags & SCOPE_TOP2) {
              delete this.undefinedExports[name2];
            }
            if (scope$3.flags & SCOPE_VAR2) {
              break;
            }
          }
        }
        if (redeclared) {
          this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
        }
      };
      pp$32.checkLocalExport = function(id2) {
        if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
          this.undefinedExports[id2.name] = id2;
        }
      };
      pp$32.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      };
      pp$32.currentVarScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & SCOPE_VAR2) {
            return scope;
          }
        }
      };
      pp$32.currentThisScope = function() {
        for (var i2 = this.scopeStack.length - 1; ; i2--) {
          var scope = this.scopeStack[i2];
          if (scope.flags & SCOPE_VAR2 && !(scope.flags & SCOPE_ARROW2)) {
            return scope;
          }
        }
      };
      var Node3 = function Node4(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations) {
          this.loc = new SourceLocation3(parser, loc);
        }
        if (parser.options.directSourceFile) {
          this.sourceFile = parser.options.directSourceFile;
        }
        if (parser.options.ranges) {
          this.range = [pos, 0];
        }
      };
      var pp$22 = Parser3.prototype;
      pp$22.startNode = function() {
        return new Node3(this, this.start, this.startLoc);
      };
      pp$22.startNodeAt = function(pos, loc) {
        return new Node3(this, pos, loc);
      };
      function finishNodeAt2(node2, type, pos, loc) {
        node2.type = type;
        node2.end = pos;
        if (this.options.locations) {
          node2.loc.end = loc;
        }
        if (this.options.ranges) {
          node2.range[1] = pos;
        }
        return node2;
      }
      pp$22.finishNode = function(node2, type) {
        return finishNodeAt2.call(this, node2, type, this.lastTokEnd, this.lastTokEndLoc);
      };
      pp$22.finishNodeAt = function(node2, type, pos, loc) {
        return finishNodeAt2.call(this, node2, type, pos, loc);
      };
      pp$22.copyNode = function(node2) {
        var newNode = new Node3(this, node2.start, this.startLoc);
        for (var prop in node2) {
          newNode[prop] = node2[prop];
        }
        return newNode;
      };
      var ecma9BinaryProperties2 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties2 = ecma9BinaryProperties2 + " Extended_Pictographic";
      var ecma11BinaryProperties2 = ecma10BinaryProperties2;
      var ecma12BinaryProperties2 = ecma11BinaryProperties2 + " EBase EComp EMod EPres ExtPict";
      var ecma13BinaryProperties2 = ecma12BinaryProperties2;
      var ecma14BinaryProperties2 = ecma13BinaryProperties2;
      var unicodeBinaryProperties2 = {
        9: ecma9BinaryProperties2,
        10: ecma10BinaryProperties2,
        11: ecma11BinaryProperties2,
        12: ecma12BinaryProperties2,
        13: ecma13BinaryProperties2,
        14: ecma14BinaryProperties2
      };
      var unicodeGeneralCategoryValues2 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
      var ecma9ScriptValues2 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues2 = ecma9ScriptValues2 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues2 = ecma10ScriptValues2 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var ecma12ScriptValues2 = ecma11ScriptValues2 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
      var ecma13ScriptValues2 = ecma12ScriptValues2 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
      var ecma14ScriptValues2 = ecma13ScriptValues2 + " Kawi Nag_Mundari Nagm";
      var unicodeScriptValues2 = {
        9: ecma9ScriptValues2,
        10: ecma10ScriptValues2,
        11: ecma11ScriptValues2,
        12: ecma12ScriptValues2,
        13: ecma13ScriptValues2,
        14: ecma14ScriptValues2
      };
      var data2 = {};
      function buildUnicodeData2(ecmaVersion2) {
        var d = data2[ecmaVersion2] = {
          binary: wordsRegexp2(unicodeBinaryProperties2[ecmaVersion2] + " " + unicodeGeneralCategoryValues2),
          nonBinary: {
            General_Category: wordsRegexp2(unicodeGeneralCategoryValues2),
            Script: wordsRegexp2(unicodeScriptValues2[ecmaVersion2])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;
        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      for (var i = 0, list3 = [9, 10, 11, 12, 13, 14]; i < list3.length; i += 1) {
        var ecmaVersion = list3[i];
        buildUnicodeData2(ecmaVersion);
      }
      var pp$12 = Parser3.prototype;
      var RegExpValidationState3 = function RegExpValidationState4(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
        this.unicodeProperties = data2[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };
      RegExpValidationState3.prototype.reset = function reset2(start3, pattern, flags) {
        var unicode = flags.indexOf("u") !== -1;
        this.start = start3 | 0;
        this.source = pattern + "";
        this.flags = flags;
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      };
      RegExpValidationState3.prototype.raise = function raise2(message) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
      };
      RegExpValidationState3.prototype.at = function at3(i2, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return -1;
        }
        var c = s.charCodeAt(i2);
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
          return c;
        }
        var next = s.charCodeAt(i2 + 1);
        return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
      };
      RegExpValidationState3.prototype.nextIndex = function nextIndex2(i2, forceU) {
        if (forceU === void 0) forceU = false;
        var s = this.source;
        var l = s.length;
        if (i2 >= l) {
          return l;
        }
        var c = s.charCodeAt(i2), next;
        if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
          return i2 + 1;
        }
        return i2 + 2;
      };
      RegExpValidationState3.prototype.current = function current2(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.pos, forceU);
      };
      RegExpValidationState3.prototype.lookahead = function lookahead2(forceU) {
        if (forceU === void 0) forceU = false;
        return this.at(this.nextIndex(this.pos, forceU), forceU);
      };
      RegExpValidationState3.prototype.advance = function advance2(forceU) {
        if (forceU === void 0) forceU = false;
        this.pos = this.nextIndex(this.pos, forceU);
      };
      RegExpValidationState3.prototype.eat = function eat4(ch, forceU) {
        if (forceU === void 0) forceU = false;
        if (this.current(forceU) === ch) {
          this.advance(forceU);
          return true;
        }
        return false;
      };
      pp$12.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;
        for (var i2 = 0; i2 < flags.length; i2++) {
          var flag = flags.charAt(i2);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i2 + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
        }
      };
      pp$12.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);
        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };
      pp$12.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;
        this.regexp_disjunction(state);
        if (state.pos !== state.source.length) {
          if (state.eat(
            41
            /* ) */
          )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(
            93
            /* ] */
          ) || state.eat(
            125
            /* } */
          )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i2 = 0, list4 = state.backReferenceNames; i2 < list4.length; i2 += 1) {
          var name2 = list4[i2];
          if (state.groupNames.indexOf(name2) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };
      pp$12.regexp_disjunction = function(state) {
        this.regexp_alternative(state);
        while (state.eat(
          124
          /* | */
        )) {
          this.regexp_alternative(state);
        }
        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(
          123
          /* { */
        )) {
          state.raise("Lone quantifier brackets");
        }
      };
      pp$12.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
        }
      };
      pp$12.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true;
        }
        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true;
        }
        return false;
      };
      pp$12.regexp_eatAssertion = function(state) {
        var start3 = state.pos;
        state.lastAssertionIsQuantifiable = false;
        if (state.eat(
          94
          /* ^ */
        ) || state.eat(
          36
          /* $ */
        )) {
          return true;
        }
        if (state.eat(
          92
          /* \ */
        )) {
          if (state.eat(
            66
            /* B */
          ) || state.eat(
            98
            /* b */
          )) {
            return true;
          }
          state.pos = start3;
        }
        if (state.eat(
          40
          /* ( */
        ) && state.eat(
          63
          /* ? */
        )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(
              60
              /* < */
            );
          }
          if (state.eat(
            61
            /* = */
          ) || state.eat(
            33
            /* ! */
          )) {
            this.regexp_disjunction(state);
            if (!state.eat(
              41
              /* ) */
            )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true;
          }
        }
        state.pos = start3;
        return false;
      };
      pp$12.regexp_eatQuantifier = function(state, noError) {
        if (noError === void 0) noError = false;
        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(
            63
            /* ? */
          );
          return true;
        }
        return false;
      };
      pp$12.regexp_eatQuantifierPrefix = function(state, noError) {
        return state.eat(
          42
          /* * */
        ) || state.eat(
          43
          /* + */
        ) || state.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(state, noError);
      };
      pp$12.regexp_eatBracedQuantifier = function(state, noError) {
        var start3 = state.pos;
        if (state.eat(
          123
          /* { */
        )) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(
              44
              /* , */
            ) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(
              125
              /* } */
            )) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true;
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start3;
        }
        return false;
      };
      pp$12.regexp_eatAtom = function(state) {
        return this.regexp_eatPatternCharacters(state) || state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
      };
      pp$12.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start3 = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true;
          }
          state.pos = start3;
        }
        return false;
      };
      pp$12.regexp_eatUncapturingGroup = function(state) {
        var start3 = state.pos;
        if (state.eat(
          40
          /* ( */
        )) {
          if (state.eat(
            63
            /* ? */
          ) && state.eat(
            58
            /* : */
          )) {
            this.regexp_disjunction(state);
            if (state.eat(
              41
              /* ) */
            )) {
              return true;
            }
            state.raise("Unterminated group");
          }
          state.pos = start3;
        }
        return false;
      };
      pp$12.regexp_eatCapturingGroup = function(state) {
        if (state.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 63) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(
            41
            /* ) */
          )) {
            state.numCapturingParens += 1;
            return true;
          }
          state.raise("Unterminated group");
        }
        return false;
      };
      pp$12.regexp_eatExtendedAtom = function(state) {
        return state.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
      };
      pp$12.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false;
      };
      pp$12.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter2(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      function isSyntaxCharacter2(ch) {
        return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
      }
      pp$12.regexp_eatPatternCharacters = function(state) {
        var start3 = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter2(ch)) {
          state.advance();
        }
        return state.pos !== start3;
      };
      pp$12.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_groupSpecifier = function(state) {
        if (state.eat(
          63
          /* ? */
        )) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return;
          }
          state.raise("Invalid group");
        }
      };
      pp$12.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
            62
            /* > */
          )) {
            return true;
          }
          state.raise("Invalid capture group name");
        }
        return false;
      };
      pp$12.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString2(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString2(state.lastIntValue);
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_eatRegExpIdentifierStart = function(state) {
        var start3 = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart2(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start3;
        return false;
      };
      function isRegExpIdentifierStart2(ch) {
        return isIdentifierStart2(ch, true) || ch === 36 || ch === 95;
      }
      pp$12.regexp_eatRegExpIdentifierPart = function(state) {
        var start3 = state.pos;
        var forceU = this.options.ecmaVersion >= 11;
        var ch = state.current(forceU);
        state.advance(forceU);
        if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart2(ch)) {
          state.lastIntValue = ch;
          return true;
        }
        state.pos = start3;
        return false;
      };
      function isRegExpIdentifierPart2(ch) {
        return isIdentifierChar2(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
      }
      pp$12.regexp_eatAtomEscape = function(state) {
        if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
          return true;
        }
        if (state.switchU) {
          if (state.current() === 99) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false;
      };
      pp$12.regexp_eatBackReference = function(state) {
        var start3 = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true;
          }
          if (n <= state.numCapturingParens) {
            return true;
          }
          state.pos = start3;
        }
        return false;
      };
      pp$12.regexp_eatKGroupName = function(state) {
        if (state.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true;
          }
          state.raise("Invalid named reference");
        }
        return false;
      };
      pp$12.regexp_eatCharacterEscape = function(state) {
        return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
      };
      pp$12.regexp_eatCControlLetter = function(state) {
        var start3 = state.pos;
        if (state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(state)) {
            return true;
          }
          state.pos = start3;
        }
        return false;
      };
      pp$12.regexp_eatZero = function(state) {
        if (state.current() === 48 && !isDecimalDigit2(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 116) {
          state.lastIntValue = 9;
          state.advance();
          return true;
        }
        if (ch === 110) {
          state.lastIntValue = 10;
          state.advance();
          return true;
        }
        if (ch === 118) {
          state.lastIntValue = 11;
          state.advance();
          return true;
        }
        if (ch === 102) {
          state.lastIntValue = 12;
          state.advance();
          return true;
        }
        if (ch === 114) {
          state.lastIntValue = 13;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter2(ch)) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      function isControlLetter2(ch) {
        return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
      }
      pp$12.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
        if (forceU === void 0) forceU = false;
        var start3 = state.pos;
        var switchU = forceU || state.switchU;
        if (state.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (switchU && lead >= 55296 && lead <= 56319) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(
                92
                /* \ */
              ) && state.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail2 = state.lastIntValue;
                if (trail2 >= 56320 && trail2 <= 57343) {
                  state.lastIntValue = (lead - 55296) * 1024 + (trail2 - 56320) + 65536;
                  return true;
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true;
          }
          if (switchU && state.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(state) && state.eat(
            125
            /* } */
          ) && isValidUnicode2(state.lastIntValue)) {
            return true;
          }
          if (switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start3;
        }
        return false;
      };
      function isValidUnicode2(ch) {
        return ch >= 0 && ch <= 1114111;
      }
      pp$12.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true;
          }
          if (state.eat(
            47
            /* / */
          )) {
            state.lastIntValue = 47;
            return true;
          }
          return false;
        }
        var ch = state.current();
        if (ch !== 99 && (!state.switchN || ch !== 107)) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 49 && ch <= 57) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
            state.advance();
          } while ((ch = state.current()) >= 48 && ch <= 57);
          return true;
        }
        return false;
      };
      pp$12.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();
        if (isCharacterClassEscape2(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return true;
        }
        if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
          state.lastIntValue = -1;
          state.advance();
          if (state.eat(
            123
            /* { */
          ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(
            125
            /* } */
          )) {
            return true;
          }
          state.raise("Invalid property name");
        }
        return false;
      };
      function isCharacterClassEscape2(ch) {
        return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
      }
      pp$12.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start3 = state.pos;
        if (this.regexp_eatUnicodePropertyName(state) && state.eat(
          61
          /* = */
        )) {
          var name2 = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name2, value);
            return true;
          }
        }
        state.pos = start3;
        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
          return true;
        }
        return false;
      };
      pp$12.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value) {
        if (!hasOwn2(state.unicodeProperties.nonBinary, name2)) {
          state.raise("Invalid property name");
        }
        if (!state.unicodeProperties.nonBinary[name2].test(value)) {
          state.raise("Invalid property value");
        }
      };
      pp$12.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (!state.unicodeProperties.binary.test(nameOrValue)) {
          state.raise("Invalid property name");
        }
      };
      pp$12.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter2(ch = state.current())) {
          state.lastStringValue += codePointToString2(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyNameCharacter2(ch) {
        return isControlLetter2(ch) || ch === 95;
      }
      pp$12.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter2(ch = state.current())) {
          state.lastStringValue += codePointToString2(ch);
          state.advance();
        }
        return state.lastStringValue !== "";
      };
      function isUnicodePropertyValueCharacter2(ch) {
        return isUnicodePropertyNameCharacter2(ch) || isDecimalDigit2(ch);
      }
      pp$12.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state);
      };
      pp$12.regexp_eatCharacterClass = function(state) {
        if (state.eat(
          91
          /* [ */
        )) {
          state.eat(
            94
            /* ^ */
          );
          this.regexp_classRanges(state);
          if (state.eat(
            93
            /* ] */
          )) {
            return true;
          }
          state.raise("Unterminated character class");
        }
        return false;
      };
      pp$12.regexp_classRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };
      pp$12.regexp_eatClassAtom = function(state) {
        var start3 = state.pos;
        if (state.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(state)) {
            return true;
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 99 || isOctalDigit2(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start3;
        }
        var ch = state.current();
        if (ch !== 93) {
          state.lastIntValue = ch;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatClassEscape = function(state) {
        var start3 = state.pos;
        if (state.eat(
          98
          /* b */
        )) {
          state.lastIntValue = 8;
          return true;
        }
        if (state.switchU && state.eat(
          45
          /* - */
        )) {
          state.lastIntValue = 45;
          return true;
        }
        if (!state.switchU && state.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true;
          }
          state.pos = start3;
        }
        return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
      };
      pp$12.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit2(ch) || ch === 95) {
          state.lastIntValue = ch % 32;
          state.advance();
          return true;
        }
        return false;
      };
      pp$12.regexp_eatHexEscapeSequence = function(state) {
        var start3 = state.pos;
        if (state.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true;
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start3;
        }
        return false;
      };
      pp$12.regexp_eatDecimalDigits = function(state) {
        var start3 = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit2(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
          state.advance();
        }
        return state.pos !== start3;
      };
      function isDecimalDigit2(ch) {
        return ch >= 48 && ch <= 57;
      }
      pp$12.regexp_eatHexDigits = function(state) {
        var start3 = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit2(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
          state.advance();
        }
        return state.pos !== start3;
      };
      function isHexDigit2(ch) {
        return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
      }
      function hexToInt2(ch) {
        if (ch >= 65 && ch <= 70) {
          return 10 + (ch - 65);
        }
        if (ch >= 97 && ch <= 102) {
          return 10 + (ch - 97);
        }
        return ch - 48;
      }
      pp$12.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true;
        }
        return false;
      };
      pp$12.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit2(ch)) {
          state.lastIntValue = ch - 48;
          state.advance();
          return true;
        }
        state.lastIntValue = 0;
        return false;
      };
      function isOctalDigit2(ch) {
        return ch >= 48 && ch <= 55;
      }
      pp$12.regexp_eatFixedHexDigits = function(state, length) {
        var start3 = state.pos;
        state.lastIntValue = 0;
        for (var i2 = 0; i2 < length; ++i2) {
          var ch = state.current();
          if (!isHexDigit2(ch)) {
            state.pos = start3;
            return false;
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt2(ch);
          state.advance();
        }
        return true;
      };
      var Token3 = function Token4(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations) {
          this.loc = new SourceLocation3(p, p.startLoc, p.endLoc);
        }
        if (p.options.ranges) {
          this.range = [p.start, p.end];
        }
      };
      var pp2 = Parser3.prototype;
      pp2.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
          this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
        }
        if (this.options.onToken) {
          this.options.onToken(new Token3(this));
        }
        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };
      pp2.getToken = function() {
        this.next();
        return new Token3(this);
      };
      if (typeof Symbol !== "undefined") {
        pp2[Symbol.iterator] = function() {
          var this$1$1 = this;
          return {
            next: function() {
              var token = this$1$1.getToken();
              return {
                done: token.type === types$12.eof,
                value: token
              };
            }
          };
        };
      }
      pp2.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) {
          this.skipSpace();
        }
        this.start = this.pos;
        if (this.options.locations) {
          this.startLoc = this.curPosition();
        }
        if (this.pos >= this.input.length) {
          return this.finishToken(types$12.eof);
        }
        if (curContext.override) {
          return curContext.override(this);
        } else {
          this.readToken(this.fullCharCodeAtPos());
        }
      };
      pp2.readToken = function(code3) {
        if (isIdentifierStart2(code3, this.options.ecmaVersion >= 6) || code3 === 92) {
          return this.readWord();
        }
        return this.getTokenFromCode(code3);
      };
      pp2.fullCharCodeAtPos = function() {
        var code3 = this.input.charCodeAt(this.pos);
        if (code3 <= 55295 || code3 >= 56320) {
          return code3;
        }
        var next = this.input.charCodeAt(this.pos + 1);
        return next <= 56319 || next >= 57344 ? code3 : (code3 << 10) + next - 56613888;
      };
      pp2.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start3 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) {
          this.raise(this.pos - 2, "Unterminated comment");
        }
        this.pos = end + 2;
        if (this.options.locations) {
          for (var nextBreak = void 0, pos = start3; (nextBreak = nextLineBreak2(this.input, pos, this.pos)) > -1; ) {
            ++this.curLine;
            pos = this.lineStart = nextBreak;
          }
        }
        if (this.options.onComment) {
          this.options.onComment(
            true,
            this.input.slice(start3 + 2, end),
            start3,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp2.skipLineComment = function(startSkip) {
        var start3 = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine2(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment) {
          this.options.onComment(
            false,
            this.input.slice(start3 + startSkip, this.pos),
            start3,
            this.pos,
            startLoc,
            this.curPosition()
          );
        }
      };
      pp2.skipSpace = function() {
        loop: while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break loop;
              }
              break;
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace2.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop;
              }
          }
        }
      };
      pp2.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) {
          this.endLoc = this.curPosition();
        }
        var prevType = this.type;
        this.type = type;
        this.value = val;
        this.updateContext(prevType);
      };
      pp2.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) {
          return this.readNumber(true);
        }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
          this.pos += 3;
          return this.finishToken(types$12.ellipsis);
        } else {
          ++this.pos;
          return this.finishToken(types$12.dot);
        }
      };
      pp2.readToken_slash = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) {
          ++this.pos;
          return this.readRegexp();
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.slash, 1);
      };
      pp2.readToken_mult_modulo_exp = function(code3) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code3 === 42 ? types$12.star : types$12.modulo;
        if (this.options.ecmaVersion >= 7 && code3 === 42 && next === 42) {
          ++size;
          tokentype = types$12.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, size + 1);
        }
        return this.finishOp(tokentype, size);
      };
      pp2.readToken_pipe_amp = function(code3) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code3) {
          if (this.options.ecmaVersion >= 12) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 === 61) {
              return this.finishOp(types$12.assign, 3);
            }
          }
          return this.finishOp(code3 === 124 ? types$12.logicalOR : types$12.logicalAND, 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(code3 === 124 ? types$12.bitwiseOR : types$12.bitwiseAND, 1);
      };
      pp2.readToken_caret = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.bitwiseXOR, 1);
      };
      pp2.readToken_plus_min = function(code3) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code3) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak2.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken();
          }
          return this.finishOp(types$12.incDec, 2);
        }
        if (next === 61) {
          return this.finishOp(types$12.assign, 2);
        }
        return this.finishOp(types$12.plusMin, 1);
      };
      pp2.readToken_lt_gt = function(code3) {
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code3) {
          size = code3 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) {
            return this.finishOp(types$12.assign, size + 1);
          }
          return this.finishOp(types$12.bitShift, size);
        }
        if (next === 33 && code3 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken();
        }
        if (next === 61) {
          size = 2;
        }
        return this.finishOp(types$12.relational, size);
      };
      pp2.readToken_eq_excl = function(code3) {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) {
          return this.finishOp(types$12.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
        }
        if (code3 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
          this.pos += 2;
          return this.finishToken(types$12.arrow);
        }
        return this.finishOp(code3 === 61 ? types$12.eq : types$12.prefix, 1);
      };
      pp2.readToken_question = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        if (ecmaVersion2 >= 11) {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 46) {
            var next2 = this.input.charCodeAt(this.pos + 2);
            if (next2 < 48 || next2 > 57) {
              return this.finishOp(types$12.questionDot, 2);
            }
          }
          if (next === 63) {
            if (ecmaVersion2 >= 12) {
              var next2$1 = this.input.charCodeAt(this.pos + 2);
              if (next2$1 === 61) {
                return this.finishOp(types$12.assign, 3);
              }
            }
            return this.finishOp(types$12.coalesce, 2);
          }
        }
        return this.finishOp(types$12.question, 1);
      };
      pp2.readToken_numberSign = function() {
        var ecmaVersion2 = this.options.ecmaVersion;
        var code3 = 35;
        if (ecmaVersion2 >= 13) {
          ++this.pos;
          code3 = this.fullCharCodeAtPos();
          if (isIdentifierStart2(code3, true) || code3 === 92) {
            return this.finishToken(types$12.privateId, this.readWord1());
          }
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString2(code3) + "'");
      };
      pp2.getTokenFromCode = function(code3) {
        switch (code3) {
          // The interpretation of a dot depends on whether it is followed
          // by a digit or another two dots.
          case 46:
            return this.readToken_dot();
          // Punctuation tokens.
          case 40:
            ++this.pos;
            return this.finishToken(types$12.parenL);
          case 41:
            ++this.pos;
            return this.finishToken(types$12.parenR);
          case 59:
            ++this.pos;
            return this.finishToken(types$12.semi);
          case 44:
            ++this.pos;
            return this.finishToken(types$12.comma);
          case 91:
            ++this.pos;
            return this.finishToken(types$12.bracketL);
          case 93:
            ++this.pos;
            return this.finishToken(types$12.bracketR);
          case 123:
            ++this.pos;
            return this.finishToken(types$12.braceL);
          case 125:
            ++this.pos;
            return this.finishToken(types$12.braceR);
          case 58:
            ++this.pos;
            return this.finishToken(types$12.colon);
          case 96:
            if (this.options.ecmaVersion < 6) {
              break;
            }
            ++this.pos;
            return this.finishToken(types$12.backQuote);
          case 48:
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) {
              return this.readRadixNumber(16);
            }
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) {
                return this.readRadixNumber(8);
              }
              if (next === 98 || next === 66) {
                return this.readRadixNumber(2);
              }
            }
          // Anything else beginning with a digit is an integer, octal
          // number, or float.
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(false);
          // Quotes produce strings.
          case 34:
          case 39:
            return this.readString(code3);
          // Operators are parsed inline in tiny state machines. '=' (61) is
          // often referred to. `finishOp` simply skips the amount of
          // characters it is given as second argument, and returns a token
          // of the type given by its first argument.
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(code3);
          case 124:
          case 38:
            return this.readToken_pipe_amp(code3);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(code3);
          case 60:
          case 62:
            return this.readToken_lt_gt(code3);
          case 61:
          case 33:
            return this.readToken_eq_excl(code3);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(types$12.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + codePointToString2(code3) + "'");
      };
      pp2.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str);
      };
      pp2.readRegexp = function() {
        var escaped, inClass, start3 = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(start3, "Unterminated regular expression");
          }
          var ch = this.input.charAt(this.pos);
          if (lineBreak2.test(ch)) {
            this.raise(start3, "Unterminated regular expression");
          }
          if (!escaped) {
            if (ch === "[") {
              inClass = true;
            } else if (ch === "]" && inClass) {
              inClass = false;
            } else if (ch === "/" && !inClass) {
              break;
            }
            escaped = ch === "\\";
          } else {
            escaped = false;
          }
          ++this.pos;
        }
        var pattern = this.input.slice(start3, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) {
          this.unexpected(flagsStart);
        }
        var state = this.regexpState || (this.regexpState = new RegExpValidationState3(this));
        state.reset(start3, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);
        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
        }
        return this.finishToken(types$12.regexp, { pattern, flags, value });
      };
      pp2.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
        var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
        var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
        var start3 = this.pos, total = 0, lastCode = 0;
        for (var i2 = 0, e = len == null ? Infinity : len; i2 < e; ++i2, ++this.pos) {
          var code3 = this.input.charCodeAt(this.pos), val = void 0;
          if (allowSeparators && code3 === 95) {
            if (isLegacyOctalNumericLiteral) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
            }
            if (lastCode === 95) {
              this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
            }
            if (i2 === 0) {
              this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
            }
            lastCode = code3;
            continue;
          }
          if (code3 >= 97) {
            val = code3 - 97 + 10;
          } else if (code3 >= 65) {
            val = code3 - 65 + 10;
          } else if (code3 >= 48 && code3 <= 57) {
            val = code3 - 48;
          } else {
            val = Infinity;
          }
          if (val >= radix) {
            break;
          }
          lastCode = code3;
          total = total * radix + val;
        }
        if (allowSeparators && lastCode === 95) {
          this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
        }
        if (this.pos === start3 || len != null && this.pos - start3 !== len) {
          return null;
        }
        return total;
      };
      function stringToNumber2(str, isLegacyOctalNumericLiteral) {
        if (isLegacyOctalNumericLiteral) {
          return parseInt(str, 8);
        }
        return parseFloat(str.replace(/_/g, ""));
      }
      function stringToBigInt2(str) {
        if (typeof BigInt !== "function") {
          return null;
        }
        return BigInt(str.replace(/_/g, ""));
      }
      pp2.readRadixNumber = function(radix) {
        var start3 = this.pos;
        this.pos += 2;
        var val = this.readInt(radix);
        if (val == null) {
          this.raise(this.start + 2, "Expected number in radix " + radix);
        }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = stringToBigInt2(this.input.slice(start3, this.pos));
          ++this.pos;
        } else if (isIdentifierStart2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        return this.finishToken(types$12.num, val);
      };
      pp2.readNumber = function(startsWithDot) {
        var start3 = this.pos;
        if (!startsWithDot && this.readInt(10, void 0, true) === null) {
          this.raise(start3, "Invalid number");
        }
        var octal = this.pos - start3 >= 2 && this.input.charCodeAt(start3) === 48;
        if (octal && this.strict) {
          this.raise(start3, "Invalid number");
        }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var val$1 = stringToBigInt2(this.input.slice(start3, this.pos));
          ++this.pos;
          if (isIdentifierStart2(this.fullCharCodeAtPos())) {
            this.raise(this.pos, "Identifier directly after number");
          }
          return this.finishToken(types$12.num, val$1);
        }
        if (octal && /[89]/.test(this.input.slice(start3, this.pos))) {
          octal = false;
        }
        if (next === 46 && !octal) {
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) {
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) {
            ++this.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(start3, "Invalid number");
          }
        }
        if (isIdentifierStart2(this.fullCharCodeAtPos())) {
          this.raise(this.pos, "Identifier directly after number");
        }
        var val = stringToNumber2(this.input.slice(start3, this.pos), octal);
        return this.finishToken(types$12.num, val);
      };
      pp2.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code3;
        if (ch === 123) {
          if (this.options.ecmaVersion < 6) {
            this.unexpected();
          }
          var codePos = ++this.pos;
          code3 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code3 > 1114111) {
            this.invalidStringToken(codePos, "Code point out of bounds");
          }
        } else {
          code3 = this.readHexChar(4);
        }
        return code3;
      };
      pp2.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated string constant");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) {
            break;
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else if (ch === 8232 || ch === 8233) {
            if (this.options.ecmaVersion < 10) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
            if (this.options.locations) {
              this.curLine++;
              this.lineStart = this.pos;
            }
          } else {
            if (isNewLine2(ch)) {
              this.raise(this.start, "Unterminated string constant");
            }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types$12.string, out);
      };
      var INVALID_TEMPLATE_ESCAPE_ERROR2 = {};
      pp2.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR2) {
            this.readInvalidTemplateToken();
          } else {
            throw err;
          }
        }
        this.inTemplateElement = false;
      };
      pp2.invalidStringToken = function(position2, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR2;
        } else {
          this.raise(position2, message);
        }
      };
      pp2.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (; ; ) {
          if (this.pos >= this.input.length) {
            this.raise(this.start, "Unterminated template");
          }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
            if (this.pos === this.start && (this.type === types$12.template || this.type === types$12.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types$12.dollarBraceL);
              } else {
                ++this.pos;
                return this.finishToken(types$12.backQuote);
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types$12.template, out);
          }
          if (ch === 92) {
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine2(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) {
                  ++this.pos;
                }
              case 10:
                out += "\n";
                break;
              default:
                out += String.fromCharCode(ch);
                break;
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };
      pp2.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break;
              }
            // falls through
            case "`":
              return this.finishToken(types$12.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        }
        this.raise(this.start, "Unterminated template");
      };
      pp2.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
          case 110:
            return "\n";
          // 'n' -> '\n'
          case 114:
            return "\r";
          // 'r' -> '\r'
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          // 'x'
          case 117:
            return codePointToString2(this.readCodePoint());
          // 'u'
          case 116:
            return "	";
          // 't' -> '\t'
          case 98:
            return "\b";
          // 'b' -> '\b'
          case 118:
            return "\v";
          // 'v' -> '\u000b'
          case 102:
            return "\f";
          // 'f' -> '\f'
          case 13:
            if (this.input.charCodeAt(this.pos) === 10) {
              ++this.pos;
            }
          // '\r\n'
          case 10:
            if (this.options.locations) {
              this.lineStart = this.pos;
              ++this.curLine;
            }
            return "";
          case 56:
          case 57:
            if (this.strict) {
              this.invalidStringToken(
                this.pos - 1,
                "Invalid escape sequence"
              );
            }
            if (inTemplate) {
              var codePos = this.pos - 1;
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal);
            }
            if (isNewLine2(ch)) {
              return "";
            }
            return String.fromCharCode(ch);
        }
      };
      pp2.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) {
          this.invalidStringToken(codePos, "Bad character escape sequence");
        }
        return n;
      };
      pp2.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar2(ch, astral)) {
            this.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) {
              this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
            }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart2 : isIdentifierChar2)(esc, astral)) {
              this.invalidStringToken(escStart, "Invalid Unicode escape");
            }
            word += codePointToString2(esc);
            chunkStart = this.pos;
          } else {
            break;
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos);
      };
      pp2.readWord = function() {
        var word = this.readWord1();
        var type = types$12.name;
        if (this.keywords.test(word)) {
          type = keywords2[word];
        }
        return this.finishToken(type, word);
      };
      var version2 = "8.8.2";
      Parser3.acorn = {
        Parser: Parser3,
        version: version2,
        defaultOptions: defaultOptions2,
        Position: Position3,
        SourceLocation: SourceLocation3,
        getLineInfo: getLineInfo2,
        Node: Node3,
        TokenType: TokenType3,
        tokTypes: types$12,
        keywordTypes: keywords2,
        TokContext: TokContext3,
        tokContexts: types3,
        isIdentifierChar: isIdentifierChar2,
        isIdentifierStart: isIdentifierStart2,
        Token: Token3,
        isNewLine: isNewLine2,
        lineBreak: lineBreak2,
        lineBreakG: lineBreakG2,
        nonASCIIwhitespace: nonASCIIwhitespace2
      };
      function parse5(input, options) {
        return Parser3.parse(input, options);
      }
      function parseExpressionAt3(input, pos, options) {
        return Parser3.parseExpressionAt(input, pos, options);
      }
      function tokenizer3(input, options) {
        return Parser3.tokenizer(input, options);
      }
      exports2.Node = Node3;
      exports2.Parser = Parser3;
      exports2.Position = Position3;
      exports2.SourceLocation = SourceLocation3;
      exports2.TokContext = TokContext3;
      exports2.Token = Token3;
      exports2.TokenType = TokenType3;
      exports2.defaultOptions = defaultOptions2;
      exports2.getLineInfo = getLineInfo2;
      exports2.isIdentifierChar = isIdentifierChar2;
      exports2.isIdentifierStart = isIdentifierStart2;
      exports2.isNewLine = isNewLine2;
      exports2.keywordTypes = keywords2;
      exports2.lineBreak = lineBreak2;
      exports2.lineBreakG = lineBreakG2;
      exports2.nonASCIIwhitespace = nonASCIIwhitespace2;
      exports2.parse = parse5;
      exports2.parseExpressionAt = parseExpressionAt3;
      exports2.tokContexts = types3;
      exports2.tokTypes = types$12;
      exports2.tokenizer = tokenizer3;
      exports2.version = version2;
    });
  }
});

// ../../../node_modules/.pnpm/acorn-jsx@5.3.2_acorn@8.8.2/node_modules/acorn-jsx/index.js
var require_acorn_jsx = __commonJS({
  "../../../node_modules/.pnpm/acorn-jsx@5.3.2_acorn@8.8.2/node_modules/acorn-jsx/index.js"(exports, module) {
    "use strict";
    var XHTMLEntities = require_xhtml();
    var hexNumber = /^[\da-fA-F]+$/;
    var decimalNumber = /^\d+$/;
    var acornJsxMap = /* @__PURE__ */ new WeakMap();
    function getJsxTokens(acorn) {
      acorn = acorn.Parser.acorn || acorn;
      let acornJsx2 = acornJsxMap.get(acorn);
      if (!acornJsx2) {
        const tt2 = acorn.tokTypes;
        const TokContext3 = acorn.TokContext;
        const TokenType3 = acorn.TokenType;
        const tc_oTag = new TokContext3("<tag", false);
        const tc_cTag = new TokContext3("</tag", false);
        const tc_expr = new TokContext3("<tag>...</tag>", true, true);
        const tokContexts = {
          tc_oTag,
          tc_cTag,
          tc_expr
        };
        const tokTypes = {
          jsxName: new TokenType3("jsxName"),
          jsxText: new TokenType3("jsxText", { beforeExpr: true }),
          jsxTagStart: new TokenType3("jsxTagStart", { startsExpr: true }),
          jsxTagEnd: new TokenType3("jsxTagEnd")
        };
        tokTypes.jsxTagStart.updateContext = function() {
          this.context.push(tc_expr);
          this.context.push(tc_oTag);
          this.exprAllowed = false;
        };
        tokTypes.jsxTagEnd.updateContext = function(prevType) {
          let out = this.context.pop();
          if (out === tc_oTag && prevType === tt2.slash || out === tc_cTag) {
            this.context.pop();
            this.exprAllowed = this.curContext() === tc_expr;
          } else {
            this.exprAllowed = true;
          }
        };
        acornJsx2 = { tokContexts, tokTypes };
        acornJsxMap.set(acorn, acornJsx2);
      }
      return acornJsx2;
    }
    function getQualifiedJSXName(object) {
      if (!object)
        return object;
      if (object.type === "JSXIdentifier")
        return object.name;
      if (object.type === "JSXNamespacedName")
        return object.namespace.name + ":" + object.name.name;
      if (object.type === "JSXMemberExpression")
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }
    module.exports = function(options) {
      options = options || {};
      return function(Parser3) {
        return plugin({
          allowNamespaces: options.allowNamespaces !== false,
          allowNamespacedObjects: !!options.allowNamespacedObjects
        }, Parser3);
      };
    };
    Object.defineProperty(module.exports, "tokTypes", {
      get: function get_tokTypes() {
        return getJsxTokens(require_acorn()).tokTypes;
      },
      configurable: true,
      enumerable: true
    });
    function plugin(options, Parser3) {
      const acorn = Parser3.acorn || require_acorn();
      const acornJsx2 = getJsxTokens(acorn);
      const tt2 = acorn.tokTypes;
      const tok = acornJsx2.tokTypes;
      const tokContexts = acorn.tokContexts;
      const tc_oTag = acornJsx2.tokContexts.tc_oTag;
      const tc_cTag = acornJsx2.tokContexts.tc_cTag;
      const tc_expr = acornJsx2.tokContexts.tc_expr;
      const isNewLine2 = acorn.isNewLine;
      const isIdentifierStart2 = acorn.isIdentifierStart;
      const isIdentifierChar2 = acorn.isIdentifierChar;
      return class extends Parser3 {
        // Expose actual `tokTypes` and `tokContexts` to other plugins.
        static get acornJsx() {
          return acornJsx2;
        }
        // Reads inline JSX contents token.
        jsx_readToken() {
          let out = "", chunkStart = this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated JSX contents");
            let ch = this.input.charCodeAt(this.pos);
            switch (ch) {
              case 60:
              // '<'
              case 123:
                if (this.pos === this.start) {
                  if (ch === 60 && this.exprAllowed) {
                    ++this.pos;
                    return this.finishToken(tok.jsxTagStart);
                  }
                  return this.getTokenFromCode(ch);
                }
                out += this.input.slice(chunkStart, this.pos);
                return this.finishToken(tok.jsxText, out);
              case 38:
                out += this.input.slice(chunkStart, this.pos);
                out += this.jsx_readEntity();
                chunkStart = this.pos;
                break;
              case 62:
              // '>'
              case 125:
                this.raise(
                  this.pos,
                  "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (ch === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
                );
              default:
                if (isNewLine2(ch)) {
                  out += this.input.slice(chunkStart, this.pos);
                  out += this.jsx_readNewLine(true);
                  chunkStart = this.pos;
                } else {
                  ++this.pos;
                }
            }
          }
        }
        jsx_readNewLine(normalizeCRLF) {
          let ch = this.input.charCodeAt(this.pos);
          let out;
          ++this.pos;
          if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
            out = normalizeCRLF ? "\n" : "\r\n";
          } else {
            out = String.fromCharCode(ch);
          }
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          return out;
        }
        jsx_readString(quote) {
          let out = "", chunkStart = ++this.pos;
          for (; ; ) {
            if (this.pos >= this.input.length)
              this.raise(this.start, "Unterminated string constant");
            let ch = this.input.charCodeAt(this.pos);
            if (ch === quote) break;
            if (ch === 38) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readEntity();
              chunkStart = this.pos;
            } else if (isNewLine2(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              out += this.jsx_readNewLine(false);
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(tt2.string, out);
        }
        jsx_readEntity() {
          let str = "", count = 0, entity;
          let ch = this.input[this.pos];
          if (ch !== "&")
            this.raise(this.pos, "Entity must start with an ampersand");
          let startPos = ++this.pos;
          while (this.pos < this.input.length && count++ < 10) {
            ch = this.input[this.pos++];
            if (ch === ";") {
              if (str[0] === "#") {
                if (str[1] === "x") {
                  str = str.substr(2);
                  if (hexNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 16));
                } else {
                  str = str.substr(1);
                  if (decimalNumber.test(str))
                    entity = String.fromCharCode(parseInt(str, 10));
                }
              } else {
                entity = XHTMLEntities[str];
              }
              break;
            }
            str += ch;
          }
          if (!entity) {
            this.pos = startPos;
            return "&";
          }
          return entity;
        }
        // Read a JSX identifier (valid tag or attribute name).
        //
        // Optimized version since JSX identifiers can't contain
        // escape characters and so can be read as single slice.
        // Also assumes that first character was already checked
        // by isIdentifierStart in readToken.
        jsx_readWord() {
          let ch, start3 = this.pos;
          do {
            ch = this.input.charCodeAt(++this.pos);
          } while (isIdentifierChar2(ch) || ch === 45);
          return this.finishToken(tok.jsxName, this.input.slice(start3, this.pos));
        }
        // Parse next token as JSX identifier
        jsx_parseIdentifier() {
          let node2 = this.startNode();
          if (this.type === tok.jsxName)
            node2.name = this.value;
          else if (this.type.keyword)
            node2.name = this.type.keyword;
          else
            this.unexpected();
          this.next();
          return this.finishNode(node2, "JSXIdentifier");
        }
        // Parse namespaced identifier.
        jsx_parseNamespacedName() {
          let startPos = this.start, startLoc = this.startLoc;
          let name2 = this.jsx_parseIdentifier();
          if (!options.allowNamespaces || !this.eat(tt2.colon)) return name2;
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.namespace = name2;
          node2.name = this.jsx_parseIdentifier();
          return this.finishNode(node2, "JSXNamespacedName");
        }
        // Parses element name in any form - namespaced, member
        // or single identifier.
        jsx_parseElementName() {
          if (this.type === tok.jsxTagEnd) return "";
          let startPos = this.start, startLoc = this.startLoc;
          let node2 = this.jsx_parseNamespacedName();
          if (this.type === tt2.dot && node2.type === "JSXNamespacedName" && !options.allowNamespacedObjects) {
            this.unexpected();
          }
          while (this.eat(tt2.dot)) {
            let newNode = this.startNodeAt(startPos, startLoc);
            newNode.object = node2;
            newNode.property = this.jsx_parseIdentifier();
            node2 = this.finishNode(newNode, "JSXMemberExpression");
          }
          return node2;
        }
        // Parses any type of JSX attribute value.
        jsx_parseAttributeValue() {
          switch (this.type) {
            case tt2.braceL:
              let node2 = this.jsx_parseExpressionContainer();
              if (node2.expression.type === "JSXEmptyExpression")
                this.raise(node2.start, "JSX attributes must only be assigned a non-empty expression");
              return node2;
            case tok.jsxTagStart:
            case tt2.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
        // JSXEmptyExpression is unique type since it doesn't actually parse anything,
        // and so it should start at the end of last read token (left brace) and finish
        // at the beginning of the next one (right brace).
        jsx_parseEmptyExpression() {
          let node2 = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(node2, "JSXEmptyExpression", this.start, this.startLoc);
        }
        // Parses JSX expression enclosed into curly brackets.
        jsx_parseExpressionContainer() {
          let node2 = this.startNode();
          this.next();
          node2.expression = this.type === tt2.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression();
          this.expect(tt2.braceR);
          return this.finishNode(node2, "JSXExpressionContainer");
        }
        // Parses following JSX attribute name-value pair.
        jsx_parseAttribute() {
          let node2 = this.startNode();
          if (this.eat(tt2.braceL)) {
            this.expect(tt2.ellipsis);
            node2.argument = this.parseMaybeAssign();
            this.expect(tt2.braceR);
            return this.finishNode(node2, "JSXSpreadAttribute");
          }
          node2.name = this.jsx_parseNamespacedName();
          node2.value = this.eat(tt2.eq) ? this.jsx_parseAttributeValue() : null;
          return this.finishNode(node2, "JSXAttribute");
        }
        // Parses JSX opening tag starting after '<'.
        jsx_parseOpeningElementAt(startPos, startLoc) {
          let node2 = this.startNodeAt(startPos, startLoc);
          node2.attributes = [];
          let nodeName = this.jsx_parseElementName();
          if (nodeName) node2.name = nodeName;
          while (this.type !== tt2.slash && this.type !== tok.jsxTagEnd)
            node2.attributes.push(this.jsx_parseAttribute());
          node2.selfClosing = this.eat(tt2.slash);
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node2, nodeName ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
        // Parses JSX closing tag starting after '</'.
        jsx_parseClosingElementAt(startPos, startLoc) {
          let node2 = this.startNodeAt(startPos, startLoc);
          let nodeName = this.jsx_parseElementName();
          if (nodeName) node2.name = nodeName;
          this.expect(tok.jsxTagEnd);
          return this.finishNode(node2, nodeName ? "JSXClosingElement" : "JSXClosingFragment");
        }
        // Parses entire JSX element, including it's opening tag
        // (starting after '<'), attributes, contents and closing tag.
        jsx_parseElementAt(startPos, startLoc) {
          let node2 = this.startNodeAt(startPos, startLoc);
          let children = [];
          let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
          let closingElement = null;
          if (!openingElement.selfClosing) {
            contents: for (; ; ) {
              switch (this.type) {
                case tok.jsxTagStart:
                  startPos = this.start;
                  startLoc = this.startLoc;
                  this.next();
                  if (this.eat(tt2.slash)) {
                    closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
                    break contents;
                  }
                  children.push(this.jsx_parseElementAt(startPos, startLoc));
                  break;
                case tok.jsxText:
                  children.push(this.parseExprAtom());
                  break;
                case tt2.braceL:
                  children.push(this.jsx_parseExpressionContainer());
                  break;
                default:
                  this.unexpected();
              }
            }
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(
                closingElement.start,
                "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">"
              );
            }
          }
          let fragmentOrElement = openingElement.name ? "Element" : "Fragment";
          node2["opening" + fragmentOrElement] = openingElement;
          node2["closing" + fragmentOrElement] = closingElement;
          node2.children = children;
          if (this.type === tt2.relational && this.value === "<") {
            this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
          }
          return this.finishNode(node2, "JSX" + fragmentOrElement);
        }
        // Parse JSX text
        jsx_parseText() {
          let node2 = this.parseLiteral(this.value);
          node2.type = "JSXText";
          return node2;
        }
        // Parses entire JSX element from current position.
        jsx_parseElement() {
          let startPos = this.start, startLoc = this.startLoc;
          this.next();
          return this.jsx_parseElementAt(startPos, startLoc);
        }
        parseExprAtom(refShortHandDefaultPos) {
          if (this.type === tok.jsxText)
            return this.jsx_parseText();
          else if (this.type === tok.jsxTagStart)
            return this.jsx_parseElement();
          else
            return super.parseExprAtom(refShortHandDefaultPos);
        }
        readToken(code3) {
          let context = this.curContext();
          if (context === tc_expr) return this.jsx_readToken();
          if (context === tc_oTag || context === tc_cTag) {
            if (isIdentifierStart2(code3)) return this.jsx_readWord();
            if (code3 == 62) {
              ++this.pos;
              return this.finishToken(tok.jsxTagEnd);
            }
            if ((code3 === 34 || code3 === 39) && context == tc_oTag)
              return this.jsx_readString(code3);
          }
          if (code3 === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) {
            ++this.pos;
            return this.finishToken(tok.jsxTagStart);
          }
          return super.readToken(code3);
        }
        updateContext(prevType) {
          if (this.type == tt2.braceL) {
            var curContext = this.curContext();
            if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);
            else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);
            else super.updateContext(prevType);
            this.exprAllowed = true;
          } else if (this.type === tt2.slash && prevType === tok.jsxTagStart) {
            this.context.length -= 2;
            this.context.push(tc_cTag);
            this.exprAllowed = false;
          } else {
            return super.updateContext(prevType);
          }
        }
      };
    }
  }
});

// ../../../node_modules/.pnpm/lodash.flatten@4.4.0/node_modules/lodash.flatten/index.js
var require_lodash = __commonJS({
  "../../../node_modules/.pnpm/lodash.flatten@4.4.0/node_modules/lodash.flatten/index.js"(exports, module) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    function arrayPush(array, values2) {
      var index2 = -1, length = values2.length, offset2 = array.length;
      while (++index2 < length) {
        array[offset2 + index2] = values2[index2];
      }
      return array;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty3 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol2 = root2.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index2 = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index2 < length) {
        var value = array[index2];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function isFlattenable(value) {
      return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function flatten2(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, 1) : [];
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty3.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module.exports = flatten2;
  }
});

// ../../../node_modules/.pnpm/bail@2.0.2/node_modules/bail/index.js
function bail(error) {
  if (error) {
    throw error;
  }
}

// ../../../node_modules/.pnpm/unified@10.1.2/node_modules/unified/lib/index.js
var import_is_buffer2 = __toESM(require_is_buffer(), 1);
var import_extend = __toESM(require_extend(), 1);

// ../../../node_modules/.pnpm/is-plain-obj@4.1.0/node_modules/is-plain-obj/index.js
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// ../../../node_modules/.pnpm/trough@2.2.0/node_modules/trough/lib/index.js
function trough() {
  const fns = [];
  const pipeline = { run: run2, use };
  return pipeline;
  function run2(...values2) {
    let middlewareIndex = -1;
    const callback = values2.pop();
    if (typeof callback !== "function") {
      throw new TypeError("Expected function as last argument, not " + callback);
    }
    next(null, ...values2);
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index2 = -1;
      if (error) {
        callback(error);
        return;
      }
      while (++index2 < values2.length) {
        if (output[index2] === null || output[index2] === void 0) {
          output[index2] = values2[index2];
        }
      }
      values2 = output;
      if (fn) {
        wrap(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }
  function use(middelware) {
    if (typeof middelware !== "function") {
      throw new TypeError(
        "Expected `middelware` to be a function, not " + middelware
      );
    }
    fns.push(middelware);
    return pipeline;
  }
}
function wrap(middleware, callback) {
  let called;
  return wrapped;
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    let result;
    if (fnExpectsCallback) {
      parameters.push(done);
    }
    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = (
        /** @type {Error} */
        error
      );
      if (fnExpectsCallback && called) {
        throw exception;
      }
      return done(exception);
    }
    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === "function") {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }
  function then(value) {
    done(null, value);
  }
}

// ../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/index.js
var import_is_buffer = __toESM(require_is_buffer(), 1);

// ../../../node_modules/.pnpm/unist-util-stringify-position@3.0.3/node_modules/unist-util-stringify-position/lib/index.js
function stringifyPosition(value) {
  if (!value || typeof value !== "object") {
    return "";
  }
  if ("position" in value || "type" in value) {
    return position(value.position);
  }
  if ("start" in value || "end" in value) {
    return position(value);
  }
  if ("line" in value || "column" in value) {
    return point(value);
  }
  return "";
}
function point(point3) {
  return index(point3 && point3.line) + ":" + index(point3 && point3.column);
}
function position(pos) {
  return point(pos && pos.start) + "-" + point(pos && pos.end);
}
function index(value) {
  return value && typeof value === "number" ? value : 1;
}

// ../../../node_modules/.pnpm/vfile-message@3.1.4/node_modules/vfile-message/lib/index.js
var VFileMessage = class extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(reason, place, origin) {
    const parts = [null, null];
    let position2 = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: { line: null, column: null },
      // @ts-expect-error: "
      end: { line: null, column: null }
    };
    super();
    if (typeof place === "string") {
      origin = place;
      place = void 0;
    }
    if (typeof origin === "string") {
      const index2 = origin.indexOf(":");
      if (index2 === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index2);
        parts[1] = origin.slice(index2 + 1);
      }
    }
    if (place) {
      if ("type" in place || "position" in place) {
        if (place.position) {
          position2 = place.position;
        }
      } else if ("start" in place || "end" in place) {
        position2 = place;
      } else if ("line" in place || "column" in place) {
        position2.start = place;
      }
    }
    this.name = stringifyPosition(place) || "1:1";
    this.message = typeof reason === "object" ? reason.message : reason;
    this.stack = "";
    if (typeof reason === "object" && reason.stack) {
      this.stack = reason.stack;
    }
    this.reason = this.message;
    this.fatal;
    this.line = position2.start.line;
    this.column = position2.start.column;
    this.position = position2;
    this.source = parts[0];
    this.ruleId = parts[1];
    this.file;
    this.actual;
    this.expected;
    this.url;
    this.note;
  }
};
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;

// ../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minpath.browser.js
var path = { basename, dirname, extname, join, sep: "/" };
function basename(path3, ext) {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path3);
  let start3 = 0;
  let end = -1;
  let index2 = path3.length;
  let seenNonSlash;
  if (ext === void 0 || ext.length === 0 || ext.length > path3.length) {
    while (index2--) {
      if (path3.charCodeAt(index2) === 47) {
        if (seenNonSlash) {
          start3 = index2 + 1;
          break;
        }
      } else if (end < 0) {
        seenNonSlash = true;
        end = index2 + 1;
      }
    }
    return end < 0 ? "" : path3.slice(start3, end);
  }
  if (ext === path3) {
    return "";
  }
  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;
  while (index2--) {
    if (path3.charCodeAt(index2) === 47) {
      if (seenNonSlash) {
        start3 = index2 + 1;
        break;
      }
    } else {
      if (firstNonSlashEnd < 0) {
        seenNonSlash = true;
        firstNonSlashEnd = index2 + 1;
      }
      if (extIndex > -1) {
        if (path3.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            end = index2;
          }
        } else {
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }
  if (start3 === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path3.length;
  }
  return path3.slice(start3, end);
}
function dirname(path3) {
  assertPath(path3);
  if (path3.length === 0) {
    return ".";
  }
  let end = -1;
  let index2 = path3.length;
  let unmatchedSlash;
  while (--index2) {
    if (path3.charCodeAt(index2) === 47) {
      if (unmatchedSlash) {
        end = index2;
        break;
      }
    } else if (!unmatchedSlash) {
      unmatchedSlash = true;
    }
  }
  return end < 0 ? path3.charCodeAt(0) === 47 ? "/" : "." : end === 1 && path3.charCodeAt(0) === 47 ? "//" : path3.slice(0, end);
}
function extname(path3) {
  assertPath(path3);
  let index2 = path3.length;
  let end = -1;
  let startPart = 0;
  let startDot = -1;
  let preDotState = 0;
  let unmatchedSlash;
  while (index2--) {
    const code3 = path3.charCodeAt(index2);
    if (code3 === 47) {
      if (unmatchedSlash) {
        startPart = index2 + 1;
        break;
      }
      continue;
    }
    if (end < 0) {
      unmatchedSlash = true;
      end = index2 + 1;
    }
    if (code3 === 46) {
      if (startDot < 0) {
        startDot = index2;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      preDotState = -1;
    }
  }
  if (startDot < 0 || end < 0 || // We saw a non-dot character immediately before the dot.
  preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path3.slice(startDot, end);
}
function join(...segments) {
  let index2 = -1;
  let joined;
  while (++index2 < segments.length) {
    assertPath(segments[index2]);
    if (segments[index2]) {
      joined = joined === void 0 ? segments[index2] : joined + "/" + segments[index2];
    }
  }
  return joined === void 0 ? "." : normalize(joined);
}
function normalize(path3) {
  assertPath(path3);
  const absolute = path3.charCodeAt(0) === 47;
  let value = normalizeString(path3, !absolute);
  if (value.length === 0 && !absolute) {
    value = ".";
  }
  if (value.length > 0 && path3.charCodeAt(path3.length - 1) === 47) {
    value += "/";
  }
  return absolute ? "/" + value : value;
}
function normalizeString(path3, allowAboveRoot) {
  let result = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index2 = -1;
  let code3;
  let lastSlashIndex;
  while (++index2 <= path3.length) {
    if (index2 < path3.length) {
      code3 = path3.charCodeAt(index2);
    } else if (code3 === 47) {
      break;
    } else {
      code3 = 47;
    }
    if (code3 === 47) {
      if (lastSlash === index2 - 1 || dots === 1) {
      } else if (lastSlash !== index2 - 1 && dots === 2) {
        if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf("/");
            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = "";
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
              }
              lastSlash = index2;
              dots = 0;
              continue;
            }
          } else if (result.length > 0) {
            result = "";
            lastSegmentLength = 0;
            lastSlash = index2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          result = result.length > 0 ? result + "/.." : "..";
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += "/" + path3.slice(lastSlash + 1, index2);
        } else {
          result = path3.slice(lastSlash + 1, index2);
        }
        lastSegmentLength = index2 - lastSlash - 1;
      }
      lastSlash = index2;
      dots = 0;
    } else if (code3 === 46 && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }
  return result;
}
function assertPath(path3) {
  if (typeof path3 !== "string") {
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(path3)
    );
  }
}

// ../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minproc.browser.js
var proc = { cwd };
function cwd() {
  return "/";
}

// ../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minurl.shared.js
function isUrl(fileUrlOrPath) {
  return fileUrlOrPath !== null && typeof fileUrlOrPath === "object" && // @ts-expect-error: indexable.
  fileUrlOrPath.href && // @ts-expect-error: indexable.
  fileUrlOrPath.origin;
}

// ../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/minurl.browser.js
function urlToPath(path3) {
  if (typeof path3 === "string") {
    path3 = new URL(path3);
  } else if (!isUrl(path3)) {
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + path3 + "`"
    );
    error.code = "ERR_INVALID_ARG_TYPE";
    throw error;
  }
  if (path3.protocol !== "file:") {
    const error = new TypeError("The URL must be of scheme file");
    error.code = "ERR_INVALID_URL_SCHEME";
    throw error;
  }
  return getPathFromURLPosix(path3);
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = "ERR_INVALID_FILE_URL_HOST";
    throw error;
  }
  const pathname = url.pathname;
  let index2 = -1;
  while (++index2 < pathname.length) {
    if (pathname.charCodeAt(index2) === 37 && pathname.charCodeAt(index2 + 1) === 50) {
      const third = pathname.charCodeAt(index2 + 2);
      if (third === 70 || third === 102) {
        const error = new TypeError(
          "File URL path must not include encoded / characters"
        );
        error.code = "ERR_INVALID_FILE_URL_PATH";
        throw error;
      }
    }
  }
  return decodeURIComponent(pathname);
}

// ../../../node_modules/.pnpm/vfile@5.3.7/node_modules/vfile/lib/index.js
var order = ["history", "path", "basename", "stem", "extname", "dirname"];
var VFile = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    let options;
    if (!value) {
      options = {};
    } else if (typeof value === "string" || buffer(value)) {
      options = { value };
    } else if (isUrl(value)) {
      options = { path: value };
    } else {
      options = value;
    }
    this.data = {};
    this.messages = [];
    this.history = [];
    this.cwd = proc.cwd();
    this.value;
    this.stored;
    this.result;
    this.map;
    let index2 = -1;
    while (++index2 < order.length) {
      const prop2 = order[index2];
      if (prop2 in options && options[prop2] !== void 0 && options[prop2] !== null) {
        this[prop2] = prop2 === "history" ? [...options[prop2]] : options[prop2];
      }
    }
    let prop;
    for (prop in options) {
      if (!order.includes(prop)) {
        this[prop] = options[prop];
      }
    }
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(path3) {
    if (isUrl(path3)) {
      path3 = urlToPath(path3);
    }
    assertNonEmpty(path3, "path");
    if (this.path !== path3) {
      this.history.push(path3);
    }
  }
  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path === "string" ? path.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(dirname2) {
    assertPath2(this.basename, "dirname");
    this.path = path.join(dirname2 || "", this.basename);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path === "string" ? path.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(basename2) {
    assertNonEmpty(basename2, "basename");
    assertPart(basename2, "basename");
    this.path = path.join(this.dirname || "", basename2);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path === "string" ? path.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(extname2) {
    assertPart(extname2, "extname");
    assertPath2(this.dirname, "extname");
    if (extname2) {
      if (extname2.charCodeAt(0) !== 46) {
        throw new Error("`extname` must start with `.`");
      }
      if (extname2.includes(".", 1)) {
        throw new Error("`extname` cannot contain multiple dots");
      }
    }
    this.path = path.join(this.dirname, this.stem + (extname2 || ""));
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path === "string" ? path.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(stem) {
    assertNonEmpty(stem, "stem");
    assertPart(stem, "stem");
    this.path = path.join(this.dirname || "", stem + (this.extname || ""));
  }
  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return (this.value || "").toString(encoding || void 0);
  }
  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(reason, place, origin) {
    const message = new VFileMessage(reason, place, origin);
    if (this.path) {
      message.name = this.path + ":" + message.name;
      message.file = this.path;
    }
    message.fatal = false;
    this.messages.push(message);
    return message;
  }
  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = null;
    return message;
  }
  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);
    message.fatal = true;
    throw message;
  }
};
function assertPart(part, name2) {
  if (part && part.includes(path.sep)) {
    throw new Error(
      "`" + name2 + "` cannot be a path: did not expect `" + path.sep + "`"
    );
  }
}
function assertNonEmpty(part, name2) {
  if (!part) {
    throw new Error("`" + name2 + "` cannot be empty");
  }
}
function assertPath2(path3, name2) {
  if (!path3) {
    throw new Error("Setting `" + name2 + "` requires `path` to be set too");
  }
}
function buffer(value) {
  return (0, import_is_buffer.default)(value);
}

// ../../../node_modules/.pnpm/unified@10.1.2/node_modules/unified/lib/index.js
var unified = base().freeze();
var own = {}.hasOwnProperty;
function base() {
  const transformers = trough();
  const attachers = [];
  let namespace = {};
  let frozen;
  let freezeIndex = -1;
  processor.data = data2;
  processor.Parser = void 0;
  processor.Compiler = void 0;
  processor.freeze = freeze;
  processor.attachers = attachers;
  processor.use = use;
  processor.parse = parse5;
  processor.stringify = stringify2;
  processor.run = run2;
  processor.runSync = runSync;
  processor.process = process2;
  processor.processSync = processSync;
  return processor;
  function processor() {
    const destination = base();
    let index2 = -1;
    while (++index2 < attachers.length) {
      destination.use(...attachers[index2]);
    }
    destination.data((0, import_extend.default)(true, {}, namespace));
    return destination;
  }
  function data2(key, value) {
    if (typeof key === "string") {
      if (arguments.length === 2) {
        assertUnfrozen("data", frozen);
        namespace[key] = value;
        return processor;
      }
      return own.call(namespace, key) && namespace[key] || null;
    }
    if (key) {
      assertUnfrozen("data", frozen);
      namespace = key;
      return processor;
    }
    return namespace;
  }
  function freeze() {
    if (frozen) {
      return processor;
    }
    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];
      if (options[0] === false) {
        continue;
      }
      if (options[0] === true) {
        options[0] = void 0;
      }
      const transformer = attacher.call(processor, ...options);
      if (typeof transformer === "function") {
        transformers.use(transformer);
      }
    }
    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;
    return processor;
  }
  function use(value, ...options) {
    let settings;
    assertUnfrozen("use", frozen);
    if (value === null || value === void 0) {
    } else if (typeof value === "function") {
      addPlugin(value, ...options);
    } else if (typeof value === "object") {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError("Expected usable value, not `" + value + "`");
    }
    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }
    return processor;
    function add(value2) {
      if (typeof value2 === "function") {
        addPlugin(value2);
      } else if (typeof value2 === "object") {
        if (Array.isArray(value2)) {
          const [plugin, ...options2] = value2;
          addPlugin(plugin, ...options2);
        } else {
          addPreset(value2);
        }
      } else {
        throw new TypeError("Expected usable value, not `" + value2 + "`");
      }
    }
    function addPreset(result) {
      addList(result.plugins);
      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }
    function addList(plugins) {
      let index2 = -1;
      if (plugins === null || plugins === void 0) {
      } else if (Array.isArray(plugins)) {
        while (++index2 < plugins.length) {
          const thing = plugins[index2];
          add(thing);
        }
      } else {
        throw new TypeError("Expected a list of plugins, not `" + plugins + "`");
      }
    }
    function addPlugin(plugin, value2) {
      let index2 = -1;
      let entry;
      while (++index2 < attachers.length) {
        if (attachers[index2][0] === plugin) {
          entry = attachers[index2];
          break;
        }
      }
      if (entry) {
        if (isPlainObject(entry[1]) && isPlainObject(value2)) {
          value2 = (0, import_extend.default)(true, entry[1], value2);
        }
        entry[1] = value2;
      } else {
        attachers.push([...arguments]);
      }
    }
  }
  function parse5(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser3 = processor.Parser;
    assertParser("parse", Parser3);
    if (newable(Parser3, "parse")) {
      return new Parser3(String(file), file).parse();
    }
    return Parser3(String(file), file);
  }
  function stringify2(node2, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler("stringify", Compiler);
    assertNode(node2);
    if (newable(Compiler, "compile")) {
      return new Compiler(node2, file).compile();
    }
    return Compiler(node2, file);
  }
  function run2(node2, doc, callback) {
    assertNode(node2);
    processor.freeze();
    if (!callback && typeof doc === "function") {
      callback = doc;
      doc = void 0;
    }
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      transformers.run(node2, vfile(doc), done);
      function done(error, tree, file) {
        tree = tree || node2;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(tree);
        } else {
          callback(null, tree, file);
        }
      }
    }
  }
  function runSync(node2, file) {
    let result;
    let complete;
    processor.run(node2, file, done);
    assertDone("runSync", "run", complete);
    return result;
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }
  function process2(doc, callback) {
    processor.freeze();
    assertParser("process", processor.Parser);
    assertCompiler("process", processor.Compiler);
    if (!callback) {
      return new Promise(executor);
    }
    executor(null, callback);
    function executor(resolve, reject) {
      const file = vfile(doc);
      processor.run(processor.parse(file), file, (error, tree, file2) => {
        if (error || !tree || !file2) {
          done(error);
        } else {
          const result = processor.stringify(tree, file2);
          if (result === void 0 || result === null) {
          } else if (looksLikeAVFileValue(result)) {
            file2.value = result;
          } else {
            file2.result = result;
          }
          done(error, file2);
        }
      });
      function done(error, file2) {
        if (error || !file2) {
          reject(error);
        } else if (resolve) {
          resolve(file2);
        } else {
          callback(null, file2);
        }
      }
    }
  }
  function processSync(doc) {
    let complete;
    processor.freeze();
    assertParser("processSync", processor.Parser);
    assertCompiler("processSync", processor.Compiler);
    const file = vfile(doc);
    processor.process(file, done);
    assertDone("processSync", "process", complete);
    return file;
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}
function newable(value, name2) {
  return typeof value === "function" && // Prototypes do exist.
  // type-coverage:ignore-next-line
  value.prototype && // A function with keys in its prototype is probably a constructor.
  // Classes’ prototype methods are not enumerable, so we check if some value
  // exists in the prototype.
  // type-coverage:ignore-next-line
  (keys(value.prototype) || name2 in value.prototype);
}
function keys(value) {
  let key;
  for (key in value) {
    if (own.call(value, key)) {
      return true;
    }
  }
  return false;
}
function assertParser(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `Parser`");
  }
}
function assertCompiler(name2, value) {
  if (typeof value !== "function") {
    throw new TypeError("Cannot `" + name2 + "` without `Compiler`");
  }
}
function assertUnfrozen(name2, frozen) {
  if (frozen) {
    throw new Error(
      "Cannot call `" + name2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
  }
}
function assertNode(node2) {
  if (!isPlainObject(node2) || typeof node2.type !== "string") {
    throw new TypeError("Expected node, got `" + node2 + "`");
  }
}
function assertDone(name2, asyncName, complete) {
  if (!complete) {
    throw new Error(
      "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
    );
  }
}
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
  return Boolean(
    value && typeof value === "object" && "message" in value && "messages" in value
  );
}
function looksLikeAVFileValue(value) {
  return typeof value === "string" || (0, import_is_buffer2.default)(value);
}

// ../../../node_modules/.pnpm/mdast-util-to-string@3.2.0/node_modules/mdast-util-to-string/lib/index.js
var emptyOptions = {};
function toString(value, options) {
  const settings = options || emptyOptions;
  const includeImageAlt = typeof settings.includeImageAlt === "boolean" ? settings.includeImageAlt : true;
  const includeHtml = typeof settings.includeHtml === "boolean" ? settings.includeHtml : true;
  return one(value, includeImageAlt, includeHtml);
}
function one(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ("value" in value) {
      return value.type === "html" && !includeHtml ? "" : value.value;
    }
    if (includeImageAlt && "alt" in value && value.alt) {
      return value.alt;
    }
    if ("children" in value) {
      return all(value.children, includeImageAlt, includeHtml);
    }
  }
  if (Array.isArray(value)) {
    return all(value, includeImageAlt, includeHtml);
  }
  return "";
}
function all(values2, includeImageAlt, includeHtml) {
  const result = [];
  let index2 = -1;
  while (++index2 < values2.length) {
    result[index2] = one(values2[index2], includeImageAlt, includeHtml);
  }
  return result.join("");
}
function node(value) {
  return Boolean(value && typeof value === "object");
}

// ../../../node_modules/.pnpm/micromark-util-chunked@1.1.0/node_modules/micromark-util-chunked/index.js
function splice(list3, start3, remove, items) {
  const end = list3.length;
  let chunkStart = 0;
  let parameters;
  if (start3 < 0) {
    start3 = -start3 > end ? 0 : end + start3;
  } else {
    start3 = start3 > end ? end : start3;
  }
  remove = remove > 0 ? remove : 0;
  if (items.length < 1e4) {
    parameters = Array.from(items);
    parameters.unshift(start3, remove);
    list3.splice(...parameters);
  } else {
    if (remove) list3.splice(start3, remove);
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 1e4);
      parameters.unshift(start3, 0);
      list3.splice(...parameters);
      chunkStart += 1e4;
      start3 += 1e4;
    }
  }
}
function push(list3, items) {
  if (list3.length > 0) {
    splice(list3, list3.length, 0, items);
    return list3;
  }
  return items;
}

// ../../../node_modules/.pnpm/micromark-util-combine-extensions@1.1.0/node_modules/micromark-util-combine-extensions/index.js
var hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(extensions) {
  const all2 = {};
  let index2 = -1;
  while (++index2 < extensions.length) {
    syntaxExtension(all2, extensions[index2]);
  }
  return all2;
}
function syntaxExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let code3;
    if (right) {
      for (code3 in right) {
        if (!hasOwnProperty.call(left, code3)) left[code3] = [];
        const value = right[code3];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code3],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}
function constructs(existing, list3) {
  let index2 = -1;
  const before = [];
  while (++index2 < list3.length) {
    ;
    (list3[index2].add === "after" ? existing : before).push(list3[index2]);
  }
  splice(existing, 0, 0, before);
}
function combineHtmlExtensions(htmlExtensions) {
  const handlers = {};
  let index2 = -1;
  while (++index2 < htmlExtensions.length) {
    htmlExtension(handlers, htmlExtensions[index2]);
  }
  return handlers;
}
function htmlExtension(all2, extension2) {
  let hook;
  for (hook in extension2) {
    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;
    const left = maybe || (all2[hook] = {});
    const right = extension2[hook];
    let type;
    if (right) {
      for (type in right) {
        left[type] = right[type];
      }
    }
  }
}

// ../../../node_modules/.pnpm/micromark-util-character@1.1.0/node_modules/micromark-util-character/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex = /[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

// ../../../node_modules/.pnpm/micromark-util-character@1.1.0/node_modules/micromark-util-character/index.js
var asciiAlpha = regexCheck(/[A-Za-z]/);
var asciiDigit = regexCheck(/\d/);
var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(code3) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code3 !== null && (code3 < 32 || code3 === 127)
  );
}
function markdownLineEndingOrSpace(code3) {
  return code3 !== null && (code3 < 0 || code3 === 32);
}
function markdownLineEnding(code3) {
  return code3 !== null && code3 < -2;
}
function markdownSpace(code3) {
  return code3 === -2 || code3 === -1 || code3 === 32;
}
var unicodeWhitespace = regexCheck(/\s/);
var unicodePunctuation = regexCheck(unicodePunctuationRegex);
function regexCheck(regex) {
  return check;
  function check(code3) {
    return code3 !== null && regex.test(String.fromCharCode(code3));
  }
}

// ../../../node_modules/.pnpm/micromark-factory-space@1.0.0/node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok3, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start3;
  function start3(code3) {
    if (markdownSpace(code3)) {
      effects.enter(type);
      return prefix(code3);
    }
    return ok3(code3);
  }
  function prefix(code3) {
    if (markdownSpace(code3) && size++ < limit) {
      effects.consume(code3);
      return prefix;
    }
    effects.exit(type);
    return ok3(code3);
  }
}

// ../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/content.js
var content = {
  tokenize: initializeContent
};
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  let previous3;
  return contentStart;
  function afterContentStartConstruct(code3) {
    if (code3 === null) {
      effects.consume(code3);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return factorySpace(effects, contentStart, "linePrefix");
  }
  function paragraphInitial(code3) {
    effects.enter("paragraph");
    return lineStart(code3);
  }
  function lineStart(code3) {
    const token = effects.enter("chunkText", {
      contentType: "text",
      previous: previous3
    });
    if (previous3) {
      previous3.next = token;
    }
    previous3 = token;
    return data2(code3);
  }
  function data2(code3) {
    if (code3 === null) {
      effects.exit("chunkText");
      effects.exit("paragraph");
      effects.consume(code3);
      return;
    }
    if (markdownLineEnding(code3)) {
      effects.consume(code3);
      effects.exit("chunkText");
      return lineStart;
    }
    effects.consume(code3);
    return data2;
  }
}

// ../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/document.js
var document2 = {
  tokenize: initializeDocument
};
var containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(effects) {
  const self2 = this;
  const stack = [];
  let continued = 0;
  let childFlow;
  let childToken;
  let lineStartOffset;
  return start3;
  function start3(code3) {
    if (continued < stack.length) {
      const item = stack[continued];
      self2.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code3);
    }
    return checkNewContainers(code3);
  }
  function documentContinue(code3) {
    continued++;
    if (self2.containerState._closeFlow) {
      self2.containerState._closeFlow = void 0;
      if (childFlow) {
        closeFlow();
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let point3;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          point3 = self2.events[indexBeforeFlow][1].end;
          break;
        }
      }
      exitContainers(continued);
      let index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point3);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
      return checkNewContainers(code3);
    }
    return start3(code3);
  }
  function checkNewContainers(code3) {
    if (continued === stack.length) {
      if (!childFlow) {
        return documentContinued(code3);
      }
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code3);
      }
      self2.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }
    self2.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code3);
  }
  function thereIsANewContainer(code3) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code3);
  }
  function thereIsNoNewContainer(code3) {
    self2.parser.lazy[self2.now().line] = continued !== stack.length;
    lineStartOffset = self2.now().offset;
    return flowStart(code3);
  }
  function documentContinued(code3) {
    self2.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code3);
  }
  function containerContinue(code3) {
    continued++;
    stack.push([self2.currentConstruct, self2.containerState]);
    return documentContinued(code3);
  }
  function flowStart(code3) {
    if (code3 === null) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code3);
      return;
    }
    childFlow = childFlow || self2.parser.flow(self2.now());
    effects.enter("chunkFlow", {
      contentType: "flow",
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code3);
  }
  function flowContinue(code3) {
    if (code3 === null) {
      writeToChild(effects.exit("chunkFlow"), true);
      exitContainers(0);
      effects.consume(code3);
      return;
    }
    if (markdownLineEnding(code3)) {
      effects.consume(code3);
      writeToChild(effects.exit("chunkFlow"));
      continued = 0;
      self2.interrupt = void 0;
      return start3;
    }
    effects.consume(code3);
    return flowContinue;
  }
  function writeToChild(token, eof) {
    const stream = self2.sliceStream(token);
    if (eof) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);
    if (self2.parser.lazy[token.start.line]) {
      let index2 = childFlow.events.length;
      while (index2--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index2][1].start.offset < lineStartOffset && // …and either is not ended yet…
          (!childFlow.events[index2][1].end || // …or ends after it.
          childFlow.events[index2][1].end.offset > lineStartOffset)
        ) {
          return;
        }
      }
      const indexBeforeExits = self2.events.length;
      let indexBeforeFlow = indexBeforeExits;
      let seen;
      let point3;
      while (indexBeforeFlow--) {
        if (self2.events[indexBeforeFlow][0] === "exit" && self2.events[indexBeforeFlow][1].type === "chunkFlow") {
          if (seen) {
            point3 = self2.events[indexBeforeFlow][1].end;
            break;
          }
          seen = true;
        }
      }
      exitContainers(continued);
      index2 = indexBeforeExits;
      while (index2 < self2.events.length) {
        self2.events[index2][1].end = Object.assign({}, point3);
        index2++;
      }
      splice(
        self2.events,
        indexBeforeFlow + 1,
        0,
        self2.events.slice(indexBeforeExits)
      );
      self2.events.length = index2;
    }
  }
  function exitContainers(size) {
    let index2 = stack.length;
    while (index2-- > size) {
      const entry = stack[index2];
      self2.containerState = entry[1];
      entry[0].exit.call(self2, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = void 0;
    childFlow = void 0;
    self2.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(effects, ok3, nok) {
  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok3, nok),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}

// ../../../node_modules/.pnpm/micromark-util-classify-character@1.1.0/node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code3) {
  if (code3 === null || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
    return 1;
  }
  if (unicodePunctuation(code3)) {
    return 2;
  }
}

// ../../../node_modules/.pnpm/micromark-util-resolve-all@1.1.0/node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
  const called = [];
  let index2 = -1;
  while (++index2 < constructs2.length) {
    const resolve = constructs2[index2].resolveAll;
    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }
  return events;
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/attention.js
var attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(events, context) {
  let index2 = -1;
  let open;
  let group;
  let text7;
  let openingSequence;
  let closingSequence;
  let use;
  let nextEvents;
  let offset2;
  while (++index2 < events.length) {
    if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
      open = index2;
      while (open--) {
        if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
          if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
            continue;
          }
          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
          const start3 = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index2][1].start);
          movePoint(start3, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: start3,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, events[index2][1].start),
            end
          };
          text7 = {
            type: use > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index2][1].start)
          };
          group = {
            type: use > 1 ? "strong" : "emphasis",
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index2][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ["enter", events[open][1], context],
              ["exit", events[open][1], context]
            ]);
          }
          nextEvents = push(nextEvents, [
            ["enter", group, context],
            ["enter", openingSequence, context],
            ["exit", openingSequence, context],
            ["enter", text7, context]
          ]);
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index2),
              context
            )
          );
          nextEvents = push(nextEvents, [
            ["exit", text7, context],
            ["enter", closingSequence, context],
            ["exit", closingSequence, context],
            ["exit", group, context]
          ]);
          if (events[index2][1].end.offset - events[index2][1].start.offset) {
            offset2 = 2;
            nextEvents = push(nextEvents, [
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context]
            ]);
          } else {
            offset2 = 0;
          }
          splice(events, open - 1, index2 - open + 3, nextEvents);
          index2 = open + nextEvents.length - offset2 - 2;
          break;
        }
      }
    }
  }
  index2 = -1;
  while (++index2 < events.length) {
    if (events[index2][1].type === "attentionSequence") {
      events[index2][1].type = "data";
    }
  }
  return events;
}
function tokenizeAttention(effects, ok3) {
  const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
  const previous3 = this.previous;
  const before = classifyCharacter(previous3);
  let marker;
  return start3;
  function start3(code3) {
    marker = code3;
    effects.enter("attentionSequence");
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      return inside;
    }
    const token = effects.exit("attentionSequence");
    const after = classifyCharacter(code3);
    const open = !after || after === 2 && before || attentionMarkers2.includes(code3);
    const close = !before || before === 2 && after || attentionMarkers2.includes(previous3);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok3(code3);
  }
}
function movePoint(point3, offset2) {
  point3.column += offset2;
  point3.offset += offset2;
  point3._bufferIndex += offset2;
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/autolink.js
var autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(effects, ok3, nok) {
  let size = 0;
  return start3;
  function start3(code3) {
    effects.enter("autolink");
    effects.enter("autolinkMarker");
    effects.consume(code3);
    effects.exit("autolinkMarker");
    effects.enter("autolinkProtocol");
    return open;
  }
  function open(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return schemeOrEmailAtext;
    }
    return emailAtext(code3);
  }
  function schemeOrEmailAtext(code3) {
    if (code3 === 43 || code3 === 45 || code3 === 46 || asciiAlphanumeric(code3)) {
      size = 1;
      return schemeInsideOrEmailAtext(code3);
    }
    return emailAtext(code3);
  }
  function schemeInsideOrEmailAtext(code3) {
    if (code3 === 58) {
      effects.consume(code3);
      size = 0;
      return urlInside;
    }
    if ((code3 === 43 || code3 === 45 || code3 === 46 || asciiAlphanumeric(code3)) && size++ < 32) {
      effects.consume(code3);
      return schemeInsideOrEmailAtext;
    }
    size = 0;
    return emailAtext(code3);
  }
  function urlInside(code3) {
    if (code3 === 62) {
      effects.exit("autolinkProtocol");
      effects.enter("autolinkMarker");
      effects.consume(code3);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok3;
    }
    if (code3 === null || code3 === 32 || code3 === 60 || asciiControl(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return urlInside;
  }
  function emailAtext(code3) {
    if (code3 === 64) {
      effects.consume(code3);
      return emailAtSignOrDot;
    }
    if (asciiAtext(code3)) {
      effects.consume(code3);
      return emailAtext;
    }
    return nok(code3);
  }
  function emailAtSignOrDot(code3) {
    return asciiAlphanumeric(code3) ? emailLabel(code3) : nok(code3);
  }
  function emailLabel(code3) {
    if (code3 === 46) {
      effects.consume(code3);
      size = 0;
      return emailAtSignOrDot;
    }
    if (code3 === 62) {
      effects.exit("autolinkProtocol").type = "autolinkEmail";
      effects.enter("autolinkMarker");
      effects.consume(code3);
      effects.exit("autolinkMarker");
      effects.exit("autolink");
      return ok3;
    }
    return emailValue(code3);
  }
  function emailValue(code3) {
    if ((code3 === 45 || asciiAlphanumeric(code3)) && size++ < 63) {
      const next = code3 === 45 ? emailValue : emailLabel;
      effects.consume(code3);
      return next;
    }
    return nok(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/blank-line.js
var blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};
function tokenizeBlankLine(effects, ok3, nok) {
  return start3;
  function start3(code3) {
    return markdownSpace(code3) ? factorySpace(effects, after, "linePrefix")(code3) : after(code3);
  }
  function after(code3) {
    return code3 === null || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/block-quote.js
var blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit
};
function tokenizeBlockQuoteStart(effects, ok3, nok) {
  const self2 = this;
  return start3;
  function start3(code3) {
    if (code3 === 62) {
      const state = self2.containerState;
      if (!state.open) {
        effects.enter("blockQuote", {
          _container: true
        });
        state.open = true;
      }
      effects.enter("blockQuotePrefix");
      effects.enter("blockQuoteMarker");
      effects.consume(code3);
      effects.exit("blockQuoteMarker");
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    if (markdownSpace(code3)) {
      effects.enter("blockQuotePrefixWhitespace");
      effects.consume(code3);
      effects.exit("blockQuotePrefixWhitespace");
      effects.exit("blockQuotePrefix");
      return ok3;
    }
    effects.exit("blockQuotePrefix");
    return ok3(code3);
  }
}
function tokenizeBlockQuoteContinuation(effects, ok3, nok) {
  const self2 = this;
  return contStart;
  function contStart(code3) {
    if (markdownSpace(code3)) {
      return factorySpace(
        effects,
        contBefore,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code3);
    }
    return contBefore(code3);
  }
  function contBefore(code3) {
    return effects.attempt(blockQuote, ok3, nok)(code3);
  }
}
function exit(effects) {
  effects.exit("blockQuote");
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/character-escape.js
var characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(effects, ok3, nok) {
  return start3;
  function start3(code3) {
    effects.enter("characterEscape");
    effects.enter("escapeMarker");
    effects.consume(code3);
    effects.exit("escapeMarker");
    return inside;
  }
  function inside(code3) {
    if (asciiPunctuation(code3)) {
      effects.enter("characterEscapeValue");
      effects.consume(code3);
      effects.exit("characterEscapeValue");
      effects.exit("characterEscape");
      return ok3;
    }
    return nok(code3);
  }
}

// ../../../node_modules/.pnpm/decode-named-character-reference@1.0.2/node_modules/decode-named-character-reference/index.dom.js
var element = document.createElement("i");
function decodeNamedCharacterReference(value) {
  const characterReference2 = "&" + value + ";";
  element.innerHTML = characterReference2;
  const char = element.textContent;
  if (char.charCodeAt(char.length - 1) === 59 && value !== "semi") {
    return false;
  }
  return char === characterReference2 ? false : char;
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/character-reference.js
var characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(effects, ok3, nok) {
  const self2 = this;
  let size = 0;
  let max;
  let test;
  return start3;
  function start3(code3) {
    effects.enter("characterReference");
    effects.enter("characterReferenceMarker");
    effects.consume(code3);
    effects.exit("characterReferenceMarker");
    return open;
  }
  function open(code3) {
    if (code3 === 35) {
      effects.enter("characterReferenceMarkerNumeric");
      effects.consume(code3);
      effects.exit("characterReferenceMarkerNumeric");
      return numeric;
    }
    effects.enter("characterReferenceValue");
    max = 31;
    test = asciiAlphanumeric;
    return value(code3);
  }
  function numeric(code3) {
    if (code3 === 88 || code3 === 120) {
      effects.enter("characterReferenceMarkerHexadecimal");
      effects.consume(code3);
      effects.exit("characterReferenceMarkerHexadecimal");
      effects.enter("characterReferenceValue");
      max = 6;
      test = asciiHexDigit;
      return value;
    }
    effects.enter("characterReferenceValue");
    max = 7;
    test = asciiDigit;
    return value(code3);
  }
  function value(code3) {
    if (code3 === 59 && size) {
      const token = effects.exit("characterReferenceValue");
      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self2.sliceSerialize(token))) {
        return nok(code3);
      }
      effects.enter("characterReferenceMarker");
      effects.consume(code3);
      effects.exit("characterReferenceMarker");
      effects.exit("characterReference");
      return ok3;
    }
    if (test(code3) && size++ < max) {
      effects.consume(code3);
      return value;
    }
    return nok(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/code-fenced.js
var nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};
var codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: true
};
function tokenizeCodeFenced(effects, ok3, nok) {
  const self2 = this;
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  let marker;
  return start3;
  function start3(code3) {
    return beforeSequenceOpen(code3);
  }
  function beforeSequenceOpen(code3) {
    const tail = self2.events[self2.events.length - 1];
    initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
    marker = code3;
    effects.enter("codeFenced");
    effects.enter("codeFencedFence");
    effects.enter("codeFencedFenceSequence");
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === marker) {
      sizeOpen++;
      effects.consume(code3);
      return sequenceOpen;
    }
    if (sizeOpen < 3) {
      return nok(code3);
    }
    effects.exit("codeFencedFenceSequence");
    return markdownSpace(code3) ? factorySpace(effects, infoBefore, "whitespace")(code3) : infoBefore(code3);
  }
  function infoBefore(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("codeFencedFence");
      return self2.interrupt ? ok3(code3) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code3);
    }
    effects.enter("codeFencedFenceInfo");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return info(code3);
  }
  function info(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return infoBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceInfo");
      return factorySpace(effects, metaBefore, "whitespace")(code3);
    }
    if (code3 === 96 && code3 === marker) {
      return nok(code3);
    }
    effects.consume(code3);
    return info;
  }
  function metaBefore(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      return infoBefore(code3);
    }
    effects.enter("codeFencedFenceMeta");
    effects.enter("chunkString", {
      contentType: "string"
    });
    return meta(code3);
  }
  function meta(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("chunkString");
      effects.exit("codeFencedFenceMeta");
      return infoBefore(code3);
    }
    if (code3 === 96 && code3 === marker) {
      return nok(code3);
    }
    effects.consume(code3);
    return meta;
  }
  function atNonLazyBreak(code3) {
    return effects.attempt(closeStart, after, contentBefore)(code3);
  }
  function contentBefore(code3) {
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return contentStart;
  }
  function contentStart(code3) {
    return initialPrefix > 0 && markdownSpace(code3) ? factorySpace(
      effects,
      beforeContentChunk,
      "linePrefix",
      initialPrefix + 1
    )(code3) : beforeContentChunk(code3);
  }
  function beforeContentChunk(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code3);
    }
    effects.enter("codeFlowValue");
    return contentChunk(code3);
  }
  function contentChunk(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("codeFlowValue");
      return beforeContentChunk(code3);
    }
    effects.consume(code3);
    return contentChunk;
  }
  function after(code3) {
    effects.exit("codeFenced");
    return ok3(code3);
  }
  function tokenizeCloseStart(effects2, ok4, nok2) {
    let size = 0;
    return startBefore;
    function startBefore(code3) {
      effects2.enter("lineEnding");
      effects2.consume(code3);
      effects2.exit("lineEnding");
      return start4;
    }
    function start4(code3) {
      effects2.enter("codeFencedFence");
      return markdownSpace(code3) ? factorySpace(
        effects2,
        beforeSequenceClose,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code3) : beforeSequenceClose(code3);
    }
    function beforeSequenceClose(code3) {
      if (code3 === marker) {
        effects2.enter("codeFencedFenceSequence");
        return sequenceClose(code3);
      }
      return nok2(code3);
    }
    function sequenceClose(code3) {
      if (code3 === marker) {
        size++;
        effects2.consume(code3);
        return sequenceClose;
      }
      if (size >= sizeOpen) {
        effects2.exit("codeFencedFenceSequence");
        return markdownSpace(code3) ? factorySpace(effects2, sequenceCloseAfter, "whitespace")(code3) : sequenceCloseAfter(code3);
      }
      return nok2(code3);
    }
    function sequenceCloseAfter(code3) {
      if (code3 === null || markdownLineEnding(code3)) {
        effects2.exit("codeFencedFence");
        return ok4(code3);
      }
      return nok2(code3);
    }
  }
}
function tokenizeNonLazyContinuation(effects, ok3, nok) {
  const self2 = this;
  return start3;
  function start3(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return lineStart;
  }
  function lineStart(code3) {
    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/code-indented.js
var codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
};
var furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};
function tokenizeCodeIndented(effects, ok3, nok) {
  const self2 = this;
  return start3;
  function start3(code3) {
    effects.enter("codeIndented");
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code3);
  }
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? atBreak(code3) : nok(code3);
  }
  function atBreak(code3) {
    if (code3 === null) {
      return after(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.attempt(furtherStart, atBreak, after)(code3);
    }
    effects.enter("codeFlowValue");
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("codeFlowValue");
      return atBreak(code3);
    }
    effects.consume(code3);
    return inside;
  }
  function after(code3) {
    effects.exit("codeIndented");
    return ok3(code3);
  }
}
function tokenizeFurtherStart(effects, ok3, nok) {
  const self2 = this;
  return furtherStart2;
  function furtherStart2(code3) {
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return furtherStart2;
    }
    return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1)(code3);
  }
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4 ? ok3(code3) : markdownLineEnding(code3) ? furtherStart2(code3) : nok(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/code-text.js
var codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous
};
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  let index2;
  let enter;
  if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
    index2 = headEnterIndex;
    while (++index2 < tailExitIndex) {
      if (events[index2][1].type === "codeTextData") {
        events[headEnterIndex][1].type = "codeTextPadding";
        events[tailExitIndex][1].type = "codeTextPadding";
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break;
      }
    }
  }
  index2 = headEnterIndex - 1;
  tailExitIndex++;
  while (++index2 <= tailExitIndex) {
    if (enter === void 0) {
      if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
        enter = index2;
      }
    } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
      events[enter][1].type = "codeTextData";
      if (index2 !== enter + 2) {
        events[enter][1].end = events[index2 - 1][1].end;
        events.splice(enter + 2, index2 - enter - 2);
        tailExitIndex -= index2 - enter - 2;
        index2 = enter + 2;
      }
      enter = void 0;
    }
  }
  return events;
}
function previous(code3) {
  return code3 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(effects, ok3, nok) {
  const self2 = this;
  let sizeOpen = 0;
  let size;
  let token;
  return start3;
  function start3(code3) {
    effects.enter("codeText");
    effects.enter("codeTextSequence");
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === 96) {
      effects.consume(code3);
      sizeOpen++;
      return sequenceOpen;
    }
    effects.exit("codeTextSequence");
    return between2(code3);
  }
  function between2(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    if (code3 === 32) {
      effects.enter("space");
      effects.consume(code3);
      effects.exit("space");
      return between2;
    }
    if (code3 === 96) {
      token = effects.enter("codeTextSequence");
      size = 0;
      return sequenceClose(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return between2;
    }
    effects.enter("codeTextData");
    return data2(code3);
  }
  function data2(code3) {
    if (code3 === null || code3 === 32 || code3 === 96 || markdownLineEnding(code3)) {
      effects.exit("codeTextData");
      return between2(code3);
    }
    effects.consume(code3);
    return data2;
  }
  function sequenceClose(code3) {
    if (code3 === 96) {
      effects.consume(code3);
      size++;
      return sequenceClose;
    }
    if (size === sizeOpen) {
      effects.exit("codeTextSequence");
      effects.exit("codeText");
      return ok3(code3);
    }
    token.type = "codeTextData";
    return data2(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-util-subtokenize@1.1.0/node_modules/micromark-util-subtokenize/index.js
function subtokenize(events) {
  const jumps = {};
  let index2 = -1;
  let event;
  let lineIndex;
  let otherIndex;
  let otherEvent;
  let parameters;
  let subevents;
  let more;
  while (++index2 < events.length) {
    while (index2 in jumps) {
      index2 = jumps[index2];
    }
    event = events[index2];
    if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
        otherIndex += 2;
      }
      if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === "content") {
            break;
          }
          if (subevents[otherIndex][1].type === "chunkText") {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }
    if (event[0] === "enter") {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index2));
        index2 = jumps[index2];
        more = true;
      }
    } else if (event[1]._container) {
      otherIndex = index2;
      lineIndex = void 0;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
          if (otherEvent[0] === "enter") {
            if (lineIndex) {
              events[lineIndex][1].type = "lineEndingBlank";
            }
            otherEvent[1].type = "lineEnding";
            lineIndex = otherIndex;
          }
        } else {
          break;
        }
      }
      if (lineIndex) {
        event[1].end = Object.assign({}, events[lineIndex][1].start);
        parameters = events.slice(lineIndex, index2);
        parameters.unshift(event);
        splice(events, lineIndex, index2 - lineIndex + 1, parameters);
      }
    }
  }
  return !more;
}
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  const startPositions = [];
  const tokenizer3 = token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer3.events;
  const jumps = [];
  const gaps = {};
  let stream;
  let previous3;
  let index2 = -1;
  let current2 = token;
  let adjust = 0;
  let start3 = 0;
  const breaks = [start3];
  while (current2) {
    while (events[++startPosition][1] !== current2) {
    }
    startPositions.push(startPosition);
    if (!current2._tokenizer) {
      stream = context.sliceStream(current2);
      if (!current2.next) {
        stream.push(null);
      }
      if (previous3) {
        tokenizer3.defineSkip(current2.start);
      }
      if (current2._isInFirstContentOfListItem) {
        tokenizer3._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer3.write(stream);
      if (current2._isInFirstContentOfListItem) {
        tokenizer3._gfmTasklistFirstContentOfListItem = void 0;
      }
    }
    previous3 = current2;
    current2 = current2.next;
  }
  current2 = token;
  while (++index2 < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index2][0] === "exit" && childEvents[index2 - 1][0] === "enter" && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
    ) {
      start3 = index2 + 1;
      breaks.push(start3);
      current2._tokenizer = void 0;
      current2.previous = void 0;
      current2 = current2.next;
    }
  }
  tokenizer3.events = [];
  if (current2) {
    current2._tokenizer = void 0;
    current2.previous = void 0;
  } else {
    breaks.pop();
  }
  index2 = breaks.length;
  while (index2--) {
    const slice = childEvents.slice(breaks[index2], breaks[index2 + 1]);
    const start4 = startPositions.pop();
    jumps.unshift([start4, start4 + slice.length - 1]);
    splice(events, start4, 2, slice);
  }
  index2 = -1;
  while (++index2 < jumps.length) {
    gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
    adjust += jumps[index2][1] - jumps[index2][0] - 1;
  }
  return gaps;
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/content.js
var content2 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};
var continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};
function resolveContent(events) {
  subtokenize(events);
  return events;
}
function tokenizeContent(effects, ok3) {
  let previous3;
  return chunkStart;
  function chunkStart(code3) {
    effects.enter("content");
    previous3 = effects.enter("chunkContent", {
      contentType: "content"
    });
    return chunkInside(code3);
  }
  function chunkInside(code3) {
    if (code3 === null) {
      return contentEnd(code3);
    }
    if (markdownLineEnding(code3)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code3);
    }
    effects.consume(code3);
    return chunkInside;
  }
  function contentEnd(code3) {
    effects.exit("chunkContent");
    effects.exit("content");
    return ok3(code3);
  }
  function contentContinue(code3) {
    effects.consume(code3);
    effects.exit("chunkContent");
    previous3.next = effects.enter("chunkContent", {
      contentType: "content",
      previous: previous3
    });
    previous3 = previous3.next;
    return chunkInside;
  }
}
function tokenizeContinuation(effects, ok3, nok) {
  const self2 = this;
  return startLookahead;
  function startLookahead(code3) {
    effects.exit("chunkContent");
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return factorySpace(effects, prefixed, "linePrefix");
  }
  function prefixed(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      return nok(code3);
    }
    const tail = self2.events[self2.events.length - 1];
    if (!self2.parser.constructs.disable.null.includes("codeIndented") && tail && tail[1].type === "linePrefix" && tail[2].sliceSerialize(tail[1], true).length >= 4) {
      return ok3(code3);
    }
    return effects.interrupt(self2.parser.constructs.flow, nok, ok3)(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-factory-destination@1.1.0/node_modules/micromark-factory-destination/index.js
function factoryDestination(effects, ok3, nok, type, literalType, literalMarkerType, rawType, stringType, max) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start3;
  function start3(code3) {
    if (code3 === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code3);
      effects.exit(literalMarkerType);
      return enclosedBefore;
    }
    if (code3 === null || code3 === 32 || code3 === 41 || asciiControl(code3)) {
      return nok(code3);
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return raw(code3);
  }
  function enclosedBefore(code3) {
    if (code3 === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code3);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    effects.enter("chunkString", {
      contentType: "string"
    });
    return enclosed(code3);
  }
  function enclosed(code3) {
    if (code3 === 62) {
      effects.exit("chunkString");
      effects.exit(stringType);
      return enclosedBefore(code3);
    }
    if (code3 === null || code3 === 60 || markdownLineEnding(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return code3 === 92 ? enclosedEscape : enclosed;
  }
  function enclosedEscape(code3) {
    if (code3 === 60 || code3 === 62 || code3 === 92) {
      effects.consume(code3);
      return enclosed;
    }
    return enclosed(code3);
  }
  function raw(code3) {
    if (!balance && (code3 === null || code3 === 41 || markdownLineEndingOrSpace(code3))) {
      effects.exit("chunkString");
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok3(code3);
    }
    if (balance < limit && code3 === 40) {
      effects.consume(code3);
      balance++;
      return raw;
    }
    if (code3 === 41) {
      effects.consume(code3);
      balance--;
      return raw;
    }
    if (code3 === null || code3 === 32 || code3 === 40 || asciiControl(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return code3 === 92 ? rawEscape : raw;
  }
  function rawEscape(code3) {
    if (code3 === 40 || code3 === 41 || code3 === 92) {
      effects.consume(code3);
      return raw;
    }
    return raw(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-factory-label@1.1.0/node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok3, nok, type, markerType, stringType) {
  const self2 = this;
  let size = 0;
  let seen;
  return start3;
  function start3(code3) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak;
  }
  function atBreak(code3) {
    if (size > 999 || code3 === null || code3 === 91 || code3 === 93 && !seen || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    code3 === 94 && !size && "_hiddenFootnoteSupport" in self2.parser.constructs) {
      return nok(code3);
    }
    if (code3 === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return atBreak;
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return labelInside(code3);
  }
  function labelInside(code3) {
    if (code3 === null || code3 === 91 || code3 === 93 || markdownLineEnding(code3) || size++ > 999) {
      effects.exit("chunkString");
      return atBreak(code3);
    }
    effects.consume(code3);
    if (!seen) seen = !markdownSpace(code3);
    return code3 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code3) {
    if (code3 === 91 || code3 === 92 || code3 === 93) {
      effects.consume(code3);
      size++;
      return labelInside;
    }
    return labelInside(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-factory-title@1.1.0/node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok3, nok, type, markerType, stringType) {
  let marker;
  return start3;
  function start3(code3) {
    if (code3 === 34 || code3 === 39 || code3 === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      marker = code3 === 40 ? 41 : code3;
      return begin;
    }
    return nok(code3);
  }
  function begin(code3) {
    if (code3 === marker) {
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    effects.enter(stringType);
    return atBreak(code3);
  }
  function atBreak(code3) {
    if (code3 === marker) {
      effects.exit(stringType);
      return begin(marker);
    }
    if (code3 === null) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return factorySpace(effects, atBreak, "linePrefix");
    }
    effects.enter("chunkString", {
      contentType: "string"
    });
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker || code3 === null || markdownLineEnding(code3)) {
      effects.exit("chunkString");
      return atBreak(code3);
    }
    effects.consume(code3);
    return code3 === 92 ? escape : inside;
  }
  function escape(code3) {
    if (code3 === marker || code3 === 92) {
      effects.consume(code3);
      return inside;
    }
    return inside(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-factory-whitespace@1.0.0/node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok3) {
  let seen;
  return start3;
  function start3(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      seen = true;
      return start3;
    }
    if (markdownSpace(code3)) {
      return factorySpace(
        effects,
        start3,
        seen ? "linePrefix" : "lineSuffix"
      )(code3);
    }
    return ok3(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-util-normalize-identifier@1.1.0/node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value) {
  return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/definition.js
var definition = {
  name: "definition",
  tokenize: tokenizeDefinition
};
var titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};
function tokenizeDefinition(effects, ok3, nok) {
  const self2 = this;
  let identifier;
  return start3;
  function start3(code3) {
    effects.enter("definition");
    return before(code3);
  }
  function before(code3) {
    return factoryLabel.call(
      self2,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(code3);
  }
  function labelAfter(code3) {
    identifier = normalizeIdentifier(
      self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
    );
    if (code3 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code3);
      effects.exit("definitionMarker");
      return markerAfter;
    }
    return nok(code3);
  }
  function markerAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, destinationBefore)(code3) : destinationBefore(code3);
  }
  function destinationBefore(code3) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(code3);
  }
  function destinationAfter(code3) {
    return effects.attempt(titleBefore, after, after)(code3);
  }
  function after(code3) {
    return markdownSpace(code3) ? factorySpace(effects, afterWhitespace, "whitespace")(code3) : afterWhitespace(code3);
  }
  function afterWhitespace(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("definition");
      self2.parser.defined.push(identifier);
      return ok3(code3);
    }
    return nok(code3);
  }
}
function tokenizeTitleBefore(effects, ok3, nok) {
  return titleBefore2;
  function titleBefore2(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, beforeMarker)(code3) : nok(code3);
  }
  function beforeMarker(code3) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(code3);
  }
  function titleAfter(code3) {
    return markdownSpace(code3) ? factorySpace(effects, titleAfterOptionalWhitespace, "whitespace")(code3) : titleAfterOptionalWhitespace(code3);
  }
  function titleAfterOptionalWhitespace(code3) {
    return code3 === null || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/hard-break-escape.js
var hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(effects, ok3, nok) {
  return start3;
  function start3(code3) {
    effects.enter("hardBreakEscape");
    effects.consume(code3);
    return after;
  }
  function after(code3) {
    if (markdownLineEnding(code3)) {
      effects.exit("hardBreakEscape");
      return ok3(code3);
    }
    return nok(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/heading-atx.js
var headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  let content3;
  let text7;
  if (events[contentStart][1].type === "whitespace") {
    contentStart += 2;
  }
  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
    contentEnd -= 2;
  }
  if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content3 = {
      type: "atxHeadingText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text7 = {
      type: "chunkText",
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: "text"
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ["enter", content3, context],
      ["enter", text7, context],
      ["exit", text7, context],
      ["exit", content3, context]
    ]);
  }
  return events;
}
function tokenizeHeadingAtx(effects, ok3, nok) {
  let size = 0;
  return start3;
  function start3(code3) {
    effects.enter("atxHeading");
    return before(code3);
  }
  function before(code3) {
    effects.enter("atxHeadingSequence");
    return sequenceOpen(code3);
  }
  function sequenceOpen(code3) {
    if (code3 === 35 && size++ < 6) {
      effects.consume(code3);
      return sequenceOpen;
    }
    if (code3 === null || markdownLineEndingOrSpace(code3)) {
      effects.exit("atxHeadingSequence");
      return atBreak(code3);
    }
    return nok(code3);
  }
  function atBreak(code3) {
    if (code3 === 35) {
      effects.enter("atxHeadingSequence");
      return sequenceFurther(code3);
    }
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("atxHeading");
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, atBreak, "whitespace")(code3);
    }
    effects.enter("atxHeadingText");
    return data2(code3);
  }
  function sequenceFurther(code3) {
    if (code3 === 35) {
      effects.consume(code3);
      return sequenceFurther;
    }
    effects.exit("atxHeadingSequence");
    return atBreak(code3);
  }
  function data2(code3) {
    if (code3 === null || code3 === 35 || markdownLineEndingOrSpace(code3)) {
      effects.exit("atxHeadingText");
      return atBreak(code3);
    }
    effects.consume(code3);
    return data2;
  }
}

// ../../../node_modules/.pnpm/micromark-util-html-tag-name@1.2.0/node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var htmlRawNames = ["pre", "script", "style", "textarea"];

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/html-flow.js
var htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};
var blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
var nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};
function resolveToHtmlFlow(events) {
  let index2 = events.length;
  while (index2--) {
    if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
      break;
    }
  }
  if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
    events[index2][1].start = events[index2 - 2][1].start;
    events[index2 + 1][1].start = events[index2 - 2][1].start;
    events.splice(index2 - 2, 2);
  }
  return events;
}
function tokenizeHtmlFlow(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let closingTag;
  let buffer2;
  let index2;
  let markerB;
  return start3;
  function start3(code3) {
    return before(code3);
  }
  function before(code3) {
    effects.enter("htmlFlow");
    effects.enter("htmlFlowData");
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === 33) {
      effects.consume(code3);
      return declarationOpen;
    }
    if (code3 === 47) {
      effects.consume(code3);
      closingTag = true;
      return tagCloseStart;
    }
    if (code3 === 63) {
      effects.consume(code3);
      marker = 3;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      buffer2 = String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      marker = 2;
      return commentOpenInside;
    }
    if (code3 === 91) {
      effects.consume(code3);
      marker = 5;
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      marker = 4;
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code3);
  }
  function commentOpenInside(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return self2.interrupt ? ok3 : continuationDeclarationInside;
    }
    return nok(code3);
  }
  function cdataOpenInside(code3) {
    const value = "CDATA[";
    if (code3 === value.charCodeAt(index2++)) {
      effects.consume(code3);
      if (index2 === value.length) {
        return self2.interrupt ? ok3 : continuation;
      }
      return cdataOpenInside;
    }
    return nok(code3);
  }
  function tagCloseStart(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      buffer2 = String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function tagName(code3) {
    if (code3 === null || code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
      const slash = code3 === 47;
      const name2 = buffer2.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name2)) {
        marker = 1;
        return self2.interrupt ? ok3(code3) : continuation(code3);
      }
      if (htmlBlockNames.includes(buffer2.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code3);
          return basicSelfClosing;
        }
        return self2.interrupt ? ok3(code3) : continuation(code3);
      }
      marker = 7;
      return self2.interrupt && !self2.parser.lazy[self2.now().line] ? nok(code3) : closingTag ? completeClosingTagAfter(code3) : completeAttributeNameBefore(code3);
    }
    if (code3 === 45 || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      buffer2 += String.fromCharCode(code3);
      return tagName;
    }
    return nok(code3);
  }
  function basicSelfClosing(code3) {
    if (code3 === 62) {
      effects.consume(code3);
      return self2.interrupt ? ok3 : continuation;
    }
    return nok(code3);
  }
  function completeClosingTagAfter(code3) {
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeClosingTagAfter;
    }
    return completeEnd(code3);
  }
  function completeAttributeNameBefore(code3) {
    if (code3 === 47) {
      effects.consume(code3);
      return completeEnd;
    }
    if (code3 === 58 || code3 === 95 || asciiAlpha(code3)) {
      effects.consume(code3);
      return completeAttributeName;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeNameBefore;
    }
    return completeEnd(code3);
  }
  function completeAttributeName(code3) {
    if (code3 === 45 || code3 === 46 || code3 === 58 || code3 === 95 || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return completeAttributeName;
    }
    return completeAttributeNameAfter(code3);
  }
  function completeAttributeNameAfter(code3) {
    if (code3 === 61) {
      effects.consume(code3);
      return completeAttributeValueBefore;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeNameAfter;
    }
    return completeAttributeNameBefore(code3);
  }
  function completeAttributeValueBefore(code3) {
    if (code3 === null || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96) {
      return nok(code3);
    }
    if (code3 === 34 || code3 === 39) {
      effects.consume(code3);
      markerB = code3;
      return completeAttributeValueQuoted;
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAttributeValueBefore;
    }
    return completeAttributeValueUnquoted(code3);
  }
  function completeAttributeValueQuoted(code3) {
    if (code3 === markerB) {
      effects.consume(code3);
      markerB = null;
      return completeAttributeValueQuotedAfter;
    }
    if (code3 === null || markdownLineEnding(code3)) {
      return nok(code3);
    }
    effects.consume(code3);
    return completeAttributeValueQuoted;
  }
  function completeAttributeValueUnquoted(code3) {
    if (code3 === null || code3 === 34 || code3 === 39 || code3 === 47 || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96 || markdownLineEndingOrSpace(code3)) {
      return completeAttributeNameAfter(code3);
    }
    effects.consume(code3);
    return completeAttributeValueUnquoted;
  }
  function completeAttributeValueQuotedAfter(code3) {
    if (code3 === 47 || code3 === 62 || markdownSpace(code3)) {
      return completeAttributeNameBefore(code3);
    }
    return nok(code3);
  }
  function completeEnd(code3) {
    if (code3 === 62) {
      effects.consume(code3);
      return completeAfter;
    }
    return nok(code3);
  }
  function completeAfter(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      return continuation(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return completeAfter;
    }
    return nok(code3);
  }
  function continuation(code3) {
    if (code3 === 45 && marker === 2) {
      effects.consume(code3);
      return continuationCommentInside;
    }
    if (code3 === 60 && marker === 1) {
      effects.consume(code3);
      return continuationRawTagOpen;
    }
    if (code3 === 62 && marker === 4) {
      effects.consume(code3);
      return continuationClose;
    }
    if (code3 === 63 && marker === 3) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    if (code3 === 93 && marker === 5) {
      effects.consume(code3);
      return continuationCdataInside;
    }
    if (markdownLineEnding(code3) && (marker === 6 || marker === 7)) {
      effects.exit("htmlFlowData");
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code3);
    }
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("htmlFlowData");
      return continuationStart(code3);
    }
    effects.consume(code3);
    return continuation;
  }
  function continuationStart(code3) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code3);
  }
  function continuationStartNonLazy(code3) {
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return continuationBefore;
  }
  function continuationBefore(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      return continuationStart(code3);
    }
    effects.enter("htmlFlowData");
    return continuation(code3);
  }
  function continuationCommentInside(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationRawTagOpen(code3) {
    if (code3 === 47) {
      effects.consume(code3);
      buffer2 = "";
      return continuationRawEndTag;
    }
    return continuation(code3);
  }
  function continuationRawEndTag(code3) {
    if (code3 === 62) {
      const name2 = buffer2.toLowerCase();
      if (htmlRawNames.includes(name2)) {
        effects.consume(code3);
        return continuationClose;
      }
      return continuation(code3);
    }
    if (asciiAlpha(code3) && buffer2.length < 8) {
      effects.consume(code3);
      buffer2 += String.fromCharCode(code3);
      return continuationRawEndTag;
    }
    return continuation(code3);
  }
  function continuationCdataInside(code3) {
    if (code3 === 93) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationDeclarationInside(code3) {
    if (code3 === 62) {
      effects.consume(code3);
      return continuationClose;
    }
    if (code3 === 45 && marker === 2) {
      effects.consume(code3);
      return continuationDeclarationInside;
    }
    return continuation(code3);
  }
  function continuationClose(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("htmlFlowData");
      return continuationAfter(code3);
    }
    effects.consume(code3);
    return continuationClose;
  }
  function continuationAfter(code3) {
    effects.exit("htmlFlow");
    return ok3(code3);
  }
}
function tokenizeNonLazyContinuationStart(effects, ok3, nok) {
  const self2 = this;
  return start3;
  function start3(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
  }
}
function tokenizeBlankLineBefore(effects, ok3, nok) {
  return start3;
  function start3(code3) {
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return effects.attempt(blankLine, ok3, nok);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/html-text.js
var htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(effects, ok3, nok) {
  const self2 = this;
  let marker;
  let index2;
  let returnState;
  return start3;
  function start3(code3) {
    effects.enter("htmlText");
    effects.enter("htmlTextData");
    effects.consume(code3);
    return open;
  }
  function open(code3) {
    if (code3 === 33) {
      effects.consume(code3);
      return declarationOpen;
    }
    if (code3 === 47) {
      effects.consume(code3);
      return tagCloseStart;
    }
    if (code3 === 63) {
      effects.consume(code3);
      return instruction;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return tagOpen;
    }
    return nok(code3);
  }
  function declarationOpen(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return commentOpenInside;
    }
    if (code3 === 91) {
      effects.consume(code3);
      index2 = 0;
      return cdataOpenInside;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return declaration;
    }
    return nok(code3);
  }
  function commentOpenInside(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return commentEnd;
    }
    return nok(code3);
  }
  function comment(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    if (code3 === 45) {
      effects.consume(code3);
      return commentClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = comment;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return comment;
  }
  function commentClose(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return commentEnd;
    }
    return comment(code3);
  }
  function commentEnd(code3) {
    return code3 === 62 ? end(code3) : code3 === 45 ? commentClose(code3) : comment(code3);
  }
  function cdataOpenInside(code3) {
    const value = "CDATA[";
    if (code3 === value.charCodeAt(index2++)) {
      effects.consume(code3);
      return index2 === value.length ? cdata : cdataOpenInside;
    }
    return nok(code3);
  }
  function cdata(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    if (code3 === 93) {
      effects.consume(code3);
      return cdataClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = cdata;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return cdata;
  }
  function cdataClose(code3) {
    if (code3 === 93) {
      effects.consume(code3);
      return cdataEnd;
    }
    return cdata(code3);
  }
  function cdataEnd(code3) {
    if (code3 === 62) {
      return end(code3);
    }
    if (code3 === 93) {
      effects.consume(code3);
      return cdataEnd;
    }
    return cdata(code3);
  }
  function declaration(code3) {
    if (code3 === null || code3 === 62) {
      return end(code3);
    }
    if (markdownLineEnding(code3)) {
      returnState = declaration;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return declaration;
  }
  function instruction(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    if (code3 === 63) {
      effects.consume(code3);
      return instructionClose;
    }
    if (markdownLineEnding(code3)) {
      returnState = instruction;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return instruction;
  }
  function instructionClose(code3) {
    return code3 === 62 ? end(code3) : instruction(code3);
  }
  function tagCloseStart(code3) {
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return tagClose;
    }
    return nok(code3);
  }
  function tagClose(code3) {
    if (code3 === 45 || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagClose;
    }
    return tagCloseBetween(code3);
  }
  function tagCloseBetween(code3) {
    if (markdownLineEnding(code3)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagCloseBetween;
    }
    return end(code3);
  }
  function tagOpen(code3) {
    if (code3 === 45 || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagOpen;
    }
    if (code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    return nok(code3);
  }
  function tagOpenBetween(code3) {
    if (code3 === 47) {
      effects.consume(code3);
      return end;
    }
    if (code3 === 58 || code3 === 95 || asciiAlpha(code3)) {
      effects.consume(code3);
      return tagOpenAttributeName;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenBetween;
    }
    return end(code3);
  }
  function tagOpenAttributeName(code3) {
    if (code3 === 45 || code3 === 46 || code3 === 58 || code3 === 95 || asciiAlphanumeric(code3)) {
      effects.consume(code3);
      return tagOpenAttributeName;
    }
    return tagOpenAttributeNameAfter(code3);
  }
  function tagOpenAttributeNameAfter(code3) {
    if (code3 === 61) {
      effects.consume(code3);
      return tagOpenAttributeValueBefore;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenAttributeNameAfter;
    }
    return tagOpenBetween(code3);
  }
  function tagOpenAttributeValueBefore(code3) {
    if (code3 === null || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96) {
      return nok(code3);
    }
    if (code3 === 34 || code3 === 39) {
      effects.consume(code3);
      marker = code3;
      return tagOpenAttributeValueQuoted;
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code3);
    }
    if (markdownSpace(code3)) {
      effects.consume(code3);
      return tagOpenAttributeValueBefore;
    }
    effects.consume(code3);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuoted(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      marker = void 0;
      return tagOpenAttributeValueQuotedAfter;
    }
    if (code3 === null) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code3);
    }
    effects.consume(code3);
    return tagOpenAttributeValueQuoted;
  }
  function tagOpenAttributeValueUnquoted(code3) {
    if (code3 === null || code3 === 34 || code3 === 39 || code3 === 60 || code3 === 61 || code3 === 96) {
      return nok(code3);
    }
    if (code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    effects.consume(code3);
    return tagOpenAttributeValueUnquoted;
  }
  function tagOpenAttributeValueQuotedAfter(code3) {
    if (code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
      return tagOpenBetween(code3);
    }
    return nok(code3);
  }
  function end(code3) {
    if (code3 === 62) {
      effects.consume(code3);
      effects.exit("htmlTextData");
      effects.exit("htmlText");
      return ok3;
    }
    return nok(code3);
  }
  function lineEndingBefore(code3) {
    effects.exit("htmlTextData");
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return lineEndingAfter;
  }
  function lineEndingAfter(code3) {
    return markdownSpace(code3) ? factorySpace(
      effects,
      lineEndingAfterPrefix,
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code3) : lineEndingAfterPrefix(code3);
  }
  function lineEndingAfterPrefix(code3) {
    effects.enter("htmlTextData");
    return returnState(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/label-end.js
var labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};
var resourceConstruct = {
  tokenize: tokenizeResource
};
var referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
var referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(events) {
  let index2 = -1;
  while (++index2 < events.length) {
    const token = events[index2][1];
    if (token.type === "labelImage" || token.type === "labelLink" || token.type === "labelEnd") {
      events.splice(index2 + 1, token.type === "labelImage" ? 4 : 2);
      token.type = "data";
      index2++;
    }
  }
  return events;
}
function resolveToLabelEnd(events, context) {
  let index2 = events.length;
  let offset2 = 0;
  let token;
  let open;
  let close;
  let media;
  while (index2--) {
    token = events[index2][1];
    if (open) {
      if (token.type === "link" || token.type === "labelLink" && token._inactive) {
        break;
      }
      if (events[index2][0] === "enter" && token.type === "labelLink") {
        token._inactive = true;
      }
    } else if (close) {
      if (events[index2][0] === "enter" && (token.type === "labelImage" || token.type === "labelLink") && !token._balanced) {
        open = index2;
        if (token.type !== "labelLink") {
          offset2 = 2;
          break;
        }
      }
    } else if (token.type === "labelEnd") {
      close = index2;
    }
  }
  const group = {
    type: events[open][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: "label",
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text7 = {
    type: "labelText",
    start: Object.assign({}, events[open + offset2 + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ["enter", group, context],
    ["enter", label, context]
  ];
  media = push(media, events.slice(open + 1, open + offset2 + 3));
  media = push(media, [["enter", text7, context]]);
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset2 + 4, close - 3),
      context
    )
  );
  media = push(media, [
    ["exit", text7, context],
    events[close - 2],
    events[close - 1],
    ["exit", label, context]
  ]);
  media = push(media, events.slice(close + 1));
  media = push(media, [["exit", group, context]]);
  splice(events, open, events.length, media);
  return events;
}
function tokenizeLabelEnd(effects, ok3, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  let labelStart;
  let defined;
  while (index2--) {
    if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
      labelStart = self2.events[index2][1];
      break;
    }
  }
  return start3;
  function start3(code3) {
    if (!labelStart) {
      return nok(code3);
    }
    if (labelStart._inactive) {
      return labelEndNok(code3);
    }
    defined = self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize({
          start: labelStart.end,
          end: self2.now()
        })
      )
    );
    effects.enter("labelEnd");
    effects.enter("labelMarker");
    effects.consume(code3);
    effects.exit("labelMarker");
    effects.exit("labelEnd");
    return after;
  }
  function after(code3) {
    if (code3 === 40) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code3);
    }
    if (code3 === 91) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code3);
    }
    return defined ? labelEndOk(code3) : labelEndNok(code3);
  }
  function referenceNotFull(code3) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code3);
  }
  function labelEndOk(code3) {
    return ok3(code3);
  }
  function labelEndNok(code3) {
    labelStart._balanced = true;
    return nok(code3);
  }
}
function tokenizeResource(effects, ok3, nok) {
  return resourceStart;
  function resourceStart(code3) {
    effects.enter("resource");
    effects.enter("resourceMarker");
    effects.consume(code3);
    effects.exit("resourceMarker");
    return resourceBefore;
  }
  function resourceBefore(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceOpen)(code3) : resourceOpen(code3);
  }
  function resourceOpen(code3) {
    if (code3 === 41) {
      return resourceEnd(code3);
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(code3);
  }
  function resourceDestinationAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceBetween)(code3) : resourceEnd(code3);
  }
  function resourceDestinationMissing(code3) {
    return nok(code3);
  }
  function resourceBetween(code3) {
    if (code3 === 34 || code3 === 39 || code3 === 40) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        "resourceTitle",
        "resourceTitleMarker",
        "resourceTitleString"
      )(code3);
    }
    return resourceEnd(code3);
  }
  function resourceTitleAfter(code3) {
    return markdownLineEndingOrSpace(code3) ? factoryWhitespace(effects, resourceEnd)(code3) : resourceEnd(code3);
  }
  function resourceEnd(code3) {
    if (code3 === 41) {
      effects.enter("resourceMarker");
      effects.consume(code3);
      effects.exit("resourceMarker");
      effects.exit("resource");
      return ok3;
    }
    return nok(code3);
  }
}
function tokenizeReferenceFull(effects, ok3, nok) {
  const self2 = this;
  return referenceFull;
  function referenceFull(code3) {
    return factoryLabel.call(
      self2,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      "reference",
      "referenceMarker",
      "referenceString"
    )(code3);
  }
  function referenceFullAfter(code3) {
    return self2.parser.defined.includes(
      normalizeIdentifier(
        self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
      )
    ) ? ok3(code3) : nok(code3);
  }
  function referenceFullMissing(code3) {
    return nok(code3);
  }
}
function tokenizeReferenceCollapsed(effects, ok3, nok) {
  return referenceCollapsedStart;
  function referenceCollapsedStart(code3) {
    effects.enter("reference");
    effects.enter("referenceMarker");
    effects.consume(code3);
    effects.exit("referenceMarker");
    return referenceCollapsedOpen;
  }
  function referenceCollapsedOpen(code3) {
    if (code3 === 93) {
      effects.enter("referenceMarker");
      effects.consume(code3);
      effects.exit("referenceMarker");
      effects.exit("reference");
      return ok3;
    }
    return nok(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/label-start-image.js
var labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(effects, ok3, nok) {
  const self2 = this;
  return start3;
  function start3(code3) {
    effects.enter("labelImage");
    effects.enter("labelImageMarker");
    effects.consume(code3);
    effects.exit("labelImageMarker");
    return open;
  }
  function open(code3) {
    if (code3 === 91) {
      effects.enter("labelMarker");
      effects.consume(code3);
      effects.exit("labelMarker");
      effects.exit("labelImage");
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    return code3 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code3) : ok3(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/label-start-link.js
var labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(effects, ok3, nok) {
  const self2 = this;
  return start3;
  function start3(code3) {
    effects.enter("labelLink");
    effects.enter("labelMarker");
    effects.consume(code3);
    effects.exit("labelMarker");
    effects.exit("labelLink");
    return after;
  }
  function after(code3) {
    return code3 === 94 && "_hiddenFootnoteSupport" in self2.parser.constructs ? nok(code3) : ok3(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/line-ending.js
var lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(effects, ok3) {
  return start3;
  function start3(code3) {
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    return factorySpace(effects, ok3, "linePrefix");
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/thematic-break.js
var thematicBreak = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(effects, ok3, nok) {
  let size = 0;
  let marker;
  return start3;
  function start3(code3) {
    effects.enter("thematicBreak");
    return before(code3);
  }
  function before(code3) {
    marker = code3;
    return atBreak(code3);
  }
  function atBreak(code3) {
    if (code3 === marker) {
      effects.enter("thematicBreakSequence");
      return sequence(code3);
    }
    if (size >= 3 && (code3 === null || markdownLineEnding(code3))) {
      effects.exit("thematicBreak");
      return ok3(code3);
    }
    return nok(code3);
  }
  function sequence(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      size++;
      return sequence;
    }
    effects.exit("thematicBreakSequence");
    return markdownSpace(code3) ? factorySpace(effects, atBreak, "whitespace")(code3) : atBreak(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/list.js
var list = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};
var listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};
var indentConstruct = {
  tokenize: tokenizeIndent,
  partial: true
};
function tokenizeListStart(effects, ok3, nok) {
  const self2 = this;
  const tail = self2.events[self2.events.length - 1];
  let initialSize = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  let size = 0;
  return start3;
  function start3(code3) {
    const kind = self2.containerState.type || (code3 === 42 || code3 === 43 || code3 === 45 ? "listUnordered" : "listOrdered");
    if (kind === "listUnordered" ? !self2.containerState.marker || code3 === self2.containerState.marker : asciiDigit(code3)) {
      if (!self2.containerState.type) {
        self2.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === "listUnordered") {
        effects.enter("listItemPrefix");
        return code3 === 42 || code3 === 45 ? effects.check(thematicBreak, nok, atMarker)(code3) : atMarker(code3);
      }
      if (!self2.interrupt || code3 === 49) {
        effects.enter("listItemPrefix");
        effects.enter("listItemValue");
        return inside(code3);
      }
    }
    return nok(code3);
  }
  function inside(code3) {
    if (asciiDigit(code3) && ++size < 10) {
      effects.consume(code3);
      return inside;
    }
    if ((!self2.interrupt || size < 2) && (self2.containerState.marker ? code3 === self2.containerState.marker : code3 === 41 || code3 === 46)) {
      effects.exit("listItemValue");
      return atMarker(code3);
    }
    return nok(code3);
  }
  function atMarker(code3) {
    effects.enter("listItemMarker");
    effects.consume(code3);
    effects.exit("listItemMarker");
    self2.containerState.marker = self2.containerState.marker || code3;
    return effects.check(
      blankLine,
      // Can’t be empty when interrupting.
      self2.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    );
  }
  function onBlank(code3) {
    self2.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code3);
  }
  function otherPrefix(code3) {
    if (markdownSpace(code3)) {
      effects.enter("listItemPrefixWhitespace");
      effects.consume(code3);
      effects.exit("listItemPrefixWhitespace");
      return endOfPrefix;
    }
    return nok(code3);
  }
  function endOfPrefix(code3) {
    self2.containerState.size = initialSize + self2.sliceSerialize(effects.exit("listItemPrefix"), true).length;
    return ok3(code3);
  }
}
function tokenizeListContinuation(effects, ok3, nok) {
  const self2 = this;
  self2.containerState._closeFlow = void 0;
  return effects.check(blankLine, onBlank, notBlank);
  function onBlank(code3) {
    self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
    return factorySpace(
      effects,
      ok3,
      "listItemIndent",
      self2.containerState.size + 1
    )(code3);
  }
  function notBlank(code3) {
    if (self2.containerState.furtherBlankLines || !markdownSpace(code3)) {
      self2.containerState.furtherBlankLines = void 0;
      self2.containerState.initialBlankLine = void 0;
      return notInCurrentItem(code3);
    }
    self2.containerState.furtherBlankLines = void 0;
    self2.containerState.initialBlankLine = void 0;
    return effects.attempt(indentConstruct, ok3, notInCurrentItem)(code3);
  }
  function notInCurrentItem(code3) {
    self2.containerState._closeFlow = true;
    self2.interrupt = void 0;
    return factorySpace(
      effects,
      effects.attempt(list, ok3, nok),
      "linePrefix",
      self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(code3);
  }
}
function tokenizeIndent(effects, ok3, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemIndent",
    self2.containerState.size + 1
  );
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "listItemIndent" && tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size ? ok3(code3) : nok(code3);
  }
}
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok3, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "listItemPrefixWhitespace",
    self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return !markdownSpace(code3) && tail && tail[1].type === "listItemPrefixWhitespace" ? ok3(code3) : nok(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-core-commonmark@1.1.0/node_modules/micromark-core-commonmark/lib/setext-underline.js
var setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(events, context) {
  let index2 = events.length;
  let content3;
  let text7;
  let definition3;
  while (index2--) {
    if (events[index2][0] === "enter") {
      if (events[index2][1].type === "content") {
        content3 = index2;
        break;
      }
      if (events[index2][1].type === "paragraph") {
        text7 = index2;
      }
    } else {
      if (events[index2][1].type === "content") {
        events.splice(index2, 1);
      }
      if (!definition3 && events[index2][1].type === "definition") {
        definition3 = index2;
      }
    }
  }
  const heading2 = {
    type: "setextHeading",
    start: Object.assign({}, events[text7][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  events[text7][1].type = "setextHeadingText";
  if (definition3) {
    events.splice(text7, 0, ["enter", heading2, context]);
    events.splice(definition3 + 1, 0, ["exit", events[content3][1], context]);
    events[content3][1].end = Object.assign({}, events[definition3][1].end);
  } else {
    events[content3][1] = heading2;
  }
  events.push(["exit", heading2, context]);
  return events;
}
function tokenizeSetextUnderline(effects, ok3, nok) {
  const self2 = this;
  let marker;
  return start3;
  function start3(code3) {
    let index2 = self2.events.length;
    let paragraph2;
    while (index2--) {
      if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
        paragraph2 = self2.events[index2][1].type === "paragraph";
        break;
      }
    }
    if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph2)) {
      effects.enter("setextHeadingLine");
      marker = code3;
      return before(code3);
    }
    return nok(code3);
  }
  function before(code3) {
    effects.enter("setextHeadingLineSequence");
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === marker) {
      effects.consume(code3);
      return inside;
    }
    effects.exit("setextHeadingLineSequence");
    return markdownSpace(code3) ? factorySpace(effects, after, "lineSuffix")(code3) : after(code3);
  }
  function after(code3) {
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("setextHeadingLine");
      return ok3(code3);
    }
    return nok(code3);
  }
}

// ../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/flow.js
var flow = {
  tokenize: initializeFlow
};
function initializeFlow(effects) {
  const self2 = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content2, afterConstruct)
        ),
        "linePrefix"
      )
    )
  );
  return initial;
  function atBlankEnding(code3) {
    if (code3 === null) {
      effects.consume(code3);
      return;
    }
    effects.enter("lineEndingBlank");
    effects.consume(code3);
    effects.exit("lineEndingBlank");
    self2.currentConstruct = void 0;
    return initial;
  }
  function afterConstruct(code3) {
    if (code3 === null) {
      effects.consume(code3);
      return;
    }
    effects.enter("lineEnding");
    effects.consume(code3);
    effects.exit("lineEnding");
    self2.currentConstruct = void 0;
    return initial;
  }
}

// ../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/initialize/text.js
var resolver = {
  resolveAll: createResolver()
};
var string = initializeFactory("string");
var text = initializeFactory("text");
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function initializeText(effects) {
    const self2 = this;
    const constructs2 = this.parser.constructs[field];
    const text7 = effects.attempt(constructs2, start3, notText);
    return start3;
    function start3(code3) {
      return atBreak(code3) ? text7(code3) : notText(code3);
    }
    function notText(code3) {
      if (code3 === null) {
        effects.consume(code3);
        return;
      }
      effects.enter("data");
      effects.consume(code3);
      return data2;
    }
    function data2(code3) {
      if (atBreak(code3)) {
        effects.exit("data");
        return text7(code3);
      }
      effects.consume(code3);
      return data2;
    }
    function atBreak(code3) {
      if (code3 === null) {
        return true;
      }
      const list3 = constructs2[code3];
      let index2 = -1;
      if (list3) {
        while (++index2 < list3.length) {
          const item = list3[index2];
          if (!item.previous || item.previous.call(self2, self2.previous)) {
            return true;
          }
        }
      }
      return false;
    }
  }
}
function createResolver(extraResolver) {
  return resolveAllText;
  function resolveAllText(events, context) {
    let index2 = -1;
    let enter;
    while (++index2 <= events.length) {
      if (enter === void 0) {
        if (events[index2] && events[index2][1].type === "data") {
          enter = index2;
          index2++;
        }
      } else if (!events[index2] || events[index2][1].type !== "data") {
        if (index2 !== enter + 2) {
          events[enter][1].end = events[index2 - 1][1].end;
          events.splice(enter + 2, index2 - enter - 2);
          index2 = enter + 2;
        }
        enter = void 0;
      }
    }
    return extraResolver ? extraResolver(events, context) : events;
  }
}
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0;
  while (++eventIndex <= events.length) {
    if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
      const data2 = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data2);
      let index2 = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      let tabs;
      while (index2--) {
        const chunk = chunks[index2];
        if (typeof chunk === "string") {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex) break;
          bufferIndex = -1;
        } else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) {
        } else {
          index2++;
          break;
        }
      }
      if (size) {
        const token = {
          type: eventIndex === events.length || tabs || size < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: data2.end.line,
            column: data2.end.column - size,
            offset: data2.end.offset - size,
            _index: data2.start._index + index2,
            _bufferIndex: index2 ? bufferIndex : data2.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data2.end)
        };
        data2.end = Object.assign({}, token.start);
        if (data2.start.offset === data2.end.offset) {
          Object.assign(data2, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ["enter", token, context],
            ["exit", token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events;
}

// ../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
  let point3 = Object.assign(
    from ? Object.assign({}, from) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const columnStart = {};
  const resolveAllConstructs = [];
  let chunks = [];
  let stack = [];
  let consumed = true;
  const effects = {
    consume,
    enter,
    exit: exit3,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };
  let state = initialize.tokenize.call(context, effects);
  let expectedCode;
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context;
  function write(slice) {
    chunks = push(chunks, slice);
    main();
    if (chunks[chunks.length - 1] !== null) {
      return [];
    }
    addResult(initialize, 0);
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events;
  }
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs);
  }
  function sliceStream(token) {
    return sliceChunks(chunks, token);
  }
  function now() {
    const { line: line2, column, offset: offset2, _index, _bufferIndex } = point3;
    return {
      line: line2,
      column,
      offset: offset2,
      _index,
      _bufferIndex
    };
  }
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }
  function main() {
    let chunkIndex;
    while (point3._index < chunks.length) {
      const chunk = chunks[point3._index];
      if (typeof chunk === "string") {
        chunkIndex = point3._index;
        if (point3._bufferIndex < 0) {
          point3._bufferIndex = 0;
        }
        while (point3._index === chunkIndex && point3._bufferIndex < chunk.length) {
          go2(chunk.charCodeAt(point3._bufferIndex));
        }
      } else {
        go2(chunk);
      }
    }
  }
  function go2(code3) {
    consumed = void 0;
    expectedCode = code3;
    state = state(code3);
  }
  function consume(code3) {
    if (markdownLineEnding(code3)) {
      point3.line++;
      point3.column = 1;
      point3.offset += code3 === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code3 !== -1) {
      point3.column++;
      point3.offset++;
    }
    if (point3._bufferIndex < 0) {
      point3._index++;
    } else {
      point3._bufferIndex++;
      if (point3._bufferIndex === chunks[point3._index].length) {
        point3._bufferIndex = -1;
        point3._index++;
      }
    }
    context.previous = code3;
    consumed = true;
  }
  function enter(type, fields) {
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(["enter", token, context]);
    stack.push(token);
    return token;
  }
  function exit3(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(["exit", token, context]);
    return token;
  }
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }
  function onsuccessfulcheck(_, info) {
    info.restore();
  }
  function constructFactory(onreturn, fields) {
    return hook;
    function hook(constructs2, returnState, bogusState) {
      let listOfConstructs;
      let constructIndex;
      let currentConstruct;
      let info;
      return Array.isArray(constructs2) ? handleListOfConstructs(constructs2) : "tokenize" in constructs2 ? (
        // @ts-expect-error Looks like a construct.
        handleListOfConstructs([constructs2])
      ) : handleMapOfConstructs(constructs2);
      function handleMapOfConstructs(map4) {
        return start3;
        function start3(code3) {
          const def = code3 !== null && map4[code3];
          const all2 = code3 !== null && map4.null;
          const list3 = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(def) ? def : def ? [def] : [],
            ...Array.isArray(all2) ? all2 : all2 ? [all2] : []
          ];
          return handleListOfConstructs(list3)(code3);
        }
      }
      function handleListOfConstructs(list3) {
        listOfConstructs = list3;
        constructIndex = 0;
        if (list3.length === 0) {
          return bogusState;
        }
        return handleConstruct(list3[constructIndex]);
      }
      function handleConstruct(construct) {
        return start3;
        function start3(code3) {
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }
          if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
            return nok(code3);
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok3,
            nok
          )(code3);
        }
      }
      function ok3(code3) {
        consumed = true;
        onreturn(currentConstruct, info);
        return returnState;
      }
      function nok(code3) {
        consumed = true;
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex]);
        }
        return bogusState;
      }
    }
  }
  function addResult(construct, from2) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from2,
        context.events.length - from2,
        construct.resolve(context.events.slice(from2), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    };
    function restore() {
      point3 = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }
  function accountForPotentialSkip() {
    if (point3.line in columnStart && point3.column < 2) {
      point3.column = columnStart[point3.line];
      point3.offset += columnStart[point3.line] - 1;
    }
  }
}
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  let view;
  if (startIndex === endIndex) {
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === "string") {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view;
}
function serializeChunks(chunks, expandTabs) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = expandTabs ? " " : "	";
          break;
        }
        case -1: {
          if (!expandTabs && atTab) continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}

// ../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
  attentionMarkers: () => attentionMarkers,
  contentInitial: () => contentInitial,
  disable: () => disable,
  document: () => document3,
  flow: () => flow2,
  flowInitial: () => flowInitial,
  insideSpan: () => insideSpan,
  string: () => string2,
  text: () => text2
});
var document3 = {
  [42]: list,
  [43]: list,
  [45]: list,
  [48]: list,
  [49]: list,
  [50]: list,
  [51]: list,
  [52]: list,
  [53]: list,
  [54]: list,
  [55]: list,
  [56]: list,
  [57]: list,
  [62]: blockQuote
};
var contentInitial = {
  [91]: definition
};
var flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};
var flow2 = {
  [35]: headingAtx,
  [42]: thematicBreak,
  [45]: [setextUnderline, thematicBreak],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak,
  [96]: codeFenced,
  [126]: codeFenced
};
var string2 = {
  [38]: characterReference,
  [92]: characterEscape
};
var text2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};
var insideSpan = {
  null: [attention, resolver]
};
var attentionMarkers = {
  null: [42, 95]
};
var disable = {
  null: []
};

// ../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/parse.js
function parse(options) {
  const settings = options || {};
  const constructs2 = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([constructs_exports, ...settings.extensions || []])
  );
  const parser = {
    defined: [],
    lazy: {},
    constructs: constructs2,
    content: create(content),
    document: create(document2),
    flow: create(flow),
    string: create(string),
    text: create(text)
  };
  return parser;
  function create(initial) {
    return creator;
    function creator(from) {
      return createTokenizer(parser, initial, from);
    }
  }
}

// ../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/preprocess.js
var search = /[\0\t\n\r]/g;
function preprocess() {
  let column = 1;
  let buffer2 = "";
  let start3 = true;
  let atCarriageReturn;
  return preprocessor;
  function preprocessor(value, encoding, end) {
    const chunks = [];
    let match;
    let next;
    let startPosition;
    let endPosition;
    let code3;
    value = buffer2 + value.toString(encoding);
    startPosition = 0;
    buffer2 = "";
    if (start3) {
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start3 = void 0;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition = match && match.index !== void 0 ? match.index : value.length;
      code3 = value.charCodeAt(endPosition);
      if (!match) {
        buffer2 = value.slice(startPosition);
        break;
      }
      if (code3 === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = void 0;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = void 0;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code3) {
          case 0: {
            chunks.push(65533);
            column++;
            break;
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next) chunks.push(-1);
            break;
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break;
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(-5);
      if (buffer2) chunks.push(buffer2);
      chunks.push(null);
    }
    return chunks;
  }
}

// ../../../node_modules/.pnpm/micromark@3.2.0/node_modules/micromark/lib/postprocess.js
function postprocess(events) {
  while (!subtokenize(events)) {
  }
  return events;
}

// ../../../node_modules/.pnpm/micromark-util-decode-numeric-character-reference@1.1.0/node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value, base2) {
  const code3 = Number.parseInt(value, base2);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code3 < 9 || code3 === 11 || code3 > 13 && code3 < 32 || // Control character (DEL) of C0, and C1 controls.
    code3 > 126 && code3 < 160 || // Lone high surrogates and low surrogates.
    code3 > 55295 && code3 < 57344 || // Noncharacters.
    code3 > 64975 && code3 < 65008 || (code3 & 65535) === 65535 || (code3 & 65535) === 65534 || // Out of range
    code3 > 1114111
  ) {
    return "\uFFFD";
  }
  return String.fromCharCode(code3);
}

// ../../../node_modules/.pnpm/micromark-util-decode-string@1.1.0/node_modules/micromark-util-decode-string/index.js
var characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode);
}
function decode($0, $1, $2) {
  if ($1) {
    return $1;
  }
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head2 = $2.charCodeAt(1);
    const hex = head2 === 120 || head2 === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
  }
  return decodeNamedCharacterReference($2) || $0;
}

// ../../../node_modules/.pnpm/mdast-util-from-markdown@1.3.0/node_modules/mdast-util-from-markdown/lib/index.js
var own2 = {}.hasOwnProperty;
var fromMarkdown = (
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */
  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function(value, encoding, options) {
    if (typeof encoding !== "string") {
      options = encoding;
      encoding = void 0;
    }
    return compiler(options)(
      postprocess(
        // @ts-expect-error: micromark types need to accept `null`.
        parse(options).document().write(preprocess()(value, encoding, true))
      )
    );
  }
);
function compiler(options) {
  const config = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: opener(link2),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading2),
      blockQuote: opener(blockQuote2),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer2,
      codeFencedFenceMeta: buffer2,
      codeIndented: opener(codeFlow, buffer2),
      codeText: opener(codeText2, buffer2),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition3),
      definitionDestinationString: buffer2,
      definitionLabelString: buffer2,
      definitionTitleString: buffer2,
      emphasis: opener(emphasis2),
      hardBreakEscape: opener(hardBreak2),
      hardBreakTrailing: opener(hardBreak2),
      htmlFlow: opener(html2, buffer2),
      htmlFlowData: onenterdata,
      htmlText: opener(html2, buffer2),
      htmlTextData: onenterdata,
      image: opener(image2),
      label: buffer2,
      link: opener(link2),
      listItem: opener(listItem2),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list3, onenterlistordered),
      listUnordered: opener(list3),
      paragraph: opener(paragraph2),
      reference: onenterreference,
      referenceString: buffer2,
      resourceDestinationString: buffer2,
      resourceTitleString: buffer2,
      setextHeading: opener(heading2),
      strong: opener(strong2),
      thematicBreak: opener(thematicBreak3)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);
  const data2 = {};
  return compile;
  function compile(events) {
    let tree = {
      type: "root",
      children: []
    };
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit: exit3,
      buffer: buffer2,
      resume,
      setData,
      getData
    };
    const listStack = [];
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
        if (events[index2][0] === "enter") {
          listStack.push(index2);
        } else {
          const tail = listStack.pop();
          index2 = prepareList(events, tail, index2);
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      const handler = config[events[index2][0]];
      if (own2.call(handler, events[index2][1].type)) {
        handler[events[index2][1].type].call(
          Object.assign(
            {
              sliceSerialize: events[index2][2].sliceSerialize
            },
            context
          ),
          events[index2][1]
        );
      }
    }
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, void 0, tail[0]);
    }
    tree.position = {
      start: point2(
        events.length > 0 ? events[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: point2(
        events.length > 0 ? events[events.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    };
    index2 = -1;
    while (++index2 < config.transforms.length) {
      tree = config.transforms[index2](tree) || tree;
    }
    return tree;
  }
  function prepareList(events, start3, length) {
    let index2 = start3 - 1;
    let containerBalance = -1;
    let listSpread = false;
    let listItem3;
    let lineIndex;
    let firstBlankLineIndex;
    let atMarker;
    while (++index2 <= length) {
      const event = events[index2];
      if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
        if (event[0] === "enter") {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = void 0;
      } else if (event[1].type === "lineEndingBlank") {
        if (event[0] === "enter") {
          if (listItem3 && !atMarker && !containerBalance && !firstBlankLineIndex) {
            firstBlankLineIndex = index2;
          }
          atMarker = void 0;
        }
      } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
      } else {
        atMarker = void 0;
      }
      if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
        if (listItem3) {
          let tailIndex = index2;
          lineIndex = void 0;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
              if (tailEvent[0] === "exit") continue;
              if (lineIndex) {
                events[lineIndex][1].type = "lineEndingBlank";
                listSpread = true;
              }
              tailEvent[1].type = "lineEnding";
              lineIndex = tailIndex;
            } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
            } else {
              break;
            }
          }
          if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
            listItem3._spread = true;
          }
          listItem3.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index2, 0, ["exit", listItem3, event[2]]);
          index2++;
          length++;
        }
        if (event[1].type === "listItemPrefix") {
          listItem3 = {
            type: "listItem",
            // @ts-expect-error Patched
            _spread: false,
            start: Object.assign({}, event[1].start)
          };
          events.splice(index2, 0, ["enter", listItem3, event[2]]);
          index2++;
          length++;
          firstBlankLineIndex = void 0;
          atMarker = true;
        }
      }
    }
    events[start3][1]._spread = listSpread;
    return length;
  }
  function setData(key, value) {
    data2[key] = value;
  }
  function getData(key) {
    return data2[key];
  }
  function opener(create, and) {
    return open;
    function open(token) {
      enter.call(this, create(token), token);
      if (and) and.call(this, token);
    }
  }
  function buffer2() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function enter(node2, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    parent.children.push(node2);
    this.stack.push(node2);
    this.tokenStack.push([token, errorHandler]);
    node2.position = {
      start: point2(token.start)
    };
    return node2;
  }
  function closer(and) {
    return close;
    function close(token) {
      if (and) and.call(this, token);
      exit3.call(this, token);
    }
  }
  function exit3(token, onExitError) {
    const node2 = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        "Cannot close `" + token.type + "` (" + stringifyPosition({
          start: token.start,
          end: token.end
        }) + "): it\u2019s not open"
      );
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node2.position.end = point2(token.end);
    return node2;
  }
  function resume() {
    return toString(this.stack.pop());
  }
  function onenterlistordered() {
    setData("expectingFirstListItemValue", true);
  }
  function onenterlistitemvalue(token) {
    if (getData("expectingFirstListItemValue")) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData("expectingFirstListItemValue");
    }
  }
  function onexitcodefencedfenceinfo() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.lang = data3;
  }
  function onexitcodefencedfencemeta() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.meta = data3;
  }
  function onexitcodefencedfence() {
    if (getData("flowCodeInside")) return;
    this.buffer();
    setData("flowCodeInside", true);
  }
  function onexitcodefenced() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "");
    setData("flowCodeInside");
  }
  function onexitcodeindented() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3.replace(/(\r?\n|\r)$/g, "");
  }
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }
  function onexitdefinitiontitlestring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data3;
  }
  function onexitdefinitiondestinationstring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data3;
  }
  function onexitatxheadingsequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    if (!node2.depth) {
      const depth = this.sliceSerialize(token).length;
      node2.depth = depth;
    }
  }
  function onexitsetextheadingtext() {
    setData("setextHeadingSlurpLineEnding", true);
  }
  function onexitsetextheadinglinesequence(token) {
    const node2 = this.stack[this.stack.length - 1];
    node2.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }
  function onexitsetextheading() {
    setData("setextHeadingSlurpLineEnding");
  }
  function onenterdata(token) {
    const node2 = this.stack[this.stack.length - 1];
    let tail = node2.children[node2.children.length - 1];
    if (!tail || tail.type !== "text") {
      tail = text7();
      tail.position = {
        start: point2(token.start)
      };
      node2.children.push(tail);
    }
    this.stack.push(tail);
  }
  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point2(token.end);
  }
  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    if (getData("atHardBreak")) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point2(token.end);
      setData("atHardBreak");
      return;
    }
    if (!getData("setextHeadingSlurpLineEnding") && config.canContainEols.includes(context.type)) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }
  function onexithardbreak() {
    setData("atHardBreak", true);
  }
  function onexithtmlflow() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3;
  }
  function onexithtmltext() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3;
  }
  function onexitcodetext() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.value = data3;
  }
  function onexitlink() {
    const node2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitimage() {
    const node2 = this.stack[this.stack.length - 1];
    if (getData("inReference")) {
      const referenceType = getData("referenceType") || "shortcut";
      node2.type += "Reference";
      node2.referenceType = referenceType;
      delete node2.url;
      delete node2.title;
    } else {
      delete node2.identifier;
      delete node2.label;
    }
    setData("referenceType");
  }
  function onexitlabeltext(token) {
    const string3 = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    ancestor.label = decodeString(string3);
    ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
  }
  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    setData("inReference", true);
    if (node2.type === "link") {
      const children = fragment.children;
      node2.children = children;
    } else {
      node2.alt = value;
    }
  }
  function onexitresourcedestinationstring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.url = data3;
  }
  function onexitresourcetitlestring() {
    const data3 = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.title = data3;
  }
  function onexitresource() {
    setData("inReference");
  }
  function onenterreference() {
    setData("referenceType", "collapsed");
  }
  function onexitreferencestring(token) {
    const label = this.resume();
    const node2 = this.stack[this.stack.length - 1];
    node2.label = label;
    node2.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    setData("referenceType", "full");
  }
  function onexitcharacterreferencemarker(token) {
    setData("characterReferenceType", token.type);
  }
  function onexitcharacterreferencevalue(token) {
    const data3 = this.sliceSerialize(token);
    const type = getData("characterReferenceType");
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data3,
        type === "characterReferenceMarkerNumeric" ? 10 : 16
      );
      setData("characterReferenceType");
    } else {
      const result = decodeNamedCharacterReference(data3);
      value = result;
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point2(token.end);
  }
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = this.sliceSerialize(token);
  }
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node2 = this.stack[this.stack.length - 1];
    node2.url = "mailto:" + this.sliceSerialize(token);
  }
  function blockQuote2() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function codeFlow() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function codeText2() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function definition3() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function emphasis2() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function heading2() {
    return {
      type: "heading",
      depth: void 0,
      children: []
    };
  }
  function hardBreak2() {
    return {
      type: "break"
    };
  }
  function html2() {
    return {
      type: "html",
      value: ""
    };
  }
  function image2() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function link2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function list3(token) {
    return {
      type: "list",
      ordered: token.type === "listOrdered",
      start: null,
      // @ts-expect-error Patched.
      spread: token._spread,
      children: []
    };
  }
  function listItem2(token) {
    return {
      type: "listItem",
      // @ts-expect-error Patched.
      spread: token._spread,
      checked: null,
      children: []
    };
  }
  function paragraph2() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function strong2() {
    return {
      type: "strong",
      children: []
    };
  }
  function text7() {
    return {
      type: "text",
      value: ""
    };
  }
  function thematicBreak3() {
    return {
      type: "thematicBreak"
    };
  }
}
function point2(d) {
  return {
    line: d.line,
    column: d.column,
    offset: d.offset
  };
}
function configure(combined, extensions) {
  let index2 = -1;
  while (++index2 < extensions.length) {
    const value = extensions[index2];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}
function extension(combined, extension2) {
  let key;
  for (key in extension2) {
    if (own2.call(extension2, key)) {
      if (key === "canContainEols") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "transforms") {
        const right = extension2[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === "enter" || key === "exit") {
        const right = extension2[key];
        if (right) {
          Object.assign(combined[key], right);
        }
      }
    }
  }
}
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      "Cannot close `" + left.type + "` (" + stringifyPosition({
        start: left.start,
        end: left.end
      }) + "): a different token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is open"
    );
  } else {
    throw new Error(
      "Cannot close document, a token (`" + right.type + "`, " + stringifyPosition({
        start: right.start,
        end: right.end
      }) + ") is still open"
    );
  }
}

// ../../../node_modules/.pnpm/remark-parse@10.0.2/node_modules/remark-parse/lib/index.js
function remarkParse(options) {
  const parser = (doc) => {
    const settings = (
      /** @type {Options} */
      this.data("settings")
    );
    return fromMarkdown(
      doc,
      Object.assign({}, settings, options, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data("micromarkExtensions") || [],
        mdastExtensions: this.data("fromMarkdownExtensions") || []
      })
    );
  };
  Object.assign(this, { Parser: parser });
}

// ../../../node_modules/.pnpm/zwitch@2.0.4/node_modules/zwitch/index.js
var own3 = {}.hasOwnProperty;
function zwitch(key, options) {
  const settings = options || {};
  function one2(value, ...parameters) {
    let fn = one2.invalid;
    const handlers = one2.handlers;
    if (value && own3.call(value, key)) {
      const id2 = String(value[key]);
      fn = own3.call(handlers, id2) ? handlers[id2] : one2.unknown;
    }
    if (fn) {
      return fn.call(this, value, ...parameters);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/configure.js
function configure2(base2, extension2) {
  let index2 = -1;
  let key;
  if (extension2.extensions) {
    while (++index2 < extension2.extensions.length) {
      configure2(base2, extension2.extensions[index2]);
    }
  }
  for (key in extension2) {
    if (key === "extensions") {
    } else if (key === "unsafe" || key === "join") {
      base2[key] = [...base2[key] || [], ...extension2[key] || []];
    } else if (key === "handlers") {
      base2[key] = Object.assign(base2[key], extension2[key] || {});
    } else {
      base2.options[key] = extension2[key];
    }
  }
  return base2;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote(node2, _, state, info) {
  const exit3 = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map
  );
  exit3();
  return value;
}
function map(line2, _, blank) {
  return ">" + (blank ? "" : " ") + line2;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list3, none) {
  if (typeof list3 === "string") {
    list3 = [list3];
  }
  if (!list3 || list3.length === 0) {
    return none;
  }
  let index2 = -1;
  while (++index2 < list3.length) {
    if (stack.includes(list3[index2])) {
      return true;
    }
  }
  return false;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_, _1, state, info) {
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    if (state.unsafe[index2].character === "\n" && patternInScope(state.stack, state.unsafe[index2])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// ../../../node_modules/.pnpm/longest-streak@3.1.0/node_modules/longest-streak/index.js
function longestStreak(value, substring) {
  const source2 = String(value);
  let index2 = source2.indexOf(substring);
  let expected = index2;
  let count = 0;
  let max = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index2 !== -1) {
    if (index2 === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index2 + substring.length;
    index2 = source2.indexOf(substring, expected);
  }
  return max;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node2, state) {
  return Boolean(
    !state.options.fences && node2.value && // If there’s no info…
    !node2.lang && // And there’s a non-whitespace character…
    /[^ \r\n]/.test(node2.value) && // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node2.value)
  );
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/code.js
function code(node2, _, state, info) {
  const marker = checkFence(state);
  const raw = node2.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node2, state)) {
    const exit4 = state.enter("codeIndented");
    const value2 = state.indentLines(raw, map2);
    exit4();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
  const exit3 = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node2.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node2.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node2.lang && node2.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node2.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw) {
    value += tracker.move(raw + "\n");
  }
  value += tracker.move(sequence);
  exit3();
  return value;
}
function map2(line2, _, blank) {
  return (blank ? "" : "    ") + line2;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition2(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node2), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If there’s no url, or…
    !node2.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit3();
  return value;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node2, _, state, info) {
  const marker = checkEmphasis(state);
  const exit3 = state.enter("emphasis");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker);
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker);
  exit3();
  return value;
}
function emphasisPeek(_, _1, state) {
  return state.options.emphasis || "*";
}

// ../../../node_modules/.pnpm/unist-util-is@5.2.1/node_modules/unist-util-is/lib/index.js
var convert = (
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {AssertAnything}
   */
  function(test) {
    if (test === void 0 || test === null) {
      return ok;
    }
    if (typeof test === "string") {
      return typeFactory(test);
    }
    if (typeof test === "object") {
      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index2 = -1;
  while (++index2 < tests.length) {
    checks[index2] = convert(tests[index2]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index3 = -1;
    while (++index3 < checks.length) {
      if (checks[index3].call(this, ...parameters)) return true;
    }
    return false;
  }
}
function propsFactory(check) {
  return castFactory(all2);
  function all2(node2) {
    let key;
    for (key in check) {
      if (node2[key] !== check[key]) return false;
    }
    return true;
  }
}
function typeFactory(check) {
  return castFactory(type);
  function type(node2) {
    return node2 && node2.type === check;
  }
}
function castFactory(check) {
  return assertion;
  function assertion(node2, ...parameters) {
    return Boolean(
      node2 && typeof node2 === "object" && "type" in node2 && // @ts-expect-error: fine.
      Boolean(check.call(this, node2, ...parameters))
    );
  }
}
function ok() {
  return true;
}

// ../../../node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/color.browser.js
function color(d) {
  return d;
}

// ../../../node_modules/.pnpm/unist-util-visit-parents@5.1.3/node_modules/unist-util-visit-parents/lib/index.js
var CONTINUE = true;
var EXIT = false;
var SKIP = "skip";
var visitParents = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor<Node>} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    const is3 = convert(test);
    const step = reverse ? -1 : 1;
    factory(tree, void 0, [])();
    function factory(node2, index2, parents) {
      const value = node2 && typeof node2 === "object" ? node2 : {};
      if (typeof value.type === "string") {
        const name2 = (
          // `hast`
          typeof value.tagName === "string" ? value.tagName : (
            // `xast`
            typeof value.name === "string" ? value.name : void 0
          )
        );
        Object.defineProperty(visit3, "name", {
          value: "node (" + color(node2.type + (name2 ? "<" + name2 + ">" : "")) + ")"
        });
      }
      return visit3;
      function visit3() {
        let result = [];
        let subresult;
        let offset2;
        let grandparents;
        if (!test || is3(node2, index2, parents[parents.length - 1] || null)) {
          result = toResult(visitor(node2, parents));
          if (result[0] === EXIT) {
            return result;
          }
        }
        if (node2.children && result[0] !== SKIP) {
          offset2 = (reverse ? node2.children.length : -1) + step;
          grandparents = parents.concat(node2);
          while (offset2 > -1 && offset2 < node2.children.length) {
            subresult = factory(node2.children[offset2], offset2, grandparents)();
            if (subresult[0] === EXIT) {
              return subresult;
            }
            offset2 = typeof subresult[1] === "number" ? subresult[1] : offset2 + step;
          }
        }
        return result;
      }
    }
  }
);
function toResult(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE, value];
  }
  return [value];
}

// ../../../node_modules/.pnpm/unist-util-visit@4.1.2/node_modules/unist-util-visit/lib/index.js
var visit = (
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  /**
   * @param {Node} tree
   * @param {Test} test
   * @param {Visitor} visitor
   * @param {boolean | null | undefined} [reverse]
   * @returns {void}
   */
  function(tree, test, visitor, reverse) {
    if (typeof test === "function" && typeof visitor !== "function") {
      reverse = visitor;
      visitor = test;
      test = null;
    }
    visitParents(tree, test, overload, reverse);
    function overload(node2, parents) {
      const parent = parents[parents.length - 1];
      return visitor(
        node2,
        parent ? parent.children.indexOf(node2) : null,
        parent
      );
    }
  }
);

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node2, state) {
  let literalWithBreak = false;
  visit(node2, (node3) => {
    if ("value" in node3 && /\r?\n|\r/.test(node3.value) || node3.type === "break") {
      literalWithBreak = true;
      return EXIT;
    }
  });
  return Boolean(
    (!node2.depth || node2.depth < 3) && toString(node2) && (state.options.setext || literalWithBreak)
  );
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading(node2, _, state, info) {
  const rank = Math.max(Math.min(6, node2.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node2, state)) {
    const exit4 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node2, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit4();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size…
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit3 = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node2, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit3();
  return value;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/html.js
html.peek = htmlPeek;
function html(node2) {
  return node2.value || "";
}
function htmlPeek() {
  return "<";
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/image.js
image.peek = imagePeek;
function image(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit3 = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node2.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function imagePeek() {
  return "!";
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit3 = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node2.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js
function patternCompile(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp(
      (before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""),
      "g"
    );
  }
  return pattern._compiled;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode.peek = inlineCodePeek;
function inlineCode(node2, _, state) {
  let value = node2.value || "";
  let sequence = "`";
  let index2 = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value) || /^`|`$/.test(value))) {
    value = " " + value + " ";
  }
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    const expression = patternCompile(pattern);
    let match;
    if (!pattern.atBreak) continue;
    while (match = expression.exec(value)) {
      let position2 = match.index;
      if (value.charCodeAt(position2) === 10 && value.charCodeAt(position2 - 1) === 13) {
        position2--;
      }
      value = value.slice(0, position2) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node2, state) {
  const raw = toString(node2);
  return Boolean(
    !state.options.resourceLink && // If there’s a url…
    node2.url && // And there’s a no title…
    !node2.title && // And the content of `node` is a single text node…
    node2.children && node2.children.length === 1 && node2.children[0].type === "text" && // And if the url is the same as the content…
    (raw === node2.url || "mailto:" + raw === node2.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(node2.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(node2.url)
  );
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/link.js
link.peek = linkPeek;
function link(node2, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit3;
  let subexit;
  if (formatLinkAsAutolink(node2, state)) {
    const stack = state.stack;
    state.stack = [];
    exit3 = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node2, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit3();
    state.stack = stack;
    return value2;
  }
  exit3 = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node2.url && node2.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node2.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node2.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node2.url, {
        before: value,
        after: node2.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node2.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node2.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit3();
  return value;
}
function linkPeek(node2, _, state) {
  return formatLinkAsAutolink(node2, state) ? "<" : "[";
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node2, _, state, info) {
  const type = node2.referenceType;
  const exit3 = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text7 = state.containerPhrasing(node2, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text7 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node2), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit3();
  if (type === "full" || !text7 || text7 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(state) {
  const marker = state.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  }
  return marker;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js
function checkBulletOrderedOther(state) {
  const bulletOrdered = checkBulletOrdered(state);
  const bulletOrderedOther = state.options.bulletOrderedOther;
  if (!bulletOrderedOther) {
    return bulletOrdered === "." ? ")" : ".";
  }
  if (bulletOrderedOther !== "." && bulletOrderedOther !== ")") {
    throw new Error(
      "Cannot serialize items with `" + bulletOrderedOther + "` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOrderedOther === bulletOrdered) {
    throw new Error(
      "Expected `bulletOrdered` (`" + bulletOrdered + "`) and `bulletOrderedOther` (`" + bulletOrderedOther + "`) to be different"
    );
  }
  return bulletOrderedOther;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/list.js
function list2(node2, parent, state, info) {
  const exit3 = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node2.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node2.ordered ? checkBulletOrderedOther(state) : checkBulletOther(state);
  const bulletLastUsed = state.bulletLastUsed;
  let useDifferentMarker = false;
  if (parent && // Explicit `other` set.
  (node2.ordered ? state.options.bulletOrderedOther : state.options.bulletOther) && bulletLastUsed && bullet === bulletLastUsed) {
    useDifferentMarker = true;
  }
  if (!node2.ordered) {
    const firstListItem = node2.children ? node2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index2 = -1;
      while (++index2 < node2.children.length) {
        const item = node2.children[index2];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node2, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit3();
  return value;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(state) {
  const style = state.options.listItemIndent || "tab";
  if (style === 1 || style === "1") {
    return "one";
  }
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error(
      "Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  }
  return style;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node2, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);
  if (parent && parent.type === "list" && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node2)) + bullet;
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.type === "list" && parent.spread || node2.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const tracker = state.createTracker(info);
  tracker.move(bullet + " ".repeat(size - bullet.length));
  tracker.shift(size);
  const exit3 = state.enter("listItem");
  const value = state.indentLines(
    state.containerFlow(node2, tracker.current()),
    map4
  );
  exit3();
  return value;
  function map4(line2, index2, blank) {
    if (index2) {
      return (blank ? "" : " ".repeat(size)) + line2;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line2;
  }
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph(node2, _, state, info) {
  const exit3 = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node2, info);
  subexit();
  exit3();
  return value;
}

// ../../../node_modules/.pnpm/mdast-util-phrasing@3.0.1/node_modules/mdast-util-phrasing/lib/index.js
var phrasing = (
  /** @type {AssertPredicatePhrasing} */
  convert([
    "break",
    "delete",
    "emphasis",
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    "link",
    "linkReference",
    "strong",
    "text"
  ])
);

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/root.js
function root(node2, _, state, info) {
  const hasPhrasing = node2.children.some((d) => phrasing(d));
  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return fn.call(state, node2, info);
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong.peek = strongPeek;
function strong(node2, _, state, info) {
  const marker = checkStrong(state);
  const exit3 = state.enter("strong");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker + marker);
  value += tracker.move(
    state.containerPhrasing(node2, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker + marker);
  exit3();
  return value;
}
function strongPeek(_, _1, state) {
  return state.options.strong || "*";
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/text.js
function text3(node2, _, state, info) {
  return state.safe(node2.value, info);
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak2(_, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle = {
  blockquote,
  break: hardBreak,
  code,
  definition: definition2,
  emphasis,
  hardBreak,
  heading,
  html,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list: list2,
  listItem,
  paragraph,
  root,
  strong,
  text: text3,
  thematicBreak: thematicBreak2
};

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/join.js
var join2 = [joinDefaults];
function joinDefaults(left, right, parent, state) {
  if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
    return false;
  }
  if (left.type === "list" && left.type === right.type && Boolean(left.ordered) === Boolean(right.ordered) && !(left.ordered ? state.options.bulletOrderedOther : state.options.bulletOther)) {
    return false;
  }
  if ("spread" in parent && typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && // Two paragraphs.
    (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
    right.type === "heading" && formatHeadingAsSetext(right, state))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/unsafe.js
var fullPhrasingSpans = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
var unsafe = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
  { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A plus sign could start a list item.
  { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
  // A dot could start a list item.
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: true, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: true, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: true, character: "~" }
];

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/association.js
function association(node2) {
  if (node2.label || !node2.identifier) {
    return node2.label || "";
  }
  return decodeString(node2.identifier);
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const results = [];
  let index2 = -1;
  let before = info.before;
  indexStack.push(-1);
  let tracker = state.createTracker(info);
  while (++index2 < children.length) {
    const child = children[index2];
    let after;
    indexStack[indexStack.length - 1] = index2;
    if (index2 + 1 < children.length) {
      let handle2 = state.handle.handlers[children[index2 + 1].type];
      if (handle2 && handle2.peek) handle2 = handle2.peek;
      after = handle2 ? handle2(children[index2 + 1], parent, state, {
        before: "",
        after: "",
        ...tracker.current()
      }).charAt(0) : "";
    } else {
      after = info.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        " "
      );
      before = " ";
      tracker = state.createTracker(info);
      tracker.move(results.join(""));
    }
    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          ...tracker.current(),
          before,
          after
        })
      )
    );
    before = results[results.length - 1].slice(-1);
  }
  indexStack.pop();
  return results.join("");
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const tracker = state.createTracker(info);
  const results = [];
  let index2 = -1;
  indexStack.push(-1);
  while (++index2 < children.length) {
    const child = children[index2];
    indexStack[indexStack.length - 1] = index2;
    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          before: "\n",
          after: "\n",
          ...tracker.current()
        })
      )
    );
    if (child.type !== "list") {
      state.bulletLastUsed = void 0;
    }
    if (index2 < children.length - 1) {
      results.push(
        tracker.move(between(child, children[index2 + 1], parent, state))
      );
    }
  }
  indexStack.pop();
  return results.join("");
}
function between(left, right, parent, state) {
  let index2 = state.join.length;
  while (index2--) {
    const result = state.join[index2](left, right, parent, state);
    if (result === true || result === 1) {
      break;
    }
    if (typeof result === "number") {
      return "\n".repeat(1 + result);
    }
    if (result === false) {
      return "\n\n<!---->\n\n";
    }
  }
  return "\n\n";
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var eol = /\r?\n|\r/g;
function indentLines(value, map4) {
  const result = [];
  let start3 = 0;
  let line2 = 0;
  let match;
  while (match = eol.exec(value)) {
    one2(value.slice(start3, match.index));
    result.push(match[0]);
    start3 = match.index + match[0].length;
    line2++;
  }
  one2(value.slice(start3));
  return result.join("");
  function one2(value2) {
    result.push(map4(value2, line2, !value2));
  }
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/safe.js
function safe(state, input, config) {
  const value = (config.before || "") + (input || "") + (config.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index2 = -1;
  while (++index2 < state.unsafe.length) {
    const pattern = state.unsafe[index2];
    if (!patternInScope(state.stack, pattern)) {
      continue;
    }
    const expression = patternCompile(pattern);
    let match;
    while (match = expression.exec(value)) {
      const before = "before" in pattern || Boolean(pattern.atBreak);
      const after = "after" in pattern;
      const position2 = match.index + (before ? match[1].length : 0);
      if (positions.includes(position2)) {
        if (infos[position2].before && !before) {
          infos[position2].before = false;
        }
        if (infos[position2].after && !after) {
          infos[position2].after = false;
        }
      } else {
        positions.push(position2);
        infos[position2] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start3 = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index2 = -1;
  while (++index2 < positions.length) {
    const position2 = positions[index2];
    if (position2 < start3 || position2 >= end) {
      continue;
    }
    if (position2 + 1 < end && positions[index2 + 1] === position2 + 1 && infos[position2].after && !infos[position2 + 1].before && !infos[position2 + 1].after || positions[index2 - 1] === position2 - 1 && infos[position2].before && !infos[position2 - 1].before && !infos[position2 - 1].after) {
      continue;
    }
    if (start3 !== position2) {
      result.push(escapeBackslashes(value.slice(start3, position2), "\\"));
    }
    start3 = position2;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position2)) && (!config.encode || !config.encode.includes(value.charAt(position2)))) {
      result.push("\\");
    } else {
      result.push(
        "&#x" + value.charCodeAt(position2).toString(16).toUpperCase() + ";"
      );
      start3++;
    }
  }
  result.push(escapeBackslashes(value.slice(start3, end), config.after));
  return result.join("");
}
function numerical(a, b) {
  return a - b;
}
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value + after;
  let index2 = -1;
  let start3 = 0;
  let match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index2 < positions.length) {
    if (start3 !== positions[index2]) {
      results.push(value.slice(start3, positions[index2]));
    }
    results.push("\\");
    start3 = positions[index2];
  }
  results.push(value.slice(start3));
  return results.join("");
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/util/track.js
function track(config) {
  const options = config || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line2 = now.line || 1;
  let column = now.column || 1;
  return { move, current: current2, shift };
  function current2() {
    return { now: { line: line2, column }, lineShift };
  }
  function shift(value) {
    lineShift += value;
  }
  function move(input) {
    const value = input || "";
    const chunks = value.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line2 += chunks.length - 1;
    column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value;
  }
}

// ../../../node_modules/.pnpm/mdast-util-to-markdown@1.5.0/node_modules/mdast-util-to-markdown/lib/index.js
function toMarkdown(tree, options = {}) {
  const state = {
    enter,
    indentLines,
    associationId: association,
    containerPhrasing: containerPhrasingBound,
    containerFlow: containerFlowBound,
    createTracker: track,
    safe: safeBound,
    stack: [],
    unsafe: [],
    join: [],
    // @ts-expect-error: we’ll fill it next.
    handlers: {},
    options: {},
    indexStack: [],
    // @ts-expect-error: we’ll add `handle` later.
    handle: void 0
  };
  configure2(state, { unsafe, join: join2, handlers: handle });
  configure2(state, options);
  if (state.options.tightDefinitions) {
    configure2(state, { join: [joinDefinition] });
  }
  state.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: state.handlers
  });
  let result = state.handle(tree, void 0, state, {
    before: "\n",
    after: "\n",
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
    result += "\n";
  }
  return result;
  function enter(name2) {
    state.stack.push(name2);
    return exit3;
    function exit3() {
      state.stack.pop();
    }
  }
}
function invalid(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown(node2) {
  throw new Error("Cannot handle unknown node `" + node2.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}
function containerPhrasingBound(parent, info) {
  return containerPhrasing(parent, this, info);
}
function containerFlowBound(parent, info) {
  return containerFlow(parent, this, info);
}
function safeBound(value, config) {
  return safe(this, value, config);
}

// ../../../node_modules/.pnpm/remark-stringify@10.0.3/node_modules/remark-stringify/lib/index.js
function remarkStringify(options) {
  const compiler2 = (tree) => {
    const settings = (
      /** @type {Options} */
      this.data("settings")
    );
    return toMarkdown(
      tree,
      Object.assign({}, settings, options, {
        // Note: this option is not in the readme.
        // The goal is for it to be set by plugins on `data` instead of being
        // passed by users.
        extensions: (
          /** @type {ToMarkdownOptions['extensions']} */
          this.data("toMarkdownExtensions") || []
        )
      })
    );
  };
  Object.assign(this, { Compiler: compiler2 });
}

// ../../../node_modules/.pnpm/remark@14.0.2/node_modules/remark/index.js
var remark = unified().use(remarkParse).use(remarkStringify).freeze();

// ../../../node_modules/.pnpm/acorn@8.8.2/node_modules/acorn/dist/acorn.mjs
var acorn_exports = {};
__export(acorn_exports, {
  Node: () => Node,
  Parser: () => Parser,
  Position: () => Position,
  SourceLocation: () => SourceLocation,
  TokContext: () => TokContext,
  Token: () => Token,
  TokenType: () => TokenType,
  defaultOptions: () => defaultOptions,
  getLineInfo: () => getLineInfo,
  isIdentifierChar: () => isIdentifierChar,
  isIdentifierStart: () => isIdentifierStart,
  isNewLine: () => isNewLine,
  keywordTypes: () => keywords,
  lineBreak: () => lineBreak,
  lineBreakG: () => lineBreakG,
  nonASCIIwhitespace: () => nonASCIIwhitespace,
  parse: () => parse4,
  parseExpressionAt: () => parseExpressionAt2,
  tokContexts: () => types,
  tokTypes: () => types$1,
  tokenizer: () => tokenizer2,
  version: () => version
});
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code3, set) {
  var pos = 65536;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code3) {
      return false;
    }
    pos += set[i + 1];
    if (pos >= code3) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code3, astral) {
  if (code3 < 65) {
    return code3 === 36;
  }
  if (code3 < 91) {
    return true;
  }
  if (code3 < 97) {
    return code3 === 95;
  }
  if (code3 < 123) {
    return true;
  }
  if (code3 <= 65535) {
    return code3 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code3));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code3, astralIdentifierStartCodes);
}
function isIdentifierChar(code3, astral) {
  if (code3 < 48) {
    return code3 === 36;
  }
  if (code3 < 58) {
    return true;
  }
  if (code3 < 65) {
    return false;
  }
  if (code3 < 91) {
    return true;
  }
  if (code3 < 97) {
    return code3 === 95;
  }
  if (code3 < 123) {
    return true;
  }
  if (code3 <= 65535) {
    return code3 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code3));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code3, astralIdentifierStartCodes) || isInAstralSet(code3, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name2, prec) {
  return new TokenType(name2, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name2, options) {
  if (options === void 0) options = {};
  options.keyword = name2;
  return keywords[name2] = new TokenType(name2, options);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code3) {
  return code3 === 10 || code3 === 13 || code3 === 8232 || code3 === 8233;
}
function nextLineBreak(code3, from, end) {
  if (end === void 0) end = code3.length;
  for (var i = from; i < end; i++) {
    var next = code3.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end - 1 && next === 13 && code3.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty2 = ref.hasOwnProperty;
var toString2 = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty2.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString2.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code3) {
  if (code3 <= 65535) {
    return String.fromCharCode(code3);
  }
  code3 -= 65536;
  return String.fromCharCode((code3 >> 10) + 55296, (code3 & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line2, col) {
  this.line = line2;
  this.column = col;
};
Position.prototype.offset = function offset(n) {
  return new Position(this.line, this.column + n);
};
var SourceLocation = function SourceLocation2(p, start3, end) {
  this.start = start3;
  this.end = end;
  if (p.sourceFile !== null) {
    this.source = p.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line2 = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line2, offset2 - cur);
    }
    ++line2;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options = {};
  for (var opt in defaultOptions) {
    options[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options.ecmaVersion === "latest") {
    options.ecmaVersion = 1e8;
  } else if (options.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options.ecmaVersion = 11;
  } else if (options.ecmaVersion >= 2015) {
    options.ecmaVersion -= 2009;
  }
  if (options.allowReserved == null) {
    options.allowReserved = options.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options.allowHashBang = options.ecmaVersion >= 14;
  }
  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options.onComment)) {
    options.onComment = pushComment(options, options.onComment);
  }
  return options;
}
function pushComment(options, array) {
  return function(block, text7, start3, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text7,
      start: start3,
      end
    };
    if (options.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options.ranges) {
      comment.range = [start3, end];
    }
    array.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options.allowReserved !== true) {
    reserved = reservedWords[options.ecmaVersion >= 6 ? 6 : options.ecmaVersion === 5 ? 5 : 3];
    if (options.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse2() {
  var node2 = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node2);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var scope = this.scopeStack[i];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend2() {
  var plugins = [], len = arguments.length;
  while (len--) plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse3(input, options) {
  return new this(options, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options) {
  var parser = new this(options, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options) {
  return new this(options, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start3) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start3;
    start3 += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start3));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start3 + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start3 += match[0].length;
    skipWhiteSpace.lastIndex = start3;
    start3 += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start3] === ";") {
      start3++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name2) {
  return this.type === types$1.name && this.value === name2 && !this.containsEsc;
};
pp$9.eatContextual = function(name2) {
  if (!this.isContextual(name2)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name2) {
  if (!this.eatContextual(name2)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node2) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node2.body) {
    node2.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node2.body.push(stmt);
  }
  if (this.inModule) {
    for (var i = 0, list3 = Object.keys(this.undefinedExports); i < list3.length; i += 1) {
      var name2 = list3[i];
      this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node2.body);
  this.next();
  node2.sourceType = this.options.sourceType;
  return this.finishNode(node2, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node2 = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node2, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node2);
    case types$1._do:
      return this.parseDoStatement(node2);
    case types$1._for:
      return this.parseForStatement(node2);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node2, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node2, true);
    case types$1._if:
      return this.parseIfStatement(node2);
    case types$1._return:
      return this.parseReturnStatement(node2);
    case types$1._switch:
      return this.parseSwitchStatement(node2);
    case types$1._throw:
      return this.parseThrowStatement(node2);
    case types$1._try:
      return this.parseTryStatement(node2);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node2, kind);
    case types$1._while:
      return this.parseWhileStatement(node2);
    case types$1._with:
      return this.parseWithStatement(node2);
    case types$1.braceL:
      return this.parseBlock(true, node2);
    case types$1.semi:
      return this.parseEmptyStatement(node2);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node2, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node2) : this.parseExport(node2, exports);
    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node2, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node2, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node2, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node2, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node2.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node2.label == null || lab.name === node2.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node2.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node2.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node2, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node2) {
  this.next();
  this.semicolon();
  return this.finishNode(node2, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node2) {
  this.next();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node2.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node2, "DoWhileStatement");
};
pp$8.parseForStatement = function(node2) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node2.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node2, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node2, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node2.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init2, false, refDestructuringErrors);
    this.checkLValPattern(init2);
    return this.parseForIn(node2, init2);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node2, init2);
};
pp$8.parseFunctionStatement = function(node2, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node2, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  node2.consequent = this.parseStatement("if");
  node2.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node2, "IfStatement");
};
pp$8.parseReturnStatement = function(node2) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node2.argument = null;
  } else {
    node2.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node2, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node2) {
  this.next();
  node2.discriminant = this.parseParenExpression();
  node2.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node2.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node2, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node2) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node2.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node2, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseTryStatement = function(node2) {
  this.next();
  node2.block = this.parseBlock();
  node2.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node2.handler = this.finishNode(clause, "CatchClause");
  }
  node2.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node2.handler && !node2.finalizer) {
    this.raise(node2.start, "Missing catch or finally clause");
  }
  return this.finishNode(node2, "TryStatement");
};
pp$8.parseVarStatement = function(node2, kind) {
  this.next();
  this.parseVar(node2, false, kind);
  this.semicolon();
  return this.finishNode(node2, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node2) {
  this.next();
  node2.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node2.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node2, "WhileStatement");
};
pp$8.parseWithStatement = function(node2) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node2.object = this.parseParenExpression();
  node2.body = this.parseStatement("with");
  return this.finishNode(node2, "WithStatement");
};
pp$8.parseEmptyStatement = function(node2) {
  this.next();
  return this.finishNode(node2, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node2, maybeName, expr, context) {
  for (var i$1 = 0, list3 = this.labels; i$1 < list3.length; i$1 += 1) {
    var label = list3[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node2.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node2.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node2.label = expr;
  return this.finishNode(node2, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node2, expr) {
  node2.expression = expr;
  this.semicolon();
  return this.finishNode(node2, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node2, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node2 === void 0) node2 = this.startNode();
  node2.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node2, "BlockStatement");
};
pp$8.parseFor = function(node2, init2) {
  node2.init = init2;
  this.expect(types$1.semi);
  node2.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node2.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, "ForStatement");
};
pp$8.parseForIn = function(node2, init2) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init2.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node2.left = init2;
  node2.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node2.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node2, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node2, isFor, kind) {
  node2.declarations = [];
  node2.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node2.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node2;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node2, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node2.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node2.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node2.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node2.id, this.strict || node2.generator || node2.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node2.async, node2.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node2.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node2);
  this.parseFunctionBody(node2, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node2) {
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node2, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node2, isStatement);
  this.parseClassSuper(node2);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element2 = this.parseClassElement(node2.superClass !== null);
    if (element2) {
      classBody.body.push(element2);
      if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
        if (hadConstructor) {
          this.raise(element2.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
        this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node2.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node2, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node2 = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node2);
      return node2;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node2.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node2.computed = false;
    node2.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node2.key.name = keyName;
    this.finishNode(node2.key, "Identifier");
  } else {
    this.parseClassElementName(node2);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node2.static && checkKeyName(node2, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node2.key.start, "Constructor can't have get/set modifier");
    }
    node2.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node2, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node2);
  }
  return node2;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element2) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element2.computed = false;
    element2.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element2);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node2) {
  node2.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node2.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node2, "StaticBlock");
};
pp$8.parseClassId = function(node2, isStatement) {
  if (this.type === types$1.name) {
    node2.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node2.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node2.id = null;
  }
};
pp$8.parseClassSuper = function(node2) {
  node2.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element2);
  return element2.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id2 = used[i];
    if (!hasOwn(declared, id2.name)) {
      if (parent) {
        parent.used.push(id2);
      } else {
        this.raiseRecoverable(id2.start, "Private field '#" + id2.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element2) {
  var name2 = element2.key.name;
  var curr = privateNameMap[name2];
  var next = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node2, name2) {
  var computed = node2.computed;
  var key = node2.key;
  return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
}
pp$8.parseExport = function(node2, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node2.exported = this.parseModuleExportName();
        this.checkExport(exports, node2.exported, this.lastTokStart);
      } else {
        node2.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node2.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node2, "ExportAllDeclaration");
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) {
        this.next();
      }
      node2.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      node2.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node2.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node2, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node2.declaration = this.parseStatement(null);
    if (node2.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node2.declaration.declarations);
    } else {
      this.checkExport(exports, node2.declaration.id, node2.declaration.id.start);
    }
    node2.specifiers = [];
    node2.source = null;
  } else {
    node2.declaration = null;
    node2.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node2.source = this.parseExprAtom();
    } else {
      for (var i = 0, list3 = node2.specifiers; i < list3.length; i += 1) {
        var spec = list3[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node2.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node2, "ExportNamedDeclaration");
};
pp$8.checkExport = function(exports, name2, pos) {
  if (!exports) {
    return;
  }
  if (typeof name2 !== "string") {
    name2 = name2.type === "Identifier" ? name2.name : name2.value;
  }
  if (hasOwn(exports, name2)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
  }
  exports[name2] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i = 0, list3 = pat.properties; i < list3.length; i += 1) {
      var prop = list3[i];
      this.checkPatternExport(exports, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  } else if (type === "ParenthesizedExpression") {
    this.checkPatternExport(exports, pat.expression);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list3 = decls; i < list3.length; i += 1) {
    var decl = list3[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var node2 = this.startNode();
    node2.local = this.parseModuleExportName();
    node2.exported = this.eatContextual("as") ? this.parseModuleExportName() : node2.local;
    this.checkExport(
      exports,
      node2.exported,
      node2.exported.start
    );
    nodes.push(this.finishNode(node2, "ExportSpecifier"));
  }
  return nodes;
};
pp$8.parseImport = function(node2) {
  this.next();
  if (this.type === types$1.string) {
    node2.specifiers = empty$1;
    node2.source = this.parseExprAtom();
  } else {
    node2.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node2.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node2, "ImportDeclaration");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    var node2 = this.startNode();
    node2.local = this.parseIdent();
    this.checkLValSimple(node2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node2, "ImportDefaultSpecifier"));
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLValSimple(node$1.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var node$2 = this.startNode();
    node$2.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLValSimple(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node2, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node2) {
    switch (node2.type) {
      case "Identifier":
        if (this.inAsync && node2.name === "await") {
          this.raise(node2.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node2.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list3 = node2.properties; i < list3.length; i += 1) {
          var prop = list3[i];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node2.kind !== "init") {
          this.raise(node2.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node2.value, isBinding);
        break;
      case "ArrayExpression":
        node2.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node2.elements, isBinding);
        break;
      case "SpreadElement":
        node2.type = "RestElement";
        this.toAssignable(node2.argument, isBinding);
        if (node2.argument.type === "AssignmentPattern") {
          this.raise(node2.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node2.operator !== "=") {
          this.raise(node2.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node2.type = "AssignmentPattern";
        delete node2.operator;
        this.toAssignable(node2.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node2.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node2.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node2.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node2;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node2, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node2 = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node2.argument = this.parseBindingAtom();
  return this.finishNode(node2, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node2 = this.startNode();
        this.next();
        node2.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node2, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.right = this.parseMaybeAssign();
  return this.finishNode(node2, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list3 = expr.properties; i < list3.length; i += 1) {
        var prop = list3[i];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p) {
    return p.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types.f_expr) {
      this.context[index2] = types.f_expr_gen;
    } else {
      this.context[index2] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name2;
  switch (key.type) {
    case "Identifier":
      name2 = key.name;
      break;
    case "Literal":
      name2 = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name2 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name2 = "$" + name2;
  var other = propHash[name2];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name2] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node2.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node2, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node2.left = left;
    this.next();
    node2.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node2, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.test = expr;
    node2.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node2.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node2, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node2 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node2, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node2 = this.startNodeAt(startPos, startLoc);
  node2.left = left;
  node2.operator = op;
  node2.right = right;
  return this.finishNode(node2, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node2 = this.startNode(), update = this.type === types$1.incDec;
    node2.operator = this.value;
    node2.prefix = true;
    this.next();
    node2.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node2.argument);
    } else if (this.strict && node2.operator === "delete" && node2.argument.type === "Identifier") {
      this.raiseRecoverable(node2.start, "Deleting local variable in strict mode");
    } else if (node2.operator === "delete" && isPrivateFieldAccess(node2.argument)) {
      this.raiseRecoverable(node2.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node2, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if (forInit || this.privateNameStack.length === 0) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node2) {
  return node2.type === "MemberExpression" && node2.property.type === "PrivateIdentifier" || node2.type === "ChainExpression" && isPrivateFieldAccess(node2.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
  var optionalChained = false;
  while (true) {
    var element2 = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element2.optional) {
      optionalChained = true;
    }
    if (element2 === base2 || element2.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element2;
        element2 = this.finishNode(chainNode, "ChainExpression");
      }
      return element2;
    }
    base2 = element2;
  }
};
pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.object = base2;
    if (computed) {
      node2.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base2.type !== "Super") {
      node2.property = this.parsePrivateIdent();
    } else {
      node2.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node2.computed = !!computed;
    if (optionalSupported) {
      node2.optional = optional;
    }
    base2 = this.finishNode(node2, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base2;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional;
    }
    base2 = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base2;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base2 = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base2;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node2, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node2 = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node2.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node2, "Super");
    case types$1._this:
      node2 = this.startNode();
      this.next();
      return this.finishNode(node2, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id2 = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id2.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id2.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id2 = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id2], true, forInit);
        }
      }
      return id2;
    case types$1.regexp:
      var value = this.value;
      node2 = this.parseLiteral(value.value);
      node2.regex = { pattern: value.pattern, flags: value.flags };
      return node2;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node2 = this.startNode();
      node2.value = this.type === types$1._null ? null : this.type === types$1._true;
      node2.raw = this.type.keyword;
      this.next();
      return this.finishNode(node2, "Literal");
    case types$1.parenL:
      var start3 = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start3;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start3;
        }
      }
      return expr;
    case types$1.bracketL:
      node2 = this.startNode();
      this.next();
      node2.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node2, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node2 = this.startNode();
      this.next();
      return this.parseFunction(node2, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport();
      } else {
        return this.unexpected();
      }
    default:
      this.unexpected();
  }
};
pp$5.parseExprImport = function() {
  var node2 = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  var meta = this.parseIdent(true);
  switch (this.type) {
    case types$1.parenL:
      return this.parseDynamicImport(node2);
    case types$1.dot:
      node2.meta = meta;
      return this.parseImportMeta(node2);
    default:
      this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node2) {
  this.next();
  node2.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node2, "ImportExpression");
};
pp$5.parseImportMeta = function(node2) {
  this.next();
  var containsEsc = this.containsEsc;
  node2.property = this.parseIdent(true);
  if (node2.property.name !== "meta") {
    this.raiseRecoverable(node2.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node2.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node2.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node2, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node2 = this.startNode();
  node2.value = value;
  node2.raw = this.input.slice(this.start, this.end);
  if (node2.raw.charCodeAt(node2.raw.length - 1) === 110) {
    node2.bigint = node2.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node2, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node2 = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node2.meta = meta;
    var containsEsc = this.containsEsc;
    node2.property = this.parseIdent(true);
    if (node2.property.name !== "target") {
      this.raiseRecoverable(node2.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node2.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node2.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node2, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
  node2.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
  if (isImport && node2.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types$1.parenL)) {
    node2.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node2.arguments = empty;
  }
  return this.finishNode(node2, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0) ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node2 = this.startNode();
  this.next();
  node2.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node2.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node2.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node2.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node2, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node2 = this.startNode(), first = true, propHash = {};
  node2.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node2.properties.push(prop);
  }
  return this.finishNode(node2, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start3 = prop.value.start;
      if (prop.kind === "get") {
        this.raiseRecoverable(start3, "getter should have no params");
      } else {
        this.raiseRecoverable(start3, "setter should have exactly one param");
      }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
      }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node2) {
  node2.id = null;
  if (this.options.ecmaVersion >= 6) {
    node2.generator = node2.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node2 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 6) {
    node2.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node2.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node2.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node2, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node2, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node2);
  if (this.options.ecmaVersion >= 8) {
    node2.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node2.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node2, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node2, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node2, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node2.body = this.parseMaybeAssign(forInit);
    node2.expression = true;
    this.checkParams(node2, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node2.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node2.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node2, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node2.params));
    if (this.strict && node2.id) {
      this.checkLValSimple(node2.id, BIND_OUTSIDE);
    }
    node2.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node2.expression = false;
    this.adaptDirectivePrologue(node2.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list3 = params; i < list3.length; i += 1) {
    var param = list3[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node2, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list3 = node2.params; i < list3.length; i += 1) {
    var param = list3[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start3 = ref2.start;
  var end = ref2.end;
  var name2 = ref2.name;
  if (this.inGenerator && name2 === "yield") {
    this.raiseRecoverable(start3, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name2 === "await") {
    this.raiseRecoverable(start3, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
    this.raiseRecoverable(start3, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
    this.raise(start3, "Cannot use " + name2 + " in class static initialization block");
  }
  if (this.keywords.test(name2)) {
    this.raise(start3, "Unexpected keyword '" + name2 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start3, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name2)) {
    if (!this.inAsync && name2 === "await") {
      this.raiseRecoverable(start3, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start3, "The keyword '" + name2 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node2 = this.startNode();
  if (this.type === types$1.name) {
    node2.name = this.value;
  } else if (this.type.keyword) {
    node2.name = this.type.keyword;
    if ((node2.name === "class" || node2.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next(!!liberal);
  this.finishNode(node2, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node2);
    if (node2.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node2.start;
    }
  }
  return node2;
};
pp$5.parsePrivateIdent = function() {
  var node2 = this.startNode();
  if (this.type === types$1.privateId) {
    node2.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node2, "PrivateIdentifier");
  if (this.privateNameStack.length === 0) {
    this.raise(node2.start, "Private field '#" + node2.name + "' must be declared in an enclosing class");
  } else {
    this.privateNameStack[this.privateNameStack.length - 1].used.push(node2);
  }
  return node2;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node2.delegate = false;
    node2.argument = null;
  } else {
    node2.delegate = this.eat(types$1.star);
    node2.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node2, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node2 = this.startNode();
  this.next();
  node2.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node2, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name2, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
    scope.lexical.push(name2);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name2];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name2);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name2) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
    }
    scope$2.functions.push(name2);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name2);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id2) {
  if (this.scopeStack[0].lexical.indexOf(id2.name) === -1 && this.scopeStack[0].var.indexOf(id2.name) === -1) {
    this.undefinedExports[id2.name] = id2;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node2, type, pos, loc) {
  node2.type = type;
  node2.end = pos;
  if (this.options.locations) {
    node2.loc.end = loc;
  }
  if (this.options.ranges) {
    node2.range[1] = pos;
  }
  return node2;
}
pp$2.finishNode = function(node2, type) {
  return finishNodeAt.call(this, node2, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node2, type, pos, loc) {
  return finishNodeAt.call(this, node2, type, pos, loc);
};
pp$2.copyNode = function(node2) {
  var newNode = new Node(this, node2.start, this.startLoc);
  for (var prop in node2) {
    newNode[prop] = node2[prop];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Kawi Nag_Mundari Nagm";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d.nonBinary.Script_Extensions = d.nonBinary.Script;
  d.nonBinary.gc = d.nonBinary.General_Category;
  d.nonBinary.sc = d.nonBinary.Script;
  d.nonBinary.scx = d.nonBinary.Script_Extensions;
}
for (i = 0, list3 = [9, 10, 11, 12, 13, 14]; i < list3.length; i += 1) {
  ecmaVersion = list3[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list3;
var pp$1 = Parser.prototype;
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start3, pattern, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start3 | 0;
  this.source = pattern + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1;
  }
  var c = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l) {
    return c;
  }
  var next = s.charCodeAt(i + 1);
  return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l;
  }
  var c = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0) forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list3 = state.backReferenceNames; i < list3.length; i += 1) {
    var name2 = list3[i];
    if (state.groupNames.indexOf(name2) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    this.regexp_alternative(state);
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start3 = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start3;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start3;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0) noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start3 = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start3;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start3 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start3;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start3 = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    ) && state.eat(
      58
      /* : */
    )) {
      this.regexp_disjunction(state);
      if (state.eat(
        41
        /* ) */
      )) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start3;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start3 = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start3;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return;
    }
    state.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start3 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start3;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start3 = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start3;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start3 = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n = state.lastIntValue;
    if (state.switchU) {
      if (n > state.maxBackReference) {
        state.maxBackReference = n;
      }
      return true;
    }
    if (n <= state.numCapturingParens) {
      return true;
    }
    state.pos = start3;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start3 = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start3;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0) forceU = false;
  var start3 = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail2 = state.lastIntValue;
          if (trail2 >= 56320 && trail2 <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail2 - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start3;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true;
  }
  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    if (state.eat(
      123
      /* { */
    ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(
      125
      /* } */
    )) {
      return true;
    }
    state.raise("Invalid property name");
  }
  return false;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start3 = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name2 = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name2, value);
      return true;
    }
  }
  state.pos = start3;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true;
  }
  return false;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name2].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue)) {
    state.raise("Invalid property name");
  }
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    state.eat(
      94
      /* ^ */
    );
    this.regexp_classRanges(state);
    if (state.eat(
      93
      /* ] */
    )) {
      return true;
    }
    state.raise("Unterminated character class");
  }
  return false;
};
pp$1.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start3 = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start3;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start3 = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start3;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start3 = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start3;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start3 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start3;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start3 = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start3;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start3 = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start3;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations) {
    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);
  }
  if (p.options.ranges) {
    this.range = [p.start, p.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code3) {
  if (isIdentifierStart(code3, this.options.ecmaVersion >= 6) || code3 === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code3);
};
pp.fullCharCodeAtPos = function() {
  var code3 = this.input.charCodeAt(this.pos);
  if (code3 <= 55295 || code3 >= 56320) {
    return code3;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code3 : (code3 << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start3 = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start3; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start3 + 2, end),
      start3,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start3 = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start3 + startSkip, this.pos),
      start3,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:
      case 8232:
      case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code3) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code3 === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code3 === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code3) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code3) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code3 === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code3 === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code3) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code3) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code3) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code3) {
    size = code3 === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code3 === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code3) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code3 === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code3 === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code3 = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code3 = this.fullCharCodeAtPos();
    if (isIdentifierStart(code3, true) || code3 === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code3) + "'");
};
pp.getTokenFromCode = function(code3) {
  switch (code3) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
    case 46:
      return this.readToken_dot();
    // Punctuation tokens.
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    // Quotes produce strings.
    case 34:
    case 39:
      return this.readString(code3);
    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code3);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code3);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code3);
    case 60:
    case 62:
      return this.readToken_lt_gt(code3);
    case 61:
    case 33:
      return this.readToken_eq_excl(code3);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code3) + "'");
};
pp.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start3 = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start3, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start3, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start3, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start3, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start3 = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i, ++this.pos) {
    var code3 = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code3 === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code3;
      continue;
    }
    if (code3 >= 97) {
      val = code3 - 97 + 10;
    } else if (code3 >= 65) {
      val = code3 - 65 + 10;
    } else if (code3 >= 48 && code3 <= 57) {
      val = code3 - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code3;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start3 || len != null && this.pos - start3 !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start3 = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start3, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start3 = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start3, "Invalid number");
  }
  var octal = this.pos - start3 >= 2 && this.input.charCodeAt(start3) === 48;
  if (octal && this.strict) {
    this.raise(start3, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start3, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start3, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start3, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start3, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code3;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code3 = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code3 > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code3 = this.readHexChar(4);
  }
  return code3;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position2, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position2, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      // falls through
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    // 'n' -> '\n'
    case 114:
      return "\r";
    // 'r' -> '\r'
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    // 'x'
    case 117:
      return codePointToString(this.readCodePoint());
    // 'u'
    case 116:
      return "	";
    // 't' -> '\t'
    case 98:
      return "\b";
    // 'b' -> '\b'
    case 118:
      return "\v";
    // 'v' -> '\u000b'
    case 102:
      return "\f";
    // 'f' -> '\f'
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    // '\r\n'
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords[word];
  }
  return this.finishToken(type, word);
};
var version = "8.8.2";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse4(input, options) {
  return Parser.parse(input, options);
}
function parseExpressionAt2(input, pos, options) {
  return Parser.parseExpressionAt(input, pos, options);
}
function tokenizer2(input, options) {
  return Parser.tokenizer(input, options);
}

// ../../../node_modules/.pnpm/micromark-extension-mdxjs@1.0.1/node_modules/micromark-extension-mdxjs/index.js
var import_acorn_jsx = __toESM(require_acorn_jsx(), 1);

// ../../../node_modules/.pnpm/unist-util-position-from-estree@1.1.2/node_modules/unist-util-position-from-estree/lib/index.js
function positionFromEstree(node2) {
  const nodeLike = node2 || {};
  const loc = nodeLike.loc || {};
  const range = nodeLike.range || [0, 0];
  const startColumn = loc.start ? numberOrUndefined(loc.start.column) : void 0;
  const endColumn = loc.end ? numberOrUndefined(loc.end.column) : void 0;
  return {
    start: {
      // @ts-expect-error: return no point / no position next major.
      line: loc.start ? numberOrUndefined(loc.start.line) : void 0,
      // @ts-expect-error: return no point / no position next major.
      column: startColumn === void 0 ? void 0 : startColumn + 1,
      offset: numberOrUndefined(range[0] || nodeLike.start)
    },
    end: {
      // @ts-expect-error: return no point / no position next major.
      line: loc.end ? numberOrUndefined(loc.end.line) : void 0,
      // @ts-expect-error: return no point / no position next major.
      column: endColumn === void 0 ? void 0 : endColumn + 1,
      offset: numberOrUndefined(range[1] || nodeLike.end)
    }
  };
}
function numberOrUndefined(value) {
  return typeof value === "number" && value > -1 ? value : void 0;
}

// ../../../node_modules/.pnpm/estree-util-visit@1.2.1/node_modules/estree-util-visit/lib/color.browser.js
function color2(d) {
  return d;
}

// ../../../node_modules/.pnpm/estree-util-visit@1.2.1/node_modules/estree-util-visit/lib/index.js
var own4 = {}.hasOwnProperty;
var CONTINUE2 = Symbol("continue");
var EXIT2 = Symbol("exit");
var SKIP2 = Symbol("skip");
function visit2(tree, visitor) {
  let enter;
  let leave;
  if (typeof visitor === "function") {
    enter = visitor;
  } else if (visitor && typeof visitor === "object") {
    if (visitor.enter) enter = visitor.enter;
    if (visitor.leave) leave = visitor.leave;
  }
  build(tree, null, null, [])();
  function build(node2, key, index2, parents) {
    if (nodelike(node2)) {
      visit3.displayName = "node (" + color2(node2.type) + ")";
    }
    return visit3;
    function visit3() {
      const result = enter ? toResult2(enter(node2, key, index2, parents)) : [];
      if (result[0] === EXIT2) {
        return result;
      }
      if (result[0] !== SKIP2) {
        let cKey;
        for (cKey in node2) {
          if (own4.call(node2, cKey) && node2[cKey] && typeof node2[cKey] === "object" && // @ts-expect-error: custom esast extension.
          cKey !== "data" && // @ts-expect-error: custom esast extension.
          cKey !== "position") {
            const grandparents = parents.concat(node2);
            const value = node2[cKey];
            if (Array.isArray(value)) {
              const nodes = (
                /** @type {Array<unknown>} */
                value
              );
              let cIndex = 0;
              while (cIndex > -1 && cIndex < nodes.length) {
                const subvalue = nodes[cIndex];
                if (nodelike(subvalue)) {
                  const subresult = build(
                    subvalue,
                    cKey,
                    cIndex,
                    grandparents
                  )();
                  if (subresult[0] === EXIT2) return subresult;
                  cIndex = typeof subresult[1] === "number" ? subresult[1] : cIndex + 1;
                } else {
                  cIndex++;
                }
              }
            } else if (nodelike(value)) {
              const subresult = build(value, cKey, null, grandparents)();
              if (subresult[0] === EXIT2) return subresult;
            }
          }
        }
      }
      return leave ? toResult2(leave(node2, key, index2, parents)) : result;
    }
  }
}
function toResult2(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "number") {
    return [CONTINUE2, value];
  }
  return [value];
}
function nodelike(value) {
  return Boolean(
    value && typeof value === "object" && "type" in value && typeof value.type === "string" && value.type.length > 0
  );
}

// ../../../node_modules/.pnpm/micromark-util-events-to-acorn@1.2.3/node_modules/micromark-util-events-to-acorn/index.js
function eventsToAcorn(events, options) {
  const prefix = options.prefix || "";
  const suffix = options.suffix || "";
  const acornOptions = Object.assign({}, options.acornOptions);
  const comments = [];
  const tokens = [];
  const onComment = acornOptions.onComment;
  const onToken = acornOptions.onToken;
  let swallow = false;
  let estree;
  let exception;
  const acornConfig = Object.assign({}, acornOptions, {
    onComment: comments,
    preserveParens: true
  });
  if (onToken) {
    acornConfig.onToken = tokens;
  }
  const collection = collect(events, [
    "lineEnding",
    // To do: these should be passed by users in parameters.
    "expressionChunk",
    // From tests.
    "mdxFlowExpressionChunk",
    // Flow chunk.
    "mdxTextExpressionChunk",
    // Text chunk.
    // JSX:
    "mdxJsxTextTagExpressionAttributeValue",
    "mdxJsxTextTagAttributeValueExpressionValue",
    "mdxJsxFlowTagExpressionAttributeValue",
    "mdxJsxFlowTagAttributeValueExpressionValue",
    // ESM:
    "mdxjsEsmData"
  ]);
  const source2 = collection.value;
  const value = prefix + source2 + suffix;
  const isEmptyExpression = options.expression && empty2(source2);
  if (isEmptyExpression && !options.allowEmpty) {
    throw new VFileMessage(
      "Unexpected empty expression",
      parseOffsetToUnistPoint(0),
      "micromark-extension-mdx-expression:unexpected-empty-expression"
    );
  }
  try {
    estree = options.expression && !isEmptyExpression ? options.acorn.parseExpressionAt(value, 0, acornConfig) : options.acorn.parse(value, acornConfig);
  } catch (error_) {
    const error = (
      /** @type {AcornError} */
      error_
    );
    const point3 = parseOffsetToUnistPoint(error.pos);
    error.message = String(error.message).replace(/ \(\d+:\d+\)$/, "");
    error.pos = point3.offset;
    error.loc = {
      line: point3.line,
      column: point3.column - 1
    };
    exception = error;
    swallow = error.raisedAt >= prefix.length + source2.length || // Broken comments are raised at their start, not their end.
    error.message === "Unterminated comment";
  }
  if (estree && options.expression && !isEmptyExpression) {
    if (empty2(value.slice(estree.end, value.length - suffix.length))) {
      estree = {
        type: "Program",
        start: 0,
        end: prefix.length + source2.length,
        // @ts-expect-error: It’s good.
        body: [
          {
            type: "ExpressionStatement",
            expression: estree,
            start: 0,
            end: prefix.length + source2.length
          }
        ],
        sourceType: "module",
        comments: []
      };
    } else {
      const point3 = parseOffsetToUnistPoint(estree.end);
      const error = (
        /** @type {AcornError} */
        new Error("Unexpected content after expression")
      );
      error.pos = point3.offset;
      error.loc = {
        line: point3.line,
        column: point3.column - 1
      };
      exception = error;
      estree = void 0;
    }
  }
  if (estree) {
    estree.comments = comments;
    visit2(estree, (esnode, field, index2, parents) => {
      let context = (
        /** @type {AcornNode | Array<AcornNode>} */
        parents[parents.length - 1]
      );
      let prop = field;
      if (esnode.type === "ParenthesizedExpression" && context && prop) {
        if (typeof index2 === "number") {
          context = context[prop];
          prop = index2;
        }
        context[prop] = esnode.expression;
      }
      fixPosition(esnode);
    });
    if (Array.isArray(onComment)) {
      onComment.push(...comments);
    } else if (typeof onComment === "function") {
      for (const comment of comments) {
        onComment(
          comment.type === "Block",
          comment.value,
          comment.start,
          comment.end,
          comment.loc.start,
          comment.loc.end
        );
      }
    }
    for (const token of tokens) {
      if (token.end <= prefix.length || token.start - prefix.length >= source2.length) {
        continue;
      }
      fixPosition(token);
      if (Array.isArray(onToken)) {
        onToken.push(token);
      } else {
        onToken(token);
      }
    }
  }
  return {
    estree,
    error: exception,
    swallow
  };
  function fixPosition(nodeOrToken) {
    const pointStart = parseOffsetToUnistPoint(nodeOrToken.start);
    const pointEnd = parseOffsetToUnistPoint(nodeOrToken.end);
    nodeOrToken.start = pointStart.offset;
    nodeOrToken.end = pointEnd.offset;
    nodeOrToken.loc = {
      start: {
        line: pointStart.line,
        column: pointStart.column - 1,
        offset: pointStart.offset
      },
      end: {
        line: pointEnd.line,
        column: pointEnd.column - 1,
        offset: pointEnd.offset
      }
    };
    nodeOrToken.range = [nodeOrToken.start, nodeOrToken.end];
  }
  function parseOffsetToUnistPoint(acornOffset) {
    let sourceOffset = acornOffset - prefix.length;
    if (sourceOffset < 0) {
      sourceOffset = 0;
    } else if (sourceOffset > source2.length) {
      sourceOffset = source2.length;
    }
    let point3 = relativeToPoint(collection.stops, sourceOffset);
    if (!point3) {
      point3 = {
        line: options.start.line,
        column: options.start.column,
        offset: options.start.offset
      };
    }
    return point3;
  }
}
function empty2(value) {
  return /^\s*$/.test(
    value.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, "")
  );
}
function collect(events, names) {
  const result = {
    value: "",
    stops: []
  };
  let index2 = -1;
  while (++index2 < events.length) {
    const event = events[index2];
    if (event[0] === "enter" && names.includes(event[1].type)) {
      const chunks = event[2].sliceStream(event[1]);
      while (chunks.length > 0 && chunks[0] === -1) {
        chunks.shift();
      }
      const value = serializeChunks2(chunks);
      result.stops.push([result.value.length, event[1].start]);
      result.value += value;
      result.stops.push([result.value.length, event[1].end]);
    }
  }
  return result;
}
function relativeToPoint(stops, relative) {
  let index2 = 0;
  while (index2 < stops.length && stops[index2][0] <= relative) {
    index2 += 1;
  }
  if (index2 === 0) {
    return void 0;
  }
  const [stopRelative, stopAbsolute] = stops[index2 - 1];
  const rest = relative - stopRelative;
  return {
    line: stopAbsolute.line,
    column: stopAbsolute.column + rest,
    offset: stopAbsolute.offset + rest
  };
}
function serializeChunks2(chunks) {
  let index2 = -1;
  const result = [];
  let atTab;
  while (++index2 < chunks.length) {
    const chunk = chunks[index2];
    let value;
    if (typeof chunk === "string") {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = "\r";
          break;
        }
        case -4: {
          value = "\n";
          break;
        }
        case -3: {
          value = "\r\n";
          break;
        }
        case -2: {
          value = "	";
          break;
        }
        /* c8 ignore next 6 */
        case -1: {
          if (atTab) continue;
          value = " ";
          break;
        }
        default: {
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join("");
}

// ../../../node_modules/.pnpm/micromark-factory-mdx-expression@1.0.7/node_modules/micromark-factory-mdx-expression/index.js
function factoryMdxExpression(effects, ok3, type, markerType, chunkType, acorn, acornOptions, addResult, spread, allowEmpty, allowLazy, startColumn) {
  const self2 = this;
  const eventStart = this.events.length + 3;
  const tail = this.events[this.events.length - 1];
  const initialPrefix = tail && tail[1].type === "linePrefix" ? tail[2].sliceSerialize(tail[1], true).length : 0;
  const prefixExpressionIndent = initialPrefix ? initialPrefix + 1 : 0;
  let balance = 1;
  let startPosition;
  let lastCrash;
  return start3;
  function start3(code3) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    startPosition = self2.now();
    return atBreak;
  }
  function atBreak(code3) {
    if (code3 === null) {
      throw lastCrash || new VFileMessage(
        "Unexpected end of file in expression, expected a corresponding closing brace for `{`",
        self2.now(),
        "micromark-extension-mdx-expression:unexpected-eof"
      );
    }
    if (code3 === 125) {
      return atClosingBrace(code3);
    }
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      const prefixTagIndent = startColumn ? startColumn + 4 - self2.now().column : 0;
      const indent2 = Math.max(prefixExpressionIndent, prefixTagIndent);
      return indent2 ? factorySpace(effects, atBreak, "linePrefix", indent2) : atBreak;
    }
    const now = self2.now();
    if (now.line !== startPosition.line && !allowLazy && self2.parser.lazy[now.line]) {
      throw new VFileMessage(
        "Unexpected end of file in expression, expected a corresponding closing brace for `{`",
        self2.now(),
        "micromark-extension-mdx-expression:unexpected-eof"
      );
    }
    effects.enter(chunkType);
    return inside(code3);
  }
  function inside(code3) {
    if (code3 === null || code3 === 125 || markdownLineEnding(code3)) {
      effects.exit(chunkType);
      return atBreak(code3);
    }
    if (code3 === 123 && !acorn) {
      effects.consume(code3);
      balance++;
      return inside;
    }
    effects.consume(code3);
    return inside;
  }
  function atClosingBrace(code3) {
    balance--;
    if (!acorn) {
      if (balance) {
        effects.enter(chunkType);
        effects.consume(code3);
        return inside;
      }
      effects.enter(markerType);
      effects.consume(code3);
      effects.exit(markerType);
      effects.exit(type);
      return ok3;
    }
    const result = eventsToAcorn(self2.events.slice(eventStart), {
      acorn,
      acornOptions,
      start: startPosition,
      expression: true,
      allowEmpty,
      prefix: spread ? "({" : "",
      suffix: spread ? "})" : ""
    });
    const estree = result.estree;
    if (spread && estree) {
      const head = estree.body[0];
      if (head.type !== "ExpressionStatement" || head.expression.type !== "ObjectExpression") {
        throw new VFileMessage(
          "Unexpected `" + head.type + "` in code: expected an object spread (`{...spread}`)",
          positionFromEstree(head).start,
          "micromark-extension-mdx-expression:non-spread"
        );
      } else if (head.expression.properties[1]) {
        throw new VFileMessage(
          "Unexpected extra content in spread: only a single spread is supported",
          positionFromEstree(head.expression.properties[1]).start,
          "micromark-extension-mdx-expression:spread-extra"
        );
      } else if (head.expression.properties[0] && head.expression.properties[0].type !== "SpreadElement") {
        throw new VFileMessage(
          "Unexpected `" + head.expression.properties[0].type + "` in code: only spread elements are supported",
          positionFromEstree(head.expression.properties[0]).start,
          "micromark-extension-mdx-expression:non-spread"
        );
      }
    }
    if (result.error) {
      lastCrash = new VFileMessage(
        "Could not parse expression with acorn: " + result.error.message,
        {
          // @ts-expect-error: fine.
          line: result.error.loc.line,
          // @ts-expect-error: fine.
          column: result.error.loc.column + 1,
          // @ts-expect-error: fine.
          offset: result.error.pos
        },
        "micromark-extension-mdx-expression:acorn"
      );
      if (code3 !== null && result.swallow) {
        effects.enter(chunkType);
        effects.consume(code3);
        return inside;
      }
      throw lastCrash;
    }
    effects.enter(markerType);
    effects.consume(code3);
    effects.exit(markerType);
    Object.assign(
      effects.exit(type),
      addResult ? {
        estree
      } : void 0
    );
    return ok3;
  }
}

// ../../../node_modules/.pnpm/micromark-extension-mdx-expression@1.0.8/node_modules/micromark-extension-mdx-expression/lib/syntax.js
function mdxExpression(options) {
  const options_ = options || {};
  const addResult = options_.addResult;
  const acorn = options_.acorn;
  const spread = options_.spread;
  let allowEmpty = options_.allowEmpty;
  let acornOptions;
  if (allowEmpty === null || allowEmpty === void 0) {
    allowEmpty = true;
  }
  if (acorn) {
    if (!acorn.parseExpressionAt) {
      throw new Error(
        "Expected a proper `acorn` instance passed in as `options.acorn`"
      );
    }
    acornOptions = Object.assign(
      {
        ecmaVersion: 2020,
        sourceType: "module"
      },
      options_.acornOptions
    );
  } else if (options_.acornOptions || options_.addResult) {
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  }
  return {
    flow: {
      [123]: {
        tokenize: tokenizeFlowExpression,
        concrete: true
      }
    },
    text: {
      [123]: {
        tokenize: tokenizeTextExpression
      }
    }
  };
  function tokenizeFlowExpression(effects, ok3, nok) {
    const self2 = this;
    return start3;
    function start3(code3) {
      return before(code3);
    }
    function before(code3) {
      return factoryMdxExpression.call(
        self2,
        effects,
        after,
        "mdxFlowExpression",
        "mdxFlowExpressionMarker",
        "mdxFlowExpressionChunk",
        acorn,
        acornOptions,
        addResult,
        spread,
        allowEmpty
      )(code3);
    }
    function after(code3) {
      return markdownSpace(code3) ? factorySpace(effects, end, "whitespace")(code3) : end(code3);
    }
    function end(code3) {
      return code3 === null || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
    }
  }
  function tokenizeTextExpression(effects, ok3) {
    const self2 = this;
    return start3;
    function start3(code3) {
      return factoryMdxExpression.call(
        self2,
        effects,
        ok3,
        "mdxTextExpression",
        "mdxTextExpressionMarker",
        "mdxTextExpressionChunk",
        acorn,
        acornOptions,
        addResult,
        spread,
        allowEmpty,
        true
      )(code3);
    }
  }
}

// ../../../node_modules/.pnpm/estree-util-is-identifier-name@2.1.0/node_modules/estree-util-is-identifier-name/lib/regex.js
var start = /[$A-Z_a-z\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/;
var cont = /[\d\u00B7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F]/;

// ../../../node_modules/.pnpm/estree-util-is-identifier-name@2.1.0/node_modules/estree-util-is-identifier-name/lib/index.js
function start2(code3) {
  return start.test(String.fromCharCode(code3));
}
function cont2(code3) {
  const character = String.fromCharCode(code3);
  return start.test(character) || cont.test(character);
}

// ../../../node_modules/.pnpm/micromark-extension-mdx-jsx@1.0.5/node_modules/micromark-extension-mdx-jsx/lib/factory-tag.js
function factoryTag(effects, ok3, nok, acorn, acornOptions, addResult, allowLazy, tagType, tagMarkerType, tagClosingMarkerType, tagSelfClosingMarker, tagNameType, tagNamePrimaryType, tagNameMemberMarkerType, tagNameMemberType, tagNamePrefixMarkerType, tagNameLocalType, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, tagAttributeType, tagAttributeNameType, tagAttributeNamePrimaryType, tagAttributeNamePrefixMarkerType, tagAttributeNameLocalType, tagAttributeInitializerMarkerType, tagAttributeValueLiteralType, tagAttributeValueLiteralMarkerType, tagAttributeValueLiteralValueType, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionValueType) {
  const self2 = this;
  let returnState;
  let marker;
  return start3;
  function start3(code3) {
    effects.enter(tagType);
    effects.enter(tagMarkerType);
    effects.consume(code3);
    effects.exit(tagMarkerType);
    return startAfter;
  }
  function startAfter(code3) {
    if (markdownLineEndingOrSpace(code3)) {
      return nok(code3);
    }
    returnState = nameBefore;
    return esWhitespaceStart(code3);
  }
  function nameBefore(code3) {
    if (code3 === 47) {
      effects.enter(tagClosingMarkerType);
      effects.consume(code3);
      effects.exit(tagClosingMarkerType);
      returnState = closingTagNameBefore;
      return esWhitespaceStart;
    }
    if (code3 === 62) {
      return tagEnd(code3);
    }
    if (code3 !== null && start2(code3)) {
      effects.enter(tagNameType);
      effects.enter(tagNamePrimaryType);
      effects.consume(code3);
      return primaryName;
    }
    crash(
      code3,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code3 === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : "")
    );
  }
  function closingTagNameBefore(code3) {
    if (code3 === 62) {
      return tagEnd(code3);
    }
    if (code3 !== null && start2(code3)) {
      effects.enter(tagNameType);
      effects.enter(tagNamePrimaryType);
      effects.consume(code3);
      return primaryName;
    }
    crash(
      code3,
      "before name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code3 === 42 || code3 === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function primaryName(code3) {
    if (code3 === 45 || code3 !== null && cont2(code3)) {
      effects.consume(code3);
      return primaryName;
    }
    if (code3 === 46 || code3 === 47 || code3 === 58 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagNamePrimaryType);
      returnState = primaryNameAfter;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "in name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code3 === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function primaryNameAfter(code3) {
    if (code3 === 46) {
      effects.enter(tagNameMemberMarkerType);
      effects.consume(code3);
      effects.exit(tagNameMemberMarkerType);
      returnState = memberNameBefore;
      return esWhitespaceStart;
    }
    if (code3 === 58) {
      effects.enter(tagNamePrefixMarkerType);
      effects.consume(code3);
      effects.exit(tagNamePrefixMarkerType);
      returnState = localNameBefore;
      return esWhitespaceStart;
    }
    if (code3 === 47 || code3 === 62 || code3 === 123 || code3 !== null && start2(code3)) {
      effects.exit(tagNameType);
      return attributeBefore(code3);
    }
    crash(
      code3,
      "after name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function memberNameBefore(code3) {
    if (code3 !== null && start2(code3)) {
      effects.enter(tagNameMemberType);
      effects.consume(code3);
      return memberName;
    }
    crash(
      code3,
      "before member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function memberName(code3) {
    if (code3 === 45 || code3 !== null && cont2(code3)) {
      effects.consume(code3);
      return memberName;
    }
    if (code3 === 46 || code3 === 47 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagNameMemberType);
      returnState = memberNameAfter;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "in member name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code3 === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function memberNameAfter(code3) {
    if (code3 === 46) {
      effects.enter(tagNameMemberMarkerType);
      effects.consume(code3);
      effects.exit(tagNameMemberMarkerType);
      returnState = memberNameBefore;
      return esWhitespaceStart;
    }
    if (code3 === 47 || code3 === 62 || code3 === 123 || code3 !== null && start2(code3)) {
      effects.exit(tagNameType);
      return attributeBefore(code3);
    }
    crash(
      code3,
      "after member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function localNameBefore(code3) {
    if (code3 !== null && start2(code3)) {
      effects.enter(tagNameLocalType);
      effects.consume(code3);
      return localName;
    }
    crash(
      code3,
      "before local name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code3 === 43 || code3 !== null && code3 > 46 && code3 < 58 ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  }
  function localName(code3) {
    if (code3 === 45 || code3 !== null && cont2(code3)) {
      effects.consume(code3);
      return localName;
    }
    if (code3 === 47 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagNameLocalType);
      returnState = localNameAfter;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "in local name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function localNameAfter(code3) {
    if (code3 === 47 || code3 === 62 || code3 === 123 || code3 !== null && start2(code3)) {
      effects.exit(tagNameType);
      return attributeBefore(code3);
    }
    crash(
      code3,
      "after local name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeBefore(code3) {
    if (code3 === 47) {
      effects.enter(tagSelfClosingMarker);
      effects.consume(code3);
      effects.exit(tagSelfClosingMarker);
      returnState = selfClosing;
      return esWhitespaceStart;
    }
    if (code3 === 62) {
      return tagEnd(code3);
    }
    if (code3 === 123) {
      return factoryMdxExpression.call(
        self2,
        effects,
        attributeExpressionAfter,
        tagExpressionAttributeType,
        tagExpressionAttributeMarkerType,
        tagExpressionAttributeValueType,
        acorn,
        acornOptions,
        addResult,
        true,
        false,
        allowLazy
      )(code3);
    }
    if (code3 !== null && start2(code3)) {
      effects.enter(tagAttributeType);
      effects.enter(tagAttributeNameType);
      effects.enter(tagAttributeNamePrimaryType);
      effects.consume(code3);
      return attributePrimaryName;
    }
    crash(
      code3,
      "before attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeExpressionAfter(code3) {
    returnState = attributeBefore;
    return esWhitespaceStart(code3);
  }
  function attributePrimaryName(code3) {
    if (code3 === 45 || code3 !== null && cont2(code3)) {
      effects.consume(code3);
      return attributePrimaryName;
    }
    if (code3 === 47 || code3 === 58 || code3 === 61 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagAttributeNamePrimaryType);
      returnState = attributePrimaryNameAfter;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "in attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function attributePrimaryNameAfter(code3) {
    if (code3 === 58) {
      effects.enter(tagAttributeNamePrefixMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeNamePrefixMarkerType);
      returnState = attributeLocalNameBefore;
      return esWhitespaceStart;
    }
    if (code3 === 61) {
      effects.exit(tagAttributeNameType);
      effects.enter(tagAttributeInitializerMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeInitializerMarkerType);
      returnState = attributeValueBefore;
      return esWhitespaceStart;
    }
    if (code3 === 47 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || code3 !== null && start2(code3)) {
      effects.exit(tagAttributeNameType);
      effects.exit(tagAttributeType);
      returnState = attributeBefore;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "after attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeLocalNameBefore(code3) {
    if (code3 !== null && start2(code3)) {
      effects.enter(tagAttributeNameLocalType);
      effects.consume(code3);
      return attributeLocalName;
    }
    crash(
      code3,
      "before local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeLocalName(code3) {
    if (code3 === 45 || code3 !== null && cont2(code3)) {
      effects.consume(code3);
      return attributeLocalName;
    }
    if (code3 === 47 || code3 === 61 || code3 === 62 || code3 === 123 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagAttributeNameLocalType);
      effects.exit(tagAttributeNameType);
      returnState = attributeLocalNameAfter;
      return esWhitespaceStart(code3);
    }
    crash(
      code3,
      "in local attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  }
  function attributeLocalNameAfter(code3) {
    if (code3 === 61) {
      effects.enter(tagAttributeInitializerMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeInitializerMarkerType);
      returnState = attributeValueBefore;
      return esWhitespaceStart;
    }
    if (code3 === 47 || code3 === 62 || code3 === 123 || code3 !== null && start2(code3)) {
      effects.exit(tagAttributeType);
      return attributeBefore(code3);
    }
    crash(
      code3,
      "after local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  }
  function attributeValueBefore(code3) {
    if (code3 === 34 || code3 === 39) {
      effects.enter(tagAttributeValueLiteralType);
      effects.enter(tagAttributeValueLiteralMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeValueLiteralMarkerType);
      marker = code3;
      return attributeValueQuotedStart;
    }
    if (code3 === 123) {
      return factoryMdxExpression.call(
        self2,
        effects,
        attributeValueExpressionAfter,
        tagAttributeValueExpressionType,
        tagAttributeValueExpressionMarkerType,
        tagAttributeValueExpressionValueType,
        acorn,
        acornOptions,
        addResult,
        false,
        false,
        allowLazy
      )(code3);
    }
    crash(
      code3,
      "before attribute value",
      "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (code3 === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : "")
    );
  }
  function attributeValueExpressionAfter(code3) {
    effects.exit(tagAttributeType);
    returnState = attributeBefore;
    return esWhitespaceStart(code3);
  }
  function attributeValueQuotedStart(code3) {
    if (code3 === null) {
      crash(
        code3,
        "in attribute value",
        "a corresponding closing quote `" + String.fromCodePoint(marker) + "`"
      );
    }
    if (code3 === marker) {
      effects.enter(tagAttributeValueLiteralMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeValueLiteralMarkerType);
      effects.exit(tagAttributeValueLiteralType);
      effects.exit(tagAttributeType);
      marker = void 0;
      returnState = attributeBefore;
      return esWhitespaceStart;
    }
    if (markdownLineEnding(code3)) {
      returnState = attributeValueQuotedStart;
      return esWhitespaceStart(code3);
    }
    effects.enter(tagAttributeValueLiteralValueType);
    return attributeValueQuoted(code3);
  }
  function attributeValueQuoted(code3) {
    if (code3 === null || code3 === marker || markdownLineEnding(code3)) {
      effects.exit(tagAttributeValueLiteralValueType);
      return attributeValueQuotedStart(code3);
    }
    effects.consume(code3);
    return attributeValueQuoted;
  }
  function selfClosing(code3) {
    if (code3 === 62) {
      return tagEnd(code3);
    }
    crash(
      code3,
      "after self-closing slash",
      "`>` to end the tag" + (code3 === 42 || code3 === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  }
  function tagEnd(code3) {
    effects.enter(tagMarkerType);
    effects.consume(code3);
    effects.exit(tagMarkerType);
    effects.exit(tagType);
    return ok3;
  }
  function esWhitespaceStart(code3) {
    if (markdownLineEnding(code3)) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return esWhitespaceEolAfter;
    }
    if (markdownSpace(code3) || unicodeWhitespace(code3)) {
      effects.enter("esWhitespace");
      return esWhitespaceInside(code3);
    }
    return returnState(code3);
  }
  function esWhitespaceInside(code3) {
    if (markdownLineEnding(code3)) {
      effects.exit("esWhitespace");
      return esWhitespaceStart(code3);
    }
    if (markdownSpace(code3) || unicodeWhitespace(code3)) {
      effects.consume(code3);
      return esWhitespaceInside;
    }
    effects.exit("esWhitespace");
    return returnState(code3);
  }
  function esWhitespaceEolAfter(code3) {
    if (!allowLazy && self2.parser.lazy[self2.now().line]) {
      throw new VFileMessage(
        "Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        self2.now(),
        "micromark-extension-mdx-jsx:unexpected-eof"
      );
    }
    return esWhitespaceStart(code3);
  }
  function crash(code3, at3, expect) {
    throw new VFileMessage(
      "Unexpected " + (code3 === null ? "end of file" : "character `" + (code3 === 96 ? "` ` `" : String.fromCodePoint(code3)) + "` (" + serializeCharCode(code3) + ")") + " " + at3 + ", expected " + expect,
      self2.now(),
      "micromark-extension-mdx-jsx:unexpected-" + (code3 === null ? "eof" : "character")
    );
  }
}
function serializeCharCode(code3) {
  return "U+" + code3.toString(16).toUpperCase().padStart(4, "0");
}

// ../../../node_modules/.pnpm/micromark-extension-mdx-jsx@1.0.5/node_modules/micromark-extension-mdx-jsx/lib/jsx-text.js
function jsxText(acorn, acornOptions, addResult) {
  return {
    tokenize: tokenizeJsxText
  };
  function tokenizeJsxText(effects, ok3, nok) {
    return factoryTag.call(
      this,
      effects,
      ok3,
      nok,
      acorn,
      acornOptions,
      addResult,
      true,
      "mdxJsxTextTag",
      "mdxJsxTextTagMarker",
      "mdxJsxTextTagClosingMarker",
      "mdxJsxTextTagSelfClosingMarker",
      "mdxJsxTextTagName",
      "mdxJsxTextTagNamePrimary",
      "mdxJsxTextTagNameMemberMarker",
      "mdxJsxTextTagNameMember",
      "mdxJsxTextTagNamePrefixMarker",
      "mdxJsxTextTagNameLocal",
      "mdxJsxTextTagExpressionAttribute",
      "mdxJsxTextTagExpressionAttributeMarker",
      "mdxJsxTextTagExpressionAttributeValue",
      "mdxJsxTextTagAttribute",
      "mdxJsxTextTagAttributeName",
      "mdxJsxTextTagAttributeNamePrimary",
      "mdxJsxTextTagAttributeNamePrefixMarker",
      "mdxJsxTextTagAttributeNameLocal",
      "mdxJsxTextTagAttributeInitializerMarker",
      "mdxJsxTextTagAttributeValueLiteral",
      "mdxJsxTextTagAttributeValueLiteralMarker",
      "mdxJsxTextTagAttributeValueLiteralValue",
      "mdxJsxTextTagAttributeValueExpression",
      "mdxJsxTextTagAttributeValueExpressionMarker",
      "mdxJsxTextTagAttributeValueExpressionValue"
    );
  }
}

// ../../../node_modules/.pnpm/micromark-extension-mdx-jsx@1.0.5/node_modules/micromark-extension-mdx-jsx/lib/jsx-flow.js
function jsxFlow(acorn, acornOptions, addResult) {
  return {
    tokenize: tokenizeJsxFlow,
    concrete: true
  };
  function tokenizeJsxFlow(effects, ok3, nok) {
    const self2 = this;
    return start3;
    function start3(code3) {
      return before(code3);
    }
    function before(code3) {
      return factoryTag.call(
        self2,
        effects,
        after,
        nok,
        acorn,
        acornOptions,
        addResult,
        false,
        "mdxJsxFlowTag",
        "mdxJsxFlowTagMarker",
        "mdxJsxFlowTagClosingMarker",
        "mdxJsxFlowTagSelfClosingMarker",
        "mdxJsxFlowTagName",
        "mdxJsxFlowTagNamePrimary",
        "mdxJsxFlowTagNameMemberMarker",
        "mdxJsxFlowTagNameMember",
        "mdxJsxFlowTagNamePrefixMarker",
        "mdxJsxFlowTagNameLocal",
        "mdxJsxFlowTagExpressionAttribute",
        "mdxJsxFlowTagExpressionAttributeMarker",
        "mdxJsxFlowTagExpressionAttributeValue",
        "mdxJsxFlowTagAttribute",
        "mdxJsxFlowTagAttributeName",
        "mdxJsxFlowTagAttributeNamePrimary",
        "mdxJsxFlowTagAttributeNamePrefixMarker",
        "mdxJsxFlowTagAttributeNameLocal",
        "mdxJsxFlowTagAttributeInitializerMarker",
        "mdxJsxFlowTagAttributeValueLiteral",
        "mdxJsxFlowTagAttributeValueLiteralMarker",
        "mdxJsxFlowTagAttributeValueLiteralValue",
        "mdxJsxFlowTagAttributeValueExpression",
        "mdxJsxFlowTagAttributeValueExpressionMarker",
        "mdxJsxFlowTagAttributeValueExpressionValue"
      )(code3);
    }
    function after(code3) {
      return markdownSpace(code3) ? factorySpace(effects, end, "whitespace")(code3) : end(code3);
    }
    function end(code3) {
      return code3 === 60 ? start3(code3) : code3 === null || markdownLineEnding(code3) ? ok3(code3) : nok(code3);
    }
  }
}

// ../../../node_modules/.pnpm/micromark-extension-mdx-jsx@1.0.5/node_modules/micromark-extension-mdx-jsx/lib/syntax.js
function mdxJsx(options) {
  const settings = options || {};
  const acorn = settings.acorn;
  let acornOptions;
  if (acorn) {
    if (!acorn.parse || !acorn.parseExpressionAt) {
      throw new Error(
        "Expected a proper `acorn` instance passed in as `options.acorn`"
      );
    }
    acornOptions = Object.assign(
      {
        ecmaVersion: 2020,
        sourceType: "module"
      },
      settings.acornOptions,
      {
        locations: true
      }
    );
  } else if (settings.acornOptions || settings.addResult) {
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  }
  return {
    flow: {
      [60]: jsxFlow(
        acorn || void 0,
        acornOptions,
        settings.addResult || false
      )
    },
    text: {
      [60]: jsxText(
        acorn || void 0,
        acornOptions,
        settings.addResult || false
      )
    }
  };
}

// ../../../node_modules/.pnpm/micromark-extension-mdx-md@1.0.1/node_modules/micromark-extension-mdx-md/index.js
var mdxMd = {
  disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] }
};

// ../../../node_modules/.pnpm/micromark-extension-mdxjs-esm@1.0.5/node_modules/micromark-extension-mdxjs-esm/lib/syntax.js
var blankLineBefore2 = {
  tokenize: tokenizeNextBlank,
  partial: true
};
var allowedAcornTypes = /* @__PURE__ */ new Set([
  "ExportAllDeclaration",
  "ExportDefaultDeclaration",
  "ExportNamedDeclaration",
  "ImportDeclaration"
]);
function mdxjsEsm(options) {
  const exportImportConstruct = {
    tokenize: tokenizeExportImport,
    concrete: true
  };
  if (!options || !options.acorn || !options.acorn.parse) {
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  }
  const acorn = options.acorn;
  const acornOptions = Object.assign(
    {
      ecmaVersion: 2020,
      sourceType: "module"
    },
    options.acornOptions
  );
  return {
    flow: {
      [101]: exportImportConstruct,
      [105]: exportImportConstruct
    }
  };
  function tokenizeExportImport(effects, ok3, nok) {
    const self2 = this;
    const definedModuleSpecifiers = self2.parser.definedModuleSpecifiers || (self2.parser.definedModuleSpecifiers = []);
    const eventStart = this.events.length + 1;
    let buffer2 = "";
    return self2.interrupt ? nok : start3;
    function start3(code3) {
      if (self2.now().column > 1) return nok(code3);
      effects.enter("mdxjsEsm");
      effects.enter("mdxjsEsmData");
      effects.consume(code3);
      buffer2 += String.fromCharCode(code3);
      return word;
    }
    function word(code3) {
      if (asciiAlpha(code3)) {
        effects.consume(code3);
        buffer2 += String.fromCharCode(code3);
        return word;
      }
      if ((buffer2 === "import" || buffer2 === "export") && code3 === 32) {
        effects.consume(code3);
        return inside;
      }
      return nok(code3);
    }
    function inside(code3) {
      if (code3 === null || markdownLineEnding(code3)) {
        effects.exit("mdxjsEsmData");
        return lineStart(code3);
      }
      effects.consume(code3);
      return inside;
    }
    function lineStart(code3) {
      if (code3 === null) {
        return atEnd(code3);
      }
      if (markdownLineEnding(code3)) {
        return effects.check(blankLineBefore2, atEnd, continuationStart)(code3);
      }
      effects.enter("mdxjsEsmData");
      return inside(code3);
    }
    function continuationStart(code3) {
      effects.enter("lineEnding");
      effects.consume(code3);
      effects.exit("lineEnding");
      return lineStart;
    }
    function atEnd(code3) {
      const result = eventsToAcorn(self2.events.slice(eventStart), {
        acorn,
        acornOptions,
        prefix: definedModuleSpecifiers.length > 0 ? "var " + definedModuleSpecifiers.join(",") + "\n" : ""
      });
      if (result.error) {
        if (code3 !== null && result.swallow) {
          return continuationStart(code3);
        }
        throw new VFileMessage(
          "Could not parse import/exports with acorn: " + String(result.error),
          {
            line: result.error.loc.line,
            column: result.error.loc.column + 1,
            offset: result.error.pos
          },
          "micromark-extension-mdxjs-esm:acorn"
        );
      }
      if (definedModuleSpecifiers.length > 0) {
        const declaration = result.estree.body.shift();
      }
      let index2 = -1;
      while (++index2 < result.estree.body.length) {
        const node2 = result.estree.body[index2];
        if (!allowedAcornTypes.has(node2.type)) {
          throw new VFileMessage(
            "Unexpected `" + node2.type + "` in code: only import/exports are supported",
            positionFromEstree(node2),
            "micromark-extension-mdxjs-esm:non-esm"
          );
        }
        if (node2.type === "ImportDeclaration" && !self2.interrupt) {
          let index3 = -1;
          while (++index3 < node2.specifiers.length) {
            const specifier = node2.specifiers[index3];
            definedModuleSpecifiers.push(specifier.local.name);
          }
        }
      }
      Object.assign(
        effects.exit("mdxjsEsm"),
        options.addResult ? {
          estree: result.estree
        } : void 0
      );
      return ok3(code3);
    }
  }
}
function tokenizeNextBlank(effects, ok3, nok) {
  return start3;
  function start3(code3) {
    effects.enter("lineEndingBlank");
    effects.consume(code3);
    effects.exit("lineEndingBlank");
    return effects.attempt(blankLine, ok3, nok);
  }
}

// ../../../node_modules/.pnpm/micromark-extension-mdxjs@1.0.1/node_modules/micromark-extension-mdxjs/index.js
function mdxjs(options) {
  const settings = Object.assign(
    {
      acorn: Parser.extend((0, import_acorn_jsx.default)()),
      acornOptions: { ecmaVersion: 2020, sourceType: "module" },
      addResult: true
    },
    options
  );
  return combineExtensions([
    mdxjsEsm(settings),
    mdxExpression(settings),
    mdxJsx(settings),
    mdxMd
  ]);
}

// ../../../node_modules/.pnpm/mdast-util-mdx-expression@1.3.2/node_modules/mdast-util-mdx-expression/lib/index.js
var mdxExpressionFromMarkdown = {
  enter: {
    mdxFlowExpression: enterMdxFlowExpression,
    mdxTextExpression: enterMdxTextExpression
  },
  exit: {
    mdxFlowExpression: exitMdxExpression,
    mdxFlowExpressionChunk: exitMdxExpressionData,
    mdxTextExpression: exitMdxExpression,
    mdxTextExpressionChunk: exitMdxExpressionData
  }
};
var mdxExpressionToMarkdown = {
  handlers: {
    mdxFlowExpression: handleMdxExpression,
    mdxTextExpression: handleMdxExpression
  },
  unsafe: [
    { character: "{", inConstruct: ["phrasing"] },
    { atBreak: true, character: "{" }
  ]
};
function enterMdxFlowExpression(token) {
  this.enter({ type: "mdxFlowExpression", value: "" }, token);
  this.buffer();
}
function enterMdxTextExpression(token) {
  this.enter({ type: "mdxTextExpression", value: "" }, token);
  this.buffer();
}
function exitMdxExpression(token) {
  const value = this.resume();
  const estree = token.estree;
  const node2 = (
    /** @type {MdxFlowExpression | MdxTextExpression} */
    this.exit(token)
  );
  node2.value = value;
  if (estree) {
    node2.data = { estree };
  }
}
function exitMdxExpressionData(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
function handleMdxExpression(node2) {
  const value = node2.value || "";
  return "{" + value + "}";
}

// ../../../node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js
function ccount(value, character) {
  const source2 = String(value);
  if (typeof character !== "string") {
    throw new TypeError("Expected character");
  }
  let count = 0;
  let index2 = source2.indexOf(character);
  while (index2 !== -1) {
    count++;
    index2 = source2.indexOf(character, index2 + character.length);
  }
  return count;
}

// ../../../node_modules/.pnpm/character-entities-legacy@3.0.0/node_modules/character-entities-legacy/index.js
var characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
];

// ../../../node_modules/.pnpm/character-reference-invalid@2.0.1/node_modules/character-reference-invalid/index.js
var characterReferenceInvalid = {
  0: "\uFFFD",
  128: "\u20AC",
  130: "\u201A",
  131: "\u0192",
  132: "\u201E",
  133: "\u2026",
  134: "\u2020",
  135: "\u2021",
  136: "\u02C6",
  137: "\u2030",
  138: "\u0160",
  139: "\u2039",
  140: "\u0152",
  142: "\u017D",
  145: "\u2018",
  146: "\u2019",
  147: "\u201C",
  148: "\u201D",
  149: "\u2022",
  150: "\u2013",
  151: "\u2014",
  152: "\u02DC",
  153: "\u2122",
  154: "\u0161",
  155: "\u203A",
  156: "\u0153",
  158: "\u017E",
  159: "\u0178"
};

// ../../../node_modules/.pnpm/is-decimal@2.0.1/node_modules/is-decimal/index.js
function isDecimal(character) {
  const code3 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code3 >= 48 && code3 <= 57;
}

// ../../../node_modules/.pnpm/is-hexadecimal@2.0.1/node_modules/is-hexadecimal/index.js
function isHexadecimal(character) {
  const code3 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code3 >= 97 && code3 <= 102 || code3 >= 65 && code3 <= 70 || code3 >= 48 && code3 <= 57;
}

// ../../../node_modules/.pnpm/is-alphabetical@2.0.1/node_modules/is-alphabetical/index.js
function isAlphabetical(character) {
  const code3 = typeof character === "string" ? character.charCodeAt(0) : character;
  return code3 >= 97 && code3 <= 122 || code3 >= 65 && code3 <= 90;
}

// ../../../node_modules/.pnpm/is-alphanumerical@2.0.1/node_modules/is-alphanumerical/index.js
function isAlphanumerical(character) {
  return isAlphabetical(character) || isDecimal(character);
}

// ../../../node_modules/.pnpm/parse-entities@4.0.1/node_modules/parse-entities/lib/index.js
var fromCharCode = String.fromCharCode;
var messages = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function parseEntities(value, options = {}) {
  const additional = typeof options.additional === "string" ? options.additional.charCodeAt(0) : options.additional;
  const result = [];
  let index2 = 0;
  let lines2 = -1;
  let queue = "";
  let point3;
  let indent2;
  if (options.position) {
    if ("start" in options.position || "indent" in options.position) {
      indent2 = options.position.indent;
      point3 = options.position.start;
    } else {
      point3 = options.position;
    }
  }
  let line2 = (point3 ? point3.line : 0) || 1;
  let column = (point3 ? point3.column : 0) || 1;
  let previous3 = now();
  let character;
  index2--;
  while (++index2 <= value.length) {
    if (character === 10) {
      column = (indent2 ? indent2[lines2] : 0) || 1;
    }
    character = value.charCodeAt(index2);
    if (character === 38) {
      const following = value.charCodeAt(index2 + 1);
      if (following === 9 || following === 10 || following === 12 || following === 32 || following === 38 || following === 60 || Number.isNaN(following) || additional && following === additional) {
        queue += fromCharCode(character);
        column++;
        continue;
      }
      const start3 = index2 + 1;
      let begin = start3;
      let end = start3;
      let type;
      if (following === 35) {
        end = ++begin;
        const following2 = value.charCodeAt(end);
        if (following2 === 88 || following2 === 120) {
          type = "hexadecimal";
          end = ++begin;
        } else {
          type = "decimal";
        }
      } else {
        type = "named";
      }
      let characterReferenceCharacters = "";
      let characterReference2 = "";
      let characters = "";
      const test = type === "named" ? isAlphanumerical : type === "decimal" ? isDecimal : isHexadecimal;
      end--;
      while (++end <= value.length) {
        const following2 = value.charCodeAt(end);
        if (!test(following2)) {
          break;
        }
        characters += fromCharCode(following2);
        if (type === "named" && characterEntitiesLegacy.includes(characters)) {
          characterReferenceCharacters = characters;
          characterReference2 = decodeNamedCharacterReference(characters);
        }
      }
      let terminated = value.charCodeAt(end) === 59;
      if (terminated) {
        end++;
        const namedReference = type === "named" ? decodeNamedCharacterReference(characters) : false;
        if (namedReference) {
          characterReferenceCharacters = characters;
          characterReference2 = namedReference;
        }
      }
      let diff2 = 1 + end - start3;
      let reference = "";
      if (!terminated && options.nonTerminated === false) {
      } else if (!characters) {
        if (type !== "named") {
          warning(4, diff2);
        }
      } else if (type === "named") {
        if (terminated && !characterReference2) {
          warning(5, 1);
        } else {
          if (characterReferenceCharacters !== characters) {
            end = begin + characterReferenceCharacters.length;
            diff2 = 1 + end - begin;
            terminated = false;
          }
          if (!terminated) {
            const reason = characterReferenceCharacters ? 1 : 3;
            if (options.attribute) {
              const following2 = value.charCodeAt(end);
              if (following2 === 61) {
                warning(reason, diff2);
                characterReference2 = "";
              } else if (isAlphanumerical(following2)) {
                characterReference2 = "";
              } else {
                warning(reason, diff2);
              }
            } else {
              warning(reason, diff2);
            }
          }
        }
        reference = characterReference2;
      } else {
        if (!terminated) {
          warning(2, diff2);
        }
        let referenceCode = Number.parseInt(
          characters,
          type === "hexadecimal" ? 16 : 10
        );
        if (prohibited(referenceCode)) {
          warning(7, diff2);
          reference = fromCharCode(
            65533
            /* `�` */
          );
        } else if (referenceCode in characterReferenceInvalid) {
          warning(6, diff2);
          reference = characterReferenceInvalid[referenceCode];
        } else {
          let output = "";
          if (disallowed(referenceCode)) {
            warning(6, diff2);
          }
          if (referenceCode > 65535) {
            referenceCode -= 65536;
            output += fromCharCode(referenceCode >>> (10 & 1023) | 55296);
            referenceCode = 56320 | referenceCode & 1023;
          }
          reference = output + fromCharCode(referenceCode);
        }
      }
      if (reference) {
        flush();
        previous3 = now();
        index2 = end - 1;
        column += end - start3 + 1;
        result.push(reference);
        const next = now();
        next.offset++;
        if (options.reference) {
          options.reference.call(
            options.referenceContext,
            reference,
            { start: previous3, end: next },
            value.slice(start3 - 1, end)
          );
        }
        previous3 = next;
      } else {
        characters = value.slice(start3 - 1, end);
        queue += characters;
        column += characters.length;
        index2 = end - 1;
      }
    } else {
      if (character === 10) {
        line2++;
        lines2++;
        column = 0;
      }
      if (Number.isNaN(character)) {
        flush();
      } else {
        queue += fromCharCode(character);
        column++;
      }
    }
  }
  return result.join("");
  function now() {
    return {
      line: line2,
      column,
      offset: index2 + ((point3 ? point3.offset : 0) || 0)
    };
  }
  function warning(code3, offset2) {
    let position2;
    if (options.warning) {
      position2 = now();
      position2.column += offset2;
      position2.offset += offset2;
      options.warning.call(
        options.warningContext,
        messages[code3],
        position2,
        code3
      );
    }
  }
  function flush() {
    if (queue) {
      result.push(queue);
      if (options.text) {
        options.text.call(options.textContext, queue, {
          start: previous3,
          end: now()
        });
      }
      queue = "";
    }
  }
}
function prohibited(code3) {
  return code3 >= 55296 && code3 <= 57343 || code3 > 1114111;
}
function disallowed(code3) {
  return code3 >= 1 && code3 <= 8 || code3 === 11 || code3 >= 13 && code3 <= 31 || code3 >= 127 && code3 <= 159 || code3 >= 64976 && code3 <= 65007 || (code3 & 65535) === 65535 || (code3 & 65535) === 65534;
}

// ../../../node_modules/.pnpm/stringify-entities@4.0.3/node_modules/stringify-entities/lib/core.js
function core(value, options) {
  value = value.replace(
    options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g,
    basic
  );
  if (options.subset || options.escapeOnly) {
    return value;
  }
  return value.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate).replace(
    // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
    /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
    basic
  );
  function surrogate(pair, index2, all2) {
    return options.format(
      (pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
      all2.charCodeAt(index2 + 2),
      options
    );
  }
  function basic(character, index2, all2) {
    return options.format(
      character.charCodeAt(0),
      all2.charCodeAt(index2 + 1),
      options
    );
  }
}
function charactersToExpression(subset) {
  const groups = [];
  let index2 = -1;
  while (++index2 < subset.length) {
    groups.push(subset[index2].replace(/[|\\{}()[\]^$+*?.]/g, "\\$&"));
  }
  return new RegExp("(?:" + groups.join("|") + ")", "g");
}

// ../../../node_modules/.pnpm/stringify-entities@4.0.3/node_modules/stringify-entities/lib/util/format-basic.js
function formatBasic(code3) {
  return "&#x" + code3.toString(16).toUpperCase() + ";";
}

// ../../../node_modules/.pnpm/stringify-entities@4.0.3/node_modules/stringify-entities/lib/index.js
function stringifyEntitiesLight(value, options) {
  return core(value, Object.assign({ format: formatBasic }, options));
}

// ../../../node_modules/.pnpm/mdast-util-mdx-jsx@2.1.2/node_modules/mdast-util-mdx-jsx/lib/index.js
function mdxJsxFromMarkdown() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: enterMdxJsxTag,
      mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagAttributeValueLiteral: buffer2,
      mdxJsxFlowTagAttributeValueExpression: buffer2,
      mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: enterMdxJsxTag,
      mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxTextTagAttributeValueLiteral: buffer2,
      mdxJsxTextTagAttributeValueExpression: buffer2,
      mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker
    },
    exit: {
      mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagExpressionAttributeValue: data2,
      mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxFlowTagAttributeValueLiteralValue: data2,
      mdxJsxFlowTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxFlowTagAttributeValueExpressionValue: data2,
      mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxFlowTag: exitMdxJsxTag,
      mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxTextTagExpressionAttributeValue: data2,
      mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxTextTagAttributeValueLiteralValue: data2,
      mdxJsxTextTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxTextTagAttributeValueExpressionValue: data2,
      mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: exitMdxJsxTag
    }
  };
  function buffer2() {
    this.buffer();
  }
  function data2(token) {
    this.config.enter.data.call(this, token);
    this.config.exit.data.call(this, token);
  }
  function enterMdxJsxTag(token) {
    const tag = {
      name: void 0,
      attributes: [],
      close: false,
      selfClosing: false,
      start: token.start,
      end: token.end
    };
    if (!this.getData("mdxJsxTagStack")) this.setData("mdxJsxTagStack", []);
    this.setData("mdxJsxTag", tag);
    this.buffer();
  }
  function enterMdxJsxTagClosingMarker(token) {
    const stack = (
      /** @type {Array<Tag>} */
      this.getData("mdxJsxTagStack")
    );
    if (stack.length === 0) {
      throw new VFileMessage(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash"
      );
    }
  }
  function enterMdxJsxTagAnyAttribute(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    if (tag.close) {
      throw new VFileMessage(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-attribute"
      );
    }
  }
  function enterMdxJsxTagSelfClosingMarker(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    if (tag.close) {
      throw new VFileMessage(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
    }
  }
  function exitMdxJsxTagClosingMarker() {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.close = true;
  }
  function exitMdxJsxTagNamePrimary(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.name = this.sliceSerialize(token);
  }
  function exitMdxJsxTagNameMember(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.name += "." + this.sliceSerialize(token);
  }
  function exitMdxJsxTagNameLocal(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.name += ":" + this.sliceSerialize(token);
  }
  function enterMdxJsxTagAttribute(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    enterMdxJsxTagAnyAttribute.call(this, token);
    tag.attributes.push({ type: "mdxJsxAttribute", name: "", value: null });
  }
  function enterMdxJsxTagExpressionAttribute(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    enterMdxJsxTagAnyAttribute.call(this, token);
    tag.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" });
    this.buffer();
  }
  function exitMdxJsxTagExpressionAttribute(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const tail = (
      /** @type {MdxJsxExpressionAttribute} */
      tag.attributes[tag.attributes.length - 1]
    );
    const estree = token.estree;
    tail.value = this.resume();
    if (estree) {
      tail.data = { estree };
    }
  }
  function exitMdxJsxTagAttributeNamePrimary(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const node2 = (
      /** @type {MdxJsxAttribute} */
      tag.attributes[tag.attributes.length - 1]
    );
    node2.name = this.sliceSerialize(token);
  }
  function exitMdxJsxTagAttributeNameLocal(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const node2 = (
      /** @type {MdxJsxAttribute} */
      tag.attributes[tag.attributes.length - 1]
    );
    node2.name += ":" + this.sliceSerialize(token);
  }
  function exitMdxJsxTagAttributeValueLiteral() {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.attributes[tag.attributes.length - 1].value = parseEntities(
      this.resume(),
      { nonTerminated: false }
    );
  }
  function exitMdxJsxTagAttributeValueExpression(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const tail = (
      /** @type {MdxJsxAttribute} */
      tag.attributes[tag.attributes.length - 1]
    );
    const node2 = { type: "mdxJsxAttributeValueExpression", value: this.resume() };
    const estree = token.estree;
    if (estree) {
      node2.data = { estree };
    }
    tail.value = node2;
  }
  function exitMdxJsxTagSelfClosingMarker() {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    tag.selfClosing = true;
  }
  function exitMdxJsxTag(token) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const stack = (
      /** @type {Array<Tag>} */
      this.getData("mdxJsxTagStack")
    );
    const tail = stack[stack.length - 1];
    if (tag.close && tail.name !== tag.name) {
      throw new VFileMessage(
        "Unexpected closing tag `" + serializeAbbreviatedTag(tag) + "`, expected corresponding closing tag for `" + serializeAbbreviatedTag(tail) + "` (" + stringifyPosition(tail) + ")",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    }
    this.resume();
    if (tag.close) {
      stack.pop();
    } else {
      this.enter(
        {
          type: token.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
          name: tag.name || null,
          attributes: tag.attributes,
          children: []
        },
        token,
        onErrorRightIsTag
      );
    }
    if (tag.selfClosing || tag.close) {
      this.exit(token, onErrorLeftIsTag);
    } else {
      stack.push(tag);
    }
  }
  function onErrorRightIsTag(closing, open) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    const place = closing ? " before the end of `" + closing.type + "`" : "";
    const position2 = closing ? { start: closing.start, end: closing.end } : void 0;
    throw new VFileMessage(
      "Expected a closing tag for `" + serializeAbbreviatedTag(tag) + "` (" + stringifyPosition({ start: open.start, end: open.end }) + ")" + place,
      position2,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function onErrorLeftIsTag(a, b) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
    throw new VFileMessage(
      "Expected the closing tag `" + serializeAbbreviatedTag(tag) + "` either after the end of `" + b.type + "` (" + stringifyPosition(b.end) + ") or another opening tag after the start of `" + b.type + "` (" + stringifyPosition(b.start) + ")",
      { start: a.start, end: a.end },
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function serializeAbbreviatedTag(tag) {
    return "<" + (tag.close ? "/" : "") + (tag.name || "") + ">";
  }
}
function mdxJsxToMarkdown(options) {
  const options_ = options || {};
  const quote = options_.quote || '"';
  const quoteSmart = options_.quoteSmart || false;
  const tightSelfClosing = options_.tightSelfClosing || false;
  const printWidth = options_.printWidth || Number.POSITIVE_INFINITY;
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error(
      "Cannot serialize attribute values with `" + quote + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  mdxElement.peek = peekElement;
  return {
    handlers: {
      mdxJsxFlowElement: mdxElement,
      mdxJsxTextElement: mdxElement
    },
    unsafe: [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: true, character: "<" }
    ],
    // Always generate fenced code (never indented code).
    fences: true,
    // Always generate links with resources (never autolinks).
    resourceLink: true
  };
  function mdxElement(node2, _, context, safeOptions) {
    const tracker = track(safeOptions);
    const selfClosing = node2.name && (!node2.children || node2.children.length === 0);
    const exit3 = context.enter(node2.type);
    let index2 = -1;
    const serializedAttributes = [];
    let value = tracker.move("<" + (node2.name || ""));
    if (node2.attributes && node2.attributes.length > 0) {
      if (!node2.name) {
        throw new Error("Cannot serialize fragment w/ attributes");
      }
      while (++index2 < node2.attributes.length) {
        const attribute = node2.attributes[index2];
        let result;
        if (attribute.type === "mdxJsxExpressionAttribute") {
          result = "{" + (attribute.value || "") + "}";
        } else {
          if (!attribute.name) {
            throw new Error("Cannot serialize attribute w/o name");
          }
          const value2 = attribute.value;
          const left = attribute.name;
          let right = "";
          if (value2 === void 0 || value2 === null) {
          } else if (typeof value2 === "object") {
            right = "{" + (value2.value || "") + "}";
          } else {
            const appliedQuote = quoteSmart && ccount(value2, quote) > ccount(value2, alternative) ? alternative : quote;
            right = appliedQuote + stringifyEntitiesLight(value2, { subset: [appliedQuote] }) + appliedQuote;
          }
          result = left + (right ? "=" : "") + right;
        }
        serializedAttributes.push(result);
      }
    }
    let attributesOnTheirOwnLine = false;
    const attributesOnOneLine = serializedAttributes.join(" ");
    if (
      // Block:
      node2.type === "mdxJsxFlowElement" && // Including a line ending (expressions).
      (/\r?\n|\r/.test(attributesOnOneLine) || // Current position (including `<tag`).
      tracker.current().now.column + // -1 because columns, +1 for ` ` before attributes.
      // Attributes joined by spaces.
      attributesOnOneLine.length + // ` />`.
      (selfClosing ? tightSelfClosing ? 2 : 3 : 1) > printWidth)
    ) {
      attributesOnTheirOwnLine = true;
    }
    if (attributesOnTheirOwnLine) {
      value += tracker.move(
        "\n" + indentLines(serializedAttributes.join("\n"), map4)
      );
    } else if (attributesOnOneLine) {
      value += tracker.move(" " + attributesOnOneLine);
    }
    if (attributesOnTheirOwnLine) {
      value += tracker.move("\n");
    }
    if (selfClosing) {
      value += tracker.move(
        (tightSelfClosing || attributesOnTheirOwnLine ? "" : " ") + "/"
      );
    }
    value += tracker.move(">");
    if (node2.children && node2.children.length > 0) {
      if (node2.type === "mdxJsxFlowElement") {
        tracker.shift(2);
        value += tracker.move("\n");
        value += tracker.move(
          indentLines(containerFlow(node2, context, tracker.current()), map4)
        );
        value += tracker.move("\n");
      } else {
        value += tracker.move(
          containerPhrasing(node2, context, {
            ...tracker.current(),
            before: "<",
            after: ">"
          })
        );
      }
    }
    if (!selfClosing) {
      value += tracker.move("</" + (node2.name || "") + ">");
    }
    exit3();
    return value;
  }
  function map4(line2, _, blank) {
    return (blank ? "" : "  ") + line2;
  }
  function peekElement() {
    return "<";
  }
}

// ../../../node_modules/.pnpm/mdast-util-mdxjs-esm@1.3.1/node_modules/mdast-util-mdxjs-esm/lib/index.js
var mdxjsEsmFromMarkdown = {
  enter: { mdxjsEsm: enterMdxjsEsm },
  exit: { mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData }
};
var mdxjsEsmToMarkdown = { handlers: { mdxjsEsm: handleMdxjsEsm } };
function enterMdxjsEsm(token) {
  this.enter({ type: "mdxjsEsm", value: "" }, token);
  this.buffer();
}
function exitMdxjsEsm(token) {
  const value = this.resume();
  const node2 = (
    /** @type {MdxjsEsm} */
    this.exit(token)
  );
  const estree = token.estree;
  node2.value = value;
  if (estree) {
    node2.data = { estree };
  }
}
function exitMdxjsEsmData(token) {
  this.config.enter.data.call(this, token);
  this.config.exit.data.call(this, token);
}
function handleMdxjsEsm(node2) {
  return node2.value || "";
}

// ../../../node_modules/.pnpm/mdast-util-mdx@2.0.1/node_modules/mdast-util-mdx/index.js
function mdxFromMarkdown() {
  return [mdxExpressionFromMarkdown, mdxJsxFromMarkdown(), mdxjsEsmFromMarkdown];
}
function mdxToMarkdown(options) {
  return {
    extensions: [
      mdxExpressionToMarkdown,
      mdxJsxToMarkdown(options),
      mdxjsEsmToMarkdown
    ]
  };
}

// ../../../node_modules/.pnpm/remark-mdx@2.3.0/node_modules/remark-mdx/index.js
function remarkMdx(options) {
  const data2 = this.data();
  add("micromarkExtensions", mdxjs(options));
  add("fromMarkdownExtensions", mdxFromMarkdown());
  add("toMarkdownExtensions", mdxToMarkdown(options));
  function add(field, value) {
    const list3 = (
      /** @type {Array<unknown>} */
      // Other extensions
      /* c8 ignore next 2 */
      data2[field] ? data2[field] : data2[field] = []
    );
    list3.push(value);
  }
}

// ../../../node_modules/.pnpm/micromark-extension-gfm-autolink-literal@1.0.5/node_modules/micromark-extension-gfm-autolink-literal/lib/syntax.js
var wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: true
};
var domain = {
  tokenize: tokenizeDomain,
  partial: true
};
var path2 = {
  tokenize: tokenizePath,
  partial: true
};
var trail = {
  tokenize: tokenizeTrail,
  partial: true
};
var emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
var wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
var protocolAutolink = {
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
var emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};
var text4 = {};
var gfmAutolinkLiteral = {
  text: text4
};
var code2 = 48;
while (code2 < 123) {
  text4[code2] = emailAutolink;
  code2++;
  if (code2 === 58) code2 = 65;
  else if (code2 === 91) code2 = 97;
}
text4[43] = emailAutolink;
text4[45] = emailAutolink;
text4[46] = emailAutolink;
text4[95] = emailAutolink;
text4[72] = [emailAutolink, protocolAutolink];
text4[104] = [emailAutolink, protocolAutolink];
text4[87] = [emailAutolink, wwwAutolink];
text4[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(effects, ok3, nok) {
  const self2 = this;
  let dot;
  let data2;
  return start3;
  function start3(code3) {
    if (!gfmAtext(code3) || !previousEmail.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code3);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkEmail");
    return atext(code3);
  }
  function atext(code3) {
    if (gfmAtext(code3)) {
      effects.consume(code3);
      return atext;
    }
    if (code3 === 64) {
      effects.consume(code3);
      return emailDomain;
    }
    return nok(code3);
  }
  function emailDomain(code3) {
    if (code3 === 46) {
      return effects.check(
        emailDomainDotTrail,
        emailDomainAfter,
        emailDomainDot
      )(code3);
    }
    if (code3 === 45 || code3 === 95 || asciiAlphanumeric(code3)) {
      data2 = true;
      effects.consume(code3);
      return emailDomain;
    }
    return emailDomainAfter(code3);
  }
  function emailDomainDot(code3) {
    effects.consume(code3);
    dot = true;
    return emailDomain;
  }
  function emailDomainAfter(code3) {
    if (data2 && dot && asciiAlpha(self2.previous)) {
      effects.exit("literalAutolinkEmail");
      effects.exit("literalAutolink");
      return ok3(code3);
    }
    return nok(code3);
  }
}
function tokenizeWwwAutolink(effects, ok3, nok) {
  const self2 = this;
  return wwwStart;
  function wwwStart(code3) {
    if (code3 !== 87 && code3 !== 119 || !previousWww.call(self2, self2.previous) || previousUnbalanced(self2.events)) {
      return nok(code3);
    }
    effects.enter("literalAutolink");
    effects.enter("literalAutolinkWww");
    return effects.check(
      wwwPrefix,
      effects.attempt(domain, effects.attempt(path2, wwwAfter), nok),
      nok
    )(code3);
  }
  function wwwAfter(code3) {
    effects.exit("literalAutolinkWww");
    effects.exit("literalAutolink");
    return ok3(code3);
  }
}
function tokenizeProtocolAutolink(effects, ok3, nok) {
  const self2 = this;
  let buffer2 = "";
  let seen = false;
  return protocolStart;
  function protocolStart(code3) {
    if ((code3 === 72 || code3 === 104) && previousProtocol.call(self2, self2.previous) && !previousUnbalanced(self2.events)) {
      effects.enter("literalAutolink");
      effects.enter("literalAutolinkHttp");
      buffer2 += String.fromCodePoint(code3);
      effects.consume(code3);
      return protocolPrefixInside;
    }
    return nok(code3);
  }
  function protocolPrefixInside(code3) {
    if (asciiAlpha(code3) && buffer2.length < 5) {
      buffer2 += String.fromCodePoint(code3);
      effects.consume(code3);
      return protocolPrefixInside;
    }
    if (code3 === 58) {
      const protocol = buffer2.toLowerCase();
      if (protocol === "http" || protocol === "https") {
        effects.consume(code3);
        return protocolSlashesInside;
      }
    }
    return nok(code3);
  }
  function protocolSlashesInside(code3) {
    if (code3 === 47) {
      effects.consume(code3);
      if (seen) {
        return afterProtocol;
      }
      seen = true;
      return protocolSlashesInside;
    }
    return nok(code3);
  }
  function afterProtocol(code3) {
    return code3 === null || asciiControl(code3) || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || unicodePunctuation(code3) ? nok(code3) : effects.attempt(domain, effects.attempt(path2, protocolAfter), nok)(code3);
  }
  function protocolAfter(code3) {
    effects.exit("literalAutolinkHttp");
    effects.exit("literalAutolink");
    return ok3(code3);
  }
}
function tokenizeWwwPrefix(effects, ok3, nok) {
  let size = 0;
  return wwwPrefixInside;
  function wwwPrefixInside(code3) {
    if ((code3 === 87 || code3 === 119) && size < 3) {
      size++;
      effects.consume(code3);
      return wwwPrefixInside;
    }
    if (code3 === 46 && size === 3) {
      effects.consume(code3);
      return wwwPrefixAfter;
    }
    return nok(code3);
  }
  function wwwPrefixAfter(code3) {
    return code3 === null ? nok(code3) : ok3(code3);
  }
}
function tokenizeDomain(effects, ok3, nok) {
  let underscoreInLastSegment;
  let underscoreInLastLastSegment;
  let seen;
  return domainInside;
  function domainInside(code3) {
    if (code3 === 46 || code3 === 95) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code3);
    }
    if (code3 === null || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || code3 !== 45 && unicodePunctuation(code3)) {
      return domainAfter(code3);
    }
    seen = true;
    effects.consume(code3);
    return domainInside;
  }
  function domainAtPunctuation(code3) {
    if (code3 === 95) {
      underscoreInLastSegment = true;
    } else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = void 0;
    }
    effects.consume(code3);
    return domainInside;
  }
  function domainAfter(code3) {
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code3);
    }
    return ok3(code3);
  }
}
function tokenizePath(effects, ok3) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside;
  function pathInside(code3) {
    if (code3 === 40) {
      sizeOpen++;
      effects.consume(code3);
      return pathInside;
    }
    if (code3 === 41 && sizeClose < sizeOpen) {
      return pathAtPunctuation(code3);
    }
    if (code3 === 33 || code3 === 34 || code3 === 38 || code3 === 39 || code3 === 41 || code3 === 42 || code3 === 44 || code3 === 46 || code3 === 58 || code3 === 59 || code3 === 60 || code3 === 63 || code3 === 93 || code3 === 95 || code3 === 126) {
      return effects.check(trail, ok3, pathAtPunctuation)(code3);
    }
    if (code3 === null || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      return ok3(code3);
    }
    effects.consume(code3);
    return pathInside;
  }
  function pathAtPunctuation(code3) {
    if (code3 === 41) {
      sizeClose++;
    }
    effects.consume(code3);
    return pathInside;
  }
}
function tokenizeTrail(effects, ok3, nok) {
  return trail2;
  function trail2(code3) {
    if (code3 === 33 || code3 === 34 || code3 === 39 || code3 === 41 || code3 === 42 || code3 === 44 || code3 === 46 || code3 === 58 || code3 === 59 || code3 === 63 || code3 === 95 || code3 === 126) {
      effects.consume(code3);
      return trail2;
    }
    if (code3 === 38) {
      effects.consume(code3);
      return trailCharRefStart;
    }
    if (code3 === 93) {
      effects.consume(code3);
      return trailBracketAfter;
    }
    if (
      // `<` is an end.
      code3 === 60 || // So is whitespace.
      code3 === null || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)
    ) {
      return ok3(code3);
    }
    return nok(code3);
  }
  function trailBracketAfter(code3) {
    if (code3 === null || code3 === 40 || code3 === 91 || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      return ok3(code3);
    }
    return trail2(code3);
  }
  function trailCharRefStart(code3) {
    return asciiAlpha(code3) ? trailCharRefInside(code3) : nok(code3);
  }
  function trailCharRefInside(code3) {
    if (code3 === 59) {
      effects.consume(code3);
      return trail2;
    }
    if (asciiAlpha(code3)) {
      effects.consume(code3);
      return trailCharRefInside;
    }
    return nok(code3);
  }
}
function tokenizeEmailDomainDotTrail(effects, ok3, nok) {
  return start3;
  function start3(code3) {
    effects.consume(code3);
    return after;
  }
  function after(code3) {
    return asciiAlphanumeric(code3) ? nok(code3) : ok3(code3);
  }
}
function previousWww(code3) {
  return code3 === null || code3 === 40 || code3 === 42 || code3 === 95 || code3 === 91 || code3 === 93 || code3 === 126 || markdownLineEndingOrSpace(code3);
}
function previousProtocol(code3) {
  return !asciiAlpha(code3);
}
function previousEmail(code3) {
  return !(code3 === 47 || gfmAtext(code3));
}
function gfmAtext(code3) {
  return code3 === 43 || code3 === 45 || code3 === 46 || code3 === 95 || asciiAlphanumeric(code3);
}
function previousUnbalanced(events) {
  let index2 = events.length;
  let result = false;
  while (index2--) {
    const token = events[index2][1];
    if ((token.type === "labelLink" || token.type === "labelImage") && !token._balanced) {
      result = true;
      break;
    }
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break;
    }
  }
  if (events.length > 0 && !result) {
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result;
}

// ../../../node_modules/.pnpm/micromark-util-encode@1.1.0/node_modules/micromark-util-encode/index.js
var characterReferences = { '"': "quot", "&": "amp", "<": "lt", ">": "gt" };
function encode(value) {
  return value.replace(/["&<>]/g, replace3);
  function replace3(value2) {
    return "&" + characterReferences[value2] + ";";
  }
}

// ../../../node_modules/.pnpm/micromark-util-sanitize-uri@1.2.0/node_modules/micromark-util-sanitize-uri/index.js
function sanitizeUri(url, protocol) {
  const value = encode(normalizeUri(url || ""));
  if (!protocol) {
    return value;
  }
  const colon = value.indexOf(":");
  const questionMark = value.indexOf("?");
  const numberSign = value.indexOf("#");
  const slash = value.indexOf("/");
  if (
    // If there is no protocol, it’s relative.
    colon < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign || // It is a protocol, it should be allowed.
    protocol.test(value.slice(0, colon))
  ) {
    return value;
  }
  return "";
}
function normalizeUri(value) {
  const result = [];
  let index2 = -1;
  let start3 = 0;
  let skip = 0;
  while (++index2 < value.length) {
    const code3 = value.charCodeAt(index2);
    let replace3 = "";
    if (code3 === 37 && asciiAlphanumeric(value.charCodeAt(index2 + 1)) && asciiAlphanumeric(value.charCodeAt(index2 + 2))) {
      skip = 2;
    } else if (code3 < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code3))) {
        replace3 = String.fromCharCode(code3);
      }
    } else if (code3 > 55295 && code3 < 57344) {
      const next = value.charCodeAt(index2 + 1);
      if (code3 < 56320 && next > 56319 && next < 57344) {
        replace3 = String.fromCharCode(code3, next);
        skip = 1;
      } else {
        replace3 = "\uFFFD";
      }
    } else {
      replace3 = String.fromCharCode(code3);
    }
    if (replace3) {
      result.push(value.slice(start3, index2), encodeURIComponent(replace3));
      start3 = index2 + skip + 1;
      replace3 = "";
    }
    if (skip) {
      index2 += skip;
      skip = 0;
    }
  }
  return result.join("") + value.slice(start3);
}

// ../../../node_modules/.pnpm/micromark-extension-gfm-autolink-literal@1.0.5/node_modules/micromark-extension-gfm-autolink-literal/lib/html.js
var gfmAutolinkLiteralHtml = {
  exit: {
    literalAutolinkEmail,
    literalAutolinkHttp,
    literalAutolinkWww
  }
};
function literalAutolinkWww(token) {
  anchorFromToken.call(this, token, "http://");
}
function literalAutolinkEmail(token) {
  anchorFromToken.call(this, token, "mailto:");
}
function literalAutolinkHttp(token) {
  anchorFromToken.call(this, token);
}
function anchorFromToken(token, protocol) {
  const url = this.sliceSerialize(token);
  this.tag('<a href="' + sanitizeUri((protocol || "") + url) + '">');
  this.raw(this.encode(url));
  this.tag("</a>");
}

// ../../../node_modules/.pnpm/micromark-extension-gfm-footnote@1.1.2/node_modules/micromark-extension-gfm-footnote/lib/syntax.js
var indent = {
  tokenize: tokenizeIndent2,
  partial: true
};
function gfmFootnote() {
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  let index2 = self2.events.length;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let labelStart;
  while (index2--) {
    const token = self2.events[index2][1];
    if (token.type === "labelImage") {
      labelStart = token;
      break;
    }
    if (token.type === "gfmFootnoteCall" || token.type === "labelLink" || token.type === "label" || token.type === "image" || token.type === "link") {
      break;
    }
  }
  return start3;
  function start3(code3) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code3);
    }
    const id2 = normalizeIdentifier(
      self2.sliceSerialize({
        start: labelStart.end,
        end: self2.now()
      })
    );
    if (id2.codePointAt(0) !== 94 || !defined.includes(id2.slice(1))) {
      return nok(code3);
    }
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteCallLabelMarker");
    return ok3(code3);
  }
}
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index2 = events.length;
  let labelStart;
  while (index2--) {
    if (events[index2][1].type === "labelImage" && events[index2][0] === "enter") {
      labelStart = events[index2][1];
      break;
    }
  }
  events[index2 + 1][1].type = "data";
  events[index2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const call = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, events[index2 + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const marker = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, events[index2 + 3][1].end),
    end: Object.assign({}, events[index2 + 3][1].end)
  };
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  const string3 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  const chunk = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, string3.start),
    end: Object.assign({}, string3.end)
  };
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index2 + 1],
    events[index2 + 2],
    ["enter", call, context],
    // The `[`
    events[index2 + 3],
    events[index2 + 4],
    // The `^`.
    ["enter", marker, context],
    ["exit", marker, context],
    // Everything in between.
    ["enter", string3, context],
    ["enter", chunk, context],
    ["exit", chunk, context],
    ["exit", string3, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ["exit", call, context]
  ];
  events.splice(index2, events.length - index2 + 1, ...replacement);
  return events;
}
function tokenizeGfmFootnoteCall(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let size = 0;
  let data2;
  return start3;
  function start3(code3) {
    effects.enter("gfmFootnoteCall");
    effects.enter("gfmFootnoteCallLabelMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteCallLabelMarker");
    return callStart;
  }
  function callStart(code3) {
    if (code3 !== 94) return nok(code3);
    effects.enter("gfmFootnoteCallMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteCallMarker");
    effects.enter("gfmFootnoteCallString");
    effects.enter("chunkString").contentType = "string";
    return callData;
  }
  function callData(code3) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code3 === 93 && !data2 || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code3 === null || code3 === 91 || markdownLineEndingOrSpace(code3)
    ) {
      return nok(code3);
    }
    if (code3 === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteCallString");
      if (!defined.includes(normalizeIdentifier(self2.sliceSerialize(token)))) {
        return nok(code3);
      }
      effects.enter("gfmFootnoteCallLabelMarker");
      effects.consume(code3);
      effects.exit("gfmFootnoteCallLabelMarker");
      effects.exit("gfmFootnoteCall");
      return ok3;
    }
    if (!markdownLineEndingOrSpace(code3)) {
      data2 = true;
    }
    size++;
    effects.consume(code3);
    return code3 === 92 ? callEscape : callData;
  }
  function callEscape(code3) {
    if (code3 === 91 || code3 === 92 || code3 === 93) {
      effects.consume(code3);
      size++;
      return callData;
    }
    return callData(code3);
  }
}
function tokenizeDefinitionStart(effects, ok3, nok) {
  const self2 = this;
  const defined = self2.parser.gfmFootnotes || (self2.parser.gfmFootnotes = []);
  let identifier;
  let size = 0;
  let data2;
  return start3;
  function start3(code3) {
    effects.enter("gfmFootnoteDefinition")._container = true;
    effects.enter("gfmFootnoteDefinitionLabel");
    effects.enter("gfmFootnoteDefinitionLabelMarker");
    effects.consume(code3);
    effects.exit("gfmFootnoteDefinitionLabelMarker");
    return labelAtMarker;
  }
  function labelAtMarker(code3) {
    if (code3 === 94) {
      effects.enter("gfmFootnoteDefinitionMarker");
      effects.consume(code3);
      effects.exit("gfmFootnoteDefinitionMarker");
      effects.enter("gfmFootnoteDefinitionLabelString");
      effects.enter("chunkString").contentType = "string";
      return labelInside;
    }
    return nok(code3);
  }
  function labelInside(code3) {
    if (
      // Too long.
      size > 999 || // Closing brace with nothing.
      code3 === 93 && !data2 || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code3 === null || code3 === 91 || markdownLineEndingOrSpace(code3)
    ) {
      return nok(code3);
    }
    if (code3 === 93) {
      effects.exit("chunkString");
      const token = effects.exit("gfmFootnoteDefinitionLabelString");
      identifier = normalizeIdentifier(self2.sliceSerialize(token));
      effects.enter("gfmFootnoteDefinitionLabelMarker");
      effects.consume(code3);
      effects.exit("gfmFootnoteDefinitionLabelMarker");
      effects.exit("gfmFootnoteDefinitionLabel");
      return labelAfter;
    }
    if (!markdownLineEndingOrSpace(code3)) {
      data2 = true;
    }
    size++;
    effects.consume(code3);
    return code3 === 92 ? labelEscape : labelInside;
  }
  function labelEscape(code3) {
    if (code3 === 91 || code3 === 92 || code3 === 93) {
      effects.consume(code3);
      size++;
      return labelInside;
    }
    return labelInside(code3);
  }
  function labelAfter(code3) {
    if (code3 === 58) {
      effects.enter("definitionMarker");
      effects.consume(code3);
      effects.exit("definitionMarker");
      if (!defined.includes(identifier)) {
        defined.push(identifier);
      }
      return factorySpace(
        effects,
        whitespaceAfter,
        "gfmFootnoteDefinitionWhitespace"
      );
    }
    return nok(code3);
  }
  function whitespaceAfter(code3) {
    return ok3(code3);
  }
}
function tokenizeDefinitionContinuation(effects, ok3, nok) {
  return effects.check(blankLine, ok3, effects.attempt(indent, ok3, nok));
}
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit("gfmFootnoteDefinition");
}
function tokenizeIndent2(effects, ok3, nok) {
  const self2 = this;
  return factorySpace(
    effects,
    afterPrefix,
    "gfmFootnoteDefinitionIndent",
    4 + 1
  );
  function afterPrefix(code3) {
    const tail = self2.events[self2.events.length - 1];
    return tail && tail[1].type === "gfmFootnoteDefinitionIndent" && tail[2].sliceSerialize(tail[1], true).length === 4 ? ok3(code3) : nok(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-extension-gfm-strikethrough@1.0.7/node_modules/micromark-extension-gfm-strikethrough/lib/html.js
var gfmStrikethroughHtml = {
  enter: {
    strikethrough() {
      this.tag("<del>");
    }
  },
  exit: {
    strikethrough() {
      this.tag("</del>");
    }
  }
};

// ../../../node_modules/.pnpm/micromark-extension-gfm-strikethrough@1.0.7/node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer3 = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === void 0) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer3
    },
    insideSpan: {
      null: [tokenizer3]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function resolveAllStrikethrough(events, context) {
    let index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][0] === "enter" && events[index2][1].type === "strikethroughSequenceTemporary" && events[index2][1]._close) {
        let open = index2;
        while (open--) {
          if (events[open][0] === "exit" && events[open][1].type === "strikethroughSequenceTemporary" && events[open][1]._open && // If the sizes are the same:
          events[index2][1].end.offset - events[index2][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {
            events[index2][1].type = "strikethroughSequence";
            events[open][1].type = "strikethroughSequence";
            const strikethrough = {
              type: "strikethrough",
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index2][1].end)
            };
            const text7 = {
              type: "strikethroughText",
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index2][1].start)
            };
            const nextEvents = [
              ["enter", strikethrough, context],
              ["enter", events[open][1], context],
              ["exit", events[open][1], context],
              ["enter", text7, context]
            ];
            const insideSpan2 = context.parser.constructs.insideSpan.null;
            if (insideSpan2) {
              splice(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll(insideSpan2, events.slice(open + 1, index2), context)
              );
            }
            splice(nextEvents, nextEvents.length, 0, [
              ["exit", text7, context],
              ["enter", events[index2][1], context],
              ["exit", events[index2][1], context],
              ["exit", strikethrough, context]
            ]);
            splice(events, open - 1, index2 - open + 3, nextEvents);
            index2 = open + nextEvents.length - 2;
            break;
          }
        }
      }
    }
    index2 = -1;
    while (++index2 < events.length) {
      if (events[index2][1].type === "strikethroughSequenceTemporary") {
        events[index2][1].type = "data";
      }
    }
    return events;
  }
  function tokenizeStrikethrough(effects, ok3, nok) {
    const previous3 = this.previous;
    const events = this.events;
    let size = 0;
    return start3;
    function start3(code3) {
      if (previous3 === 126 && events[events.length - 1][1].type !== "characterEscape") {
        return nok(code3);
      }
      effects.enter("strikethroughSequenceTemporary");
      return more(code3);
    }
    function more(code3) {
      const before = classifyCharacter(previous3);
      if (code3 === 126) {
        if (size > 1) return nok(code3);
        effects.consume(code3);
        size++;
        return more;
      }
      if (size < 2 && !single) return nok(code3);
      const token = effects.exit("strikethroughSequenceTemporary");
      const after = classifyCharacter(code3);
      token._open = !after || after === 2 && Boolean(before);
      token._close = !before || before === 2 && Boolean(after);
      return ok3(code3);
    }
  }
}

// ../../../node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/lib/html.js
var alignment = {
  none: "",
  left: ' align="left"',
  right: ' align="right"',
  center: ' align="center"'
};
var gfmTableHtml = {
  enter: {
    table(token) {
      const tableAlign = token._align;
      this.lineEndingIfNeeded();
      this.tag("<table>");
      this.setData("tableAlign", tableAlign);
    },
    tableBody() {
      this.tag("<tbody>");
    },
    tableData() {
      const tableAlign = this.getData("tableAlign");
      const tableColumn = this.getData("tableColumn");
      const align = alignment[tableAlign[tableColumn]];
      if (align === void 0) {
        this.buffer();
      } else {
        this.lineEndingIfNeeded();
        this.tag("<td" + align + ">");
      }
    },
    tableHead() {
      this.lineEndingIfNeeded();
      this.tag("<thead>");
    },
    tableHeader() {
      const tableAlign = this.getData("tableAlign");
      const tableColumn = this.getData("tableColumn");
      const align = alignment[tableAlign[tableColumn]];
      this.lineEndingIfNeeded();
      this.tag("<th" + align + ">");
    },
    tableRow() {
      this.setData("tableColumn", 0);
      this.lineEndingIfNeeded();
      this.tag("<tr>");
    }
  },
  exit: {
    // Overwrite the default code text data handler to unescape escaped pipes when
    // they are in tables.
    codeTextData(token) {
      let value = this.sliceSerialize(token);
      if (this.getData("tableAlign")) {
        value = value.replace(/\\([\\|])/g, replace);
      }
      this.raw(this.encode(value));
    },
    table() {
      this.setData("tableAlign");
      this.setData("slurpAllLineEndings");
      this.lineEndingIfNeeded();
      this.tag("</table>");
    },
    tableBody() {
      this.lineEndingIfNeeded();
      this.tag("</tbody>");
    },
    tableData() {
      const tableAlign = this.getData("tableAlign");
      const tableColumn = this.getData("tableColumn");
      if (tableColumn in tableAlign) {
        this.tag("</td>");
        this.setData("tableColumn", tableColumn + 1);
      } else {
        this.resume();
      }
    },
    tableHead() {
      this.lineEndingIfNeeded();
      this.tag("</thead>");
    },
    tableHeader() {
      const tableColumn = this.getData("tableColumn");
      this.tag("</th>");
      this.setData("tableColumn", tableColumn + 1);
    },
    tableRow() {
      const tableAlign = this.getData("tableAlign");
      let tableColumn = this.getData("tableColumn");
      while (tableColumn < tableAlign.length) {
        this.lineEndingIfNeeded();
        this.tag("<td" + alignment[tableAlign[tableColumn]] + "></td>");
        tableColumn++;
      }
      this.setData("tableColumn", tableColumn);
      this.lineEndingIfNeeded();
      this.tag("</tr>");
    }
  }
};
function replace($0, $1) {
  return $1 === "|" ? $1 : $0;
}

// ../../../node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/lib/edit-map.js
var EditMap = class {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {void}
   */
  add(index2, remove, add) {
    addImpl(this, index2, remove, add);
  }
  // To do: not used here.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {void}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {void}
   */
  consume(events) {
    this.map.sort((a, b) => a[0] - b[0]);
    if (this.map.length === 0) {
      return;
    }
    let index2 = this.map.length;
    const vecs = [];
    while (index2 > 0) {
      index2 -= 1;
      vecs.push(events.slice(this.map[index2][0] + this.map[index2][1]));
      vecs.push(this.map[index2][2]);
      events.length = this.map[index2][0];
    }
    vecs.push([...events]);
    events.length = 0;
    let slice = vecs.pop();
    while (slice) {
      events.push(...slice);
      slice = vecs.pop();
    }
    this.map.length = 0;
  }
};
function addImpl(editMap, at3, remove, add) {
  let index2 = 0;
  if (remove === 0 && add.length === 0) {
    return;
  }
  while (index2 < editMap.map.length) {
    if (editMap.map[index2][0] === at3) {
      editMap.map[index2][1] += remove;
      editMap.map[index2][2].push(...add);
      return;
    }
    index2 += 1;
  }
  editMap.map.push([at3, remove, add]);
}

// ../../../node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/lib/infer.js
function gfmTableAlign(events, index2) {
  let inDelimiterRow = false;
  const align = [];
  while (index2 < events.length) {
    const event = events[index2];
    if (inDelimiterRow) {
      if (event[0] === "enter") {
        if (event[1].type === "tableContent") {
          align.push(
            events[index2 + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
          );
        }
      } else if (event[1].type === "tableContent") {
        if (events[index2 - 1][1].type === "tableDelimiterMarker") {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === "left" ? "center" : "right";
        }
      } else if (event[1].type === "tableDelimiterRow") {
        break;
      }
    } else if (event[0] === "enter" && event[1].type === "tableDelimiterRow") {
      inDelimiterRow = true;
    }
    index2 += 1;
  }
  return align;
}

// ../../../node_modules/.pnpm/micromark-extension-gfm-table@1.0.7/node_modules/micromark-extension-gfm-table/lib/syntax.js
var gfmTable = {
  flow: {
    null: {
      tokenize: tokenizeTable,
      resolveAll: resolveTable
    }
  }
};
function tokenizeTable(effects, ok3, nok) {
  const self2 = this;
  let size = 0;
  let sizeB = 0;
  let seen;
  return start3;
  function start3(code3) {
    let index2 = self2.events.length - 1;
    while (index2 > -1) {
      const type = self2.events[index2][1].type;
      if (type === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      type === "linePrefix")
        index2--;
      else break;
    }
    const tail = index2 > -1 ? self2.events[index2][1].type : null;
    const next = tail === "tableHead" || tail === "tableRow" ? bodyRowStart : headRowBefore;
    if (next === bodyRowStart && self2.parser.lazy[self2.now().line]) {
      return nok(code3);
    }
    return next(code3);
  }
  function headRowBefore(code3) {
    effects.enter("tableHead");
    effects.enter("tableRow");
    return headRowStart(code3);
  }
  function headRowStart(code3) {
    if (code3 === 124) {
      return headRowBreak(code3);
    }
    seen = true;
    sizeB += 1;
    return headRowBreak(code3);
  }
  function headRowBreak(code3) {
    if (code3 === null) {
      return nok(code3);
    }
    if (markdownLineEnding(code3)) {
      if (sizeB > 1) {
        sizeB = 0;
        self2.interrupt = true;
        effects.exit("tableRow");
        effects.enter("lineEnding");
        effects.consume(code3);
        effects.exit("lineEnding");
        return headDelimiterStart;
      }
      return nok(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, headRowBreak, "whitespace")(code3);
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      size += 1;
    }
    if (code3 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      seen = true;
      return headRowBreak;
    }
    effects.enter("data");
    return headRowData(code3);
  }
  function headRowData(code3) {
    if (code3 === null || code3 === 124 || markdownLineEndingOrSpace(code3)) {
      effects.exit("data");
      return headRowBreak(code3);
    }
    effects.consume(code3);
    return code3 === 92 ? headRowEscape : headRowData;
  }
  function headRowEscape(code3) {
    if (code3 === 92 || code3 === 124) {
      effects.consume(code3);
      return headRowData;
    }
    return headRowData(code3);
  }
  function headDelimiterStart(code3) {
    self2.interrupt = false;
    if (self2.parser.lazy[self2.now().line]) {
      return nok(code3);
    }
    effects.enter("tableDelimiterRow");
    seen = false;
    if (markdownSpace(code3)) {
      return factorySpace(
        effects,
        headDelimiterBefore,
        "linePrefix",
        self2.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(code3);
    }
    return headDelimiterBefore(code3);
  }
  function headDelimiterBefore(code3) {
    if (code3 === 45 || code3 === 58) {
      return headDelimiterValueBefore(code3);
    }
    if (code3 === 124) {
      seen = true;
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      return headDelimiterCellBefore;
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterCellBefore(code3) {
    if (markdownSpace(code3)) {
      return factorySpace(effects, headDelimiterValueBefore, "whitespace")(code3);
    }
    return headDelimiterValueBefore(code3);
  }
  function headDelimiterValueBefore(code3) {
    if (code3 === 58) {
      sizeB += 1;
      seen = true;
      effects.enter("tableDelimiterMarker");
      effects.consume(code3);
      effects.exit("tableDelimiterMarker");
      return headDelimiterLeftAlignmentAfter;
    }
    if (code3 === 45) {
      sizeB += 1;
      return headDelimiterLeftAlignmentAfter(code3);
    }
    if (code3 === null || markdownLineEnding(code3)) {
      return headDelimiterCellAfter(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterLeftAlignmentAfter(code3) {
    if (code3 === 45) {
      effects.enter("tableDelimiterFiller");
      return headDelimiterFiller(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterFiller(code3) {
    if (code3 === 45) {
      effects.consume(code3);
      return headDelimiterFiller;
    }
    if (code3 === 58) {
      seen = true;
      effects.exit("tableDelimiterFiller");
      effects.enter("tableDelimiterMarker");
      effects.consume(code3);
      effects.exit("tableDelimiterMarker");
      return headDelimiterRightAlignmentAfter;
    }
    effects.exit("tableDelimiterFiller");
    return headDelimiterRightAlignmentAfter(code3);
  }
  function headDelimiterRightAlignmentAfter(code3) {
    if (markdownSpace(code3)) {
      return factorySpace(effects, headDelimiterCellAfter, "whitespace")(code3);
    }
    return headDelimiterCellAfter(code3);
  }
  function headDelimiterCellAfter(code3) {
    if (code3 === 124) {
      return headDelimiterBefore(code3);
    }
    if (code3 === null || markdownLineEnding(code3)) {
      if (!seen || size !== sizeB) {
        return headDelimiterNok(code3);
      }
      effects.exit("tableDelimiterRow");
      effects.exit("tableHead");
      return ok3(code3);
    }
    return headDelimiterNok(code3);
  }
  function headDelimiterNok(code3) {
    return nok(code3);
  }
  function bodyRowStart(code3) {
    effects.enter("tableRow");
    return bodyRowBreak(code3);
  }
  function bodyRowBreak(code3) {
    if (code3 === 124) {
      effects.enter("tableCellDivider");
      effects.consume(code3);
      effects.exit("tableCellDivider");
      return bodyRowBreak;
    }
    if (code3 === null || markdownLineEnding(code3)) {
      effects.exit("tableRow");
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return factorySpace(effects, bodyRowBreak, "whitespace")(code3);
    }
    effects.enter("data");
    return bodyRowData(code3);
  }
  function bodyRowData(code3) {
    if (code3 === null || code3 === 124 || markdownLineEndingOrSpace(code3)) {
      effects.exit("data");
      return bodyRowBreak(code3);
    }
    effects.consume(code3);
    return code3 === 92 ? bodyRowEscape : bodyRowData;
  }
  function bodyRowEscape(code3) {
    if (code3 === 92 || code3 === 124) {
      effects.consume(code3);
      return bodyRowData;
    }
    return bodyRowData(code3);
  }
}
function resolveTable(events, context) {
  let index2 = -1;
  let inFirstCellAwaitingPipe = true;
  let rowKind = 0;
  let lastCell = [0, 0, 0, 0];
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  let currentTable;
  let currentBody;
  let currentCell;
  const map4 = new EditMap();
  while (++index2 < events.length) {
    const event = events[index2];
    const token = event[1];
    if (event[0] === "enter") {
      if (token.type === "tableHead") {
        afterHeadAwaitingFirstBodyRow = false;
        if (lastTableEnd !== 0) {
          flushTableEnd(map4, context, lastTableEnd, currentTable, currentBody);
          currentBody = void 0;
          lastTableEnd = 0;
        }
        currentTable = {
          type: "table",
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map4.add(index2, 0, [["enter", currentTable, context]]);
      } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
        inFirstCellAwaitingPipe = true;
        currentCell = void 0;
        lastCell = [0, 0, 0, 0];
        cell = [0, index2 + 1, 0, 0];
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: "tableBody",
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map4.add(index2, 0, [["enter", currentBody, context]]);
        }
        rowKind = token.type === "tableDelimiterRow" ? 2 : currentBody ? 3 : 1;
      } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
        inFirstCellAwaitingPipe = false;
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map4,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index2;
        }
      } else if (token.type === "tableCellDivider") {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map4,
              context,
              lastCell,
              rowKind,
              void 0,
              currentCell
            );
          }
          lastCell = cell;
          cell = [lastCell[1], index2, 0, 0];
        }
      }
    } else if (token.type === "tableHead") {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index2;
    } else if (token.type === "tableRow" || token.type === "tableDelimiterRow") {
      lastTableEnd = index2;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(
          map4,
          context,
          lastCell,
          rowKind,
          index2,
          currentCell
        );
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map4, context, cell, rowKind, index2, currentCell);
      }
      rowKind = 0;
    } else if (rowKind && (token.type === "data" || token.type === "tableDelimiterMarker" || token.type === "tableDelimiterFiller")) {
      cell[3] = index2;
    }
  }
  if (lastTableEnd !== 0) {
    flushTableEnd(map4, context, lastTableEnd, currentTable, currentBody);
  }
  map4.consume(context.events);
  index2 = -1;
  while (++index2 < context.events.length) {
    const event = context.events[index2];
    if (event[0] === "enter" && event[1].type === "table") {
      event[1]._align = gfmTableAlign(context.events, index2);
    }
  }
  return events;
}
function flushCell(map4, context, range, rowKind, rowEnd, previousCell) {
  const groupName = rowKind === 1 ? "tableHeader" : rowKind === 2 ? "tableDelimiter" : "tableData";
  const valueName = "tableContent";
  if (range[0] !== 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map4.add(range[0], 0, [["exit", previousCell, context]]);
  }
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map4.add(range[1], 0, [["enter", previousCell, context]]);
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map4.add(range[2], 0, [["enter", valueToken, context]]);
    if (rowKind !== 2) {
      const start3 = context.events[range[2]];
      const end = context.events[range[3]];
      start3[1].end = Object.assign({}, end[1].end);
      start3[1].type = "chunkText";
      start3[1].contentType = "text";
      if (range[3] > range[2] + 1) {
        const a = range[2] + 1;
        const b = range[3] - range[2] - 1;
        map4.add(a, b, []);
      }
    }
    map4.add(range[3] + 1, 0, [["exit", valueToken, context]]);
  }
  if (rowEnd !== void 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map4.add(rowEnd, 0, [["exit", previousCell, context]]);
    previousCell = void 0;
  }
  return previousCell;
}
function flushTableEnd(map4, context, index2, table, tableBody) {
  const exits = [];
  const related = getPoint(context.events, index2);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(["exit", tableBody, context]);
  }
  table.end = Object.assign({}, related);
  exits.push(["exit", table, context]);
  map4.add(index2 + 1, 0, exits);
}
function getPoint(events, index2) {
  const event = events[index2];
  const side = event[0] === "enter" ? "start" : "end";
  return event[1][side];
}

// ../../../node_modules/.pnpm/micromark-extension-gfm-tagfilter@1.0.2/node_modules/micromark-extension-gfm-tagfilter/index.js
var reFlow = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\t\n\f\r />])/gi;
var reText = new RegExp("^" + reFlow.source, "i");
var gfmTagfilterHtml = {
  exit: {
    htmlFlowData(token) {
      exitHtmlData.call(this, token, reFlow);
    },
    htmlTextData(token) {
      exitHtmlData.call(this, token, reText);
    }
  }
};
function exitHtmlData(token, filter) {
  let value = this.sliceSerialize(token);
  if (this.options.allowDangerousHtml) {
    value = value.replace(filter, "&lt;$1$2");
  }
  this.raw(this.encode(value));
}

// ../../../node_modules/.pnpm/micromark-extension-gfm-task-list-item@1.0.5/node_modules/micromark-extension-gfm-task-list-item/lib/html.js
var gfmTaskListItemHtml = {
  enter: {
    taskListCheck() {
      this.tag('<input type="checkbox" disabled="" ');
    }
  },
  exit: {
    taskListCheck() {
      this.tag("/>");
    },
    taskListCheckValueChecked() {
      this.tag('checked="" ');
    }
  }
};

// ../../../node_modules/.pnpm/micromark-extension-gfm-task-list-item@1.0.5/node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js
var tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};
var gfmTaskListItem = {
  text: {
    [91]: tasklistCheck
  }
};
function tokenizeTasklistCheck(effects, ok3, nok) {
  const self2 = this;
  return open;
  function open(code3) {
    if (
      // Exit if there’s stuff before.
      self2.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !self2._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code3);
    }
    effects.enter("taskListCheck");
    effects.enter("taskListCheckMarker");
    effects.consume(code3);
    effects.exit("taskListCheckMarker");
    return inside;
  }
  function inside(code3) {
    if (markdownLineEndingOrSpace(code3)) {
      effects.enter("taskListCheckValueUnchecked");
      effects.consume(code3);
      effects.exit("taskListCheckValueUnchecked");
      return close;
    }
    if (code3 === 88 || code3 === 120) {
      effects.enter("taskListCheckValueChecked");
      effects.consume(code3);
      effects.exit("taskListCheckValueChecked");
      return close;
    }
    return nok(code3);
  }
  function close(code3) {
    if (code3 === 93) {
      effects.enter("taskListCheckMarker");
      effects.consume(code3);
      effects.exit("taskListCheckMarker");
      effects.exit("taskListCheck");
      return after;
    }
    return nok(code3);
  }
  function after(code3) {
    if (markdownLineEnding(code3)) {
      return ok3(code3);
    }
    if (markdownSpace(code3)) {
      return effects.check(
        {
          tokenize: spaceThenNonSpace
        },
        ok3,
        nok
      )(code3);
    }
    return nok(code3);
  }
}
function spaceThenNonSpace(effects, ok3, nok) {
  return factorySpace(effects, after, "whitespace");
  function after(code3) {
    return code3 === null ? nok(code3) : ok3(code3);
  }
}

// ../../../node_modules/.pnpm/micromark-extension-gfm@2.0.3/node_modules/micromark-extension-gfm/index.js
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral,
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable,
    gfmTaskListItem
  ]);
}

// ../../../node_modules/.pnpm/escape-string-regexp@5.0.0/node_modules/escape-string-regexp/index.js
function escapeStringRegexp(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError("Expected a string");
  }
  return string3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// ../../../node_modules/.pnpm/mdast-util-find-and-replace@2.2.2/node_modules/mdast-util-find-and-replace/lib/index.js
var own5 = {}.hasOwnProperty;
var findAndReplace = (
  /**
   * @type {(
   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &
   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)
   * )}
   **/
  /**
   * @template {Node} Tree
   * @param {Tree} tree
   * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find
   * @param {Replace | Options | null | undefined} [replace]
   * @param {Options | null | undefined} [options]
   * @returns {Tree}
   */
  function(tree, find2, replace3, options) {
    let settings;
    let schema;
    if (typeof find2 === "string" || find2 instanceof RegExp) {
      schema = [[find2, replace3]];
      settings = options;
    } else {
      schema = find2;
      settings = replace3;
    }
    if (!settings) {
      settings = {};
    }
    const ignored = convert(settings.ignore || []);
    const pairs = toPairs(schema);
    let pairIndex = -1;
    while (++pairIndex < pairs.length) {
      visitParents(tree, "text", visitor);
    }
    return tree;
    function visitor(node2, parents) {
      let index2 = -1;
      let grandparent;
      while (++index2 < parents.length) {
        const parent = parents[index2];
        if (ignored(
          parent,
          // @ts-expect-error: TS doesn’t understand but it’s perfect.
          grandparent ? grandparent.children.indexOf(parent) : void 0,
          grandparent
        )) {
          return;
        }
        grandparent = parent;
      }
      if (grandparent) {
        return handler(node2, parents);
      }
    }
    function handler(node2, parents) {
      const parent = parents[parents.length - 1];
      const find3 = pairs[pairIndex][0];
      const replace4 = pairs[pairIndex][1];
      let start3 = 0;
      const index2 = parent.children.indexOf(node2);
      let change = false;
      let nodes = [];
      find3.lastIndex = 0;
      let match = find3.exec(node2.value);
      while (match) {
        const position2 = match.index;
        const matchObject = {
          index: match.index,
          input: match.input,
          // @ts-expect-error: stack is fine.
          stack: [...parents, node2]
        };
        let value = replace4(...match, matchObject);
        if (typeof value === "string") {
          value = value.length > 0 ? { type: "text", value } : void 0;
        }
        if (value !== false) {
          if (start3 !== position2) {
            nodes.push({
              type: "text",
              value: node2.value.slice(start3, position2)
            });
          }
          if (Array.isArray(value)) {
            nodes.push(...value);
          } else if (value) {
            nodes.push(value);
          }
          start3 = position2 + match[0].length;
          change = true;
        }
        if (!find3.global) {
          break;
        }
        match = find3.exec(node2.value);
      }
      if (change) {
        if (start3 < node2.value.length) {
          nodes.push({ type: "text", value: node2.value.slice(start3) });
        }
        parent.children.splice(index2, 1, ...nodes);
      } else {
        nodes = [node2];
      }
      return index2 + nodes.length;
    }
  }
);
function toPairs(schema) {
  const result = [];
  if (typeof schema !== "object") {
    throw new TypeError("Expected array or object as schema");
  }
  if (Array.isArray(schema)) {
    let index2 = -1;
    while (++index2 < schema.length) {
      result.push([
        toExpression(schema[index2][0]),
        toFunction(schema[index2][1])
      ]);
    }
  } else {
    let key;
    for (key in schema) {
      if (own5.call(schema, key)) {
        result.push([toExpression(key), toFunction(schema[key])]);
      }
    }
  }
  return result;
}
function toExpression(find2) {
  return typeof find2 === "string" ? new RegExp(escapeStringRegexp(find2), "g") : find2;
}
function toFunction(replace3) {
  return typeof replace3 === "function" ? replace3 : () => replace3;
}

// ../../../node_modules/.pnpm/mdast-util-gfm-autolink-literal@1.0.3/node_modules/mdast-util-gfm-autolink-literal/lib/index.js
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
var gfmAutolinkLiteralFromMarkdown = {
  transforms: [transformGfmAutolinkLiterals],
  enter: {
    literalAutolink: enterLiteralAutolink,
    literalAutolinkEmail: enterLiteralAutolinkValue,
    literalAutolinkHttp: enterLiteralAutolinkValue,
    literalAutolinkWww: enterLiteralAutolinkValue
  },
  exit: {
    literalAutolink: exitLiteralAutolink,
    literalAutolinkEmail: exitLiteralAutolinkEmail,
    literalAutolinkHttp: exitLiteralAutolinkHttp,
    literalAutolinkWww: exitLiteralAutolinkWww
  }
};
var gfmAutolinkLiteralToMarkdown = {
  unsafe: [
    {
      character: "@",
      before: "[+\\-.\\w]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    },
    {
      character: ".",
      before: "[Ww]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    },
    { character: ":", before: "[ps]", after: "\\/", inConstruct, notInConstruct }
  ]
};
function enterLiteralAutolink(token) {
  this.enter({ type: "link", title: null, url: "", children: [] }, token);
}
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node2 = (
    /** @type {Link} */
    this.stack[this.stack.length - 1]
  );
  node2.url = "http://" + this.sliceSerialize(token);
}
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}
function exitLiteralAutolink(token) {
  this.exit(token);
}
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(_, protocol, domain2, path3, match) {
  let prefix = "";
  if (!previous2(match)) {
    return false;
  }
  if (/^w/i.test(protocol)) {
    domain2 = protocol + domain2;
    protocol = "";
    prefix = "http://";
  }
  if (!isCorrectDomain(domain2)) {
    return false;
  }
  const parts = splitUrl(domain2 + path3);
  if (!parts[0]) return false;
  const result = {
    type: "link",
    title: null,
    url: prefix + protocol + parts[0],
    children: [{ type: "text", value: protocol + parts[0] }]
  };
  if (parts[1]) {
    return [result, { type: "text", value: parts[1] }];
  }
  return result;
}
function findEmail(_, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous2(match, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false;
  }
  return {
    type: "link",
    title: null,
    url: "mailto:" + atext + "@" + label,
    children: [{ type: "text", value: atext + "@" + label }]
  };
}
function isCorrectDomain(domain2) {
  const parts = domain2.split(".");
  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\d]/.test(parts[parts.length - 2]))) {
    return false;
  }
  return true;
}
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);
  if (!trailExec) {
    return [url, void 0];
  }
  url = url.slice(0, trailExec.index);
  let trail2 = trailExec[0];
  let closingParenIndex = trail2.indexOf(")");
  const openingParens = ccount(url, "(");
  let closingParens = ccount(url, ")");
  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail2.slice(0, closingParenIndex + 1);
    trail2 = trail2.slice(closingParenIndex + 1);
    closingParenIndex = trail2.indexOf(")");
    closingParens++;
  }
  return [url, trail2];
}
function previous2(match, email) {
  const code3 = match.input.charCodeAt(match.index - 1);
  return (match.index === 0 || unicodeWhitespace(code3) || unicodePunctuation(code3)) && (!email || code3 !== 47);
}

// ../../../node_modules/.pnpm/mdast-util-gfm-footnote@1.0.2/node_modules/mdast-util-gfm-footnote/lib/index.js
footnoteReference.peek = footnoteReferencePeek;
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
}
function gfmFootnoteToMarkdown() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition, footnoteReference }
  };
}
function enterFootnoteDefinition(token) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    token
  );
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node2 = (
    /** @type {FootnoteDefinition} */
    this.stack[this.stack.length - 1]
  );
  node2.label = label;
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
}
function exitFootnoteDefinition(token) {
  this.exit(token);
}
function enterFootnoteCall(token) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, token);
}
function enterFootnoteCallString() {
  this.buffer();
}
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node2 = (
    /** @type {FootnoteDefinition} */
    this.stack[this.stack.length - 1]
  );
  node2.label = label;
  node2.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
}
function exitFootnoteCall(token) {
  this.exit(token);
}
function footnoteReference(node2, _, context, safeOptions) {
  const tracker = track(safeOptions);
  let value = tracker.move("[^");
  const exit3 = context.enter("footnoteReference");
  const subexit = context.enter("reference");
  value += tracker.move(
    safe(context, association(node2), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  exit3();
  value += tracker.move("]");
  return value;
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteDefinition(node2, _, context, safeOptions) {
  const tracker = track(safeOptions);
  let value = tracker.move("[^");
  const exit3 = context.enter("footnoteDefinition");
  const subexit = context.enter("label");
  value += tracker.move(
    safe(context, association(node2), {
      ...tracker.current(),
      before: value,
      after: "]"
    })
  );
  subexit();
  value += tracker.move(
    "]:" + (node2.children && node2.children.length > 0 ? " " : "")
  );
  tracker.shift(4);
  value += tracker.move(
    indentLines(containerFlow(node2, context, tracker.current()), map3)
  );
  exit3();
  return value;
}
function map3(line2, index2, blank) {
  if (index2 === 0) {
    return line2;
  }
  return (blank ? "" : "    ") + line2;
}

// ../../../node_modules/.pnpm/mdast-util-gfm-strikethrough@1.0.3/node_modules/mdast-util-gfm-strikethrough/lib/index.js
var constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
var gfmStrikethroughFromMarkdown = {
  canContainEols: ["delete"],
  enter: { strikethrough: enterStrikethrough },
  exit: { strikethrough: exitStrikethrough }
};
var gfmStrikethroughToMarkdown = {
  unsafe: [
    {
      character: "~",
      inConstruct: "phrasing",
      notInConstruct: constructsWithoutStrikethrough
    }
  ],
  handlers: { delete: handleDelete }
};
function enterStrikethrough(token) {
  this.enter({ type: "delete", children: [] }, token);
}
function exitStrikethrough(token) {
  this.exit(token);
}
function handleDelete(node2, _, context, safeOptions) {
  const tracker = track(safeOptions);
  const exit3 = context.enter("strikethrough");
  let value = tracker.move("~~");
  value += containerPhrasing(node2, context, {
    ...tracker.current(),
    before: value,
    after: "~"
  });
  value += tracker.move("~~");
  exit3();
  return value;
}
function peekDelete() {
  return "~";
}

// ../../../node_modules/.pnpm/markdown-table@3.0.4/node_modules/markdown-table/index.js
function defaultStringLength(value) {
  return value.length;
}
function markdownTable(table, options) {
  const settings = options || {};
  const align = (settings.align || []).concat();
  const stringLength = settings.stringLength || defaultStringLength;
  const alignments = [];
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;
  while (++rowIndex < table.length) {
    const row2 = [];
    const sizes2 = [];
    let columnIndex2 = -1;
    if (table[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table[rowIndex].length;
    }
    while (++columnIndex2 < table[rowIndex].length) {
      const cell = serialize(table[rowIndex][columnIndex2]);
      if (settings.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes2[columnIndex2] = size;
        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {
          longestCellByColumn[columnIndex2] = size;
        }
      }
      row2.push(cell);
    }
    cellMatrix[rowIndex] = row2;
    sizeMatrix[rowIndex] = sizes2;
  }
  let columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code3 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code3;
    }
  }
  columnIndex = -1;
  const row = [];
  const sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    const code3 = alignments[columnIndex];
    let before = "";
    let after = "";
    if (code3 === 99) {
      before = ":";
      after = ":";
    } else if (code3 === 108) {
      before = ":";
    } else if (code3 === 114) {
      after = ":";
    }
    let size = settings.alignDelimiters === false ? 1 : Math.max(
      1,
      longestCellByColumn[columnIndex] - before.length - after.length
    );
    const cell = before + "-".repeat(size) + after;
    if (settings.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes[columnIndex] = size;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines2 = [];
  while (++rowIndex < cellMatrix.length) {
    const row2 = cellMatrix[rowIndex];
    const sizes2 = sizeMatrix[rowIndex];
    columnIndex = -1;
    const line2 = [];
    while (++columnIndex < mostCellsPerRow) {
      const cell = row2[columnIndex] || "";
      let before = "";
      let after = "";
      if (settings.alignDelimiters !== false) {
        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);
        const code3 = alignments[columnIndex];
        if (code3 === 114) {
          before = " ".repeat(size);
        } else if (code3 === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (settings.delimiterStart !== false && !columnIndex) {
        line2.push("|");
      }
      if (settings.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) {
        line2.push(" ");
      }
      if (settings.alignDelimiters !== false) {
        line2.push(before);
      }
      line2.push(cell);
      if (settings.alignDelimiters !== false) {
        line2.push(after);
      }
      if (settings.padding !== false) {
        line2.push(" ");
      }
      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line2.push("|");
      }
    }
    lines2.push(
      settings.delimiterEnd === false ? line2.join("").replace(/ +$/, "") : line2.join("")
    );
  }
  return lines2.join("\n");
}
function serialize(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function toAlignment(value) {
  const code3 = typeof value === "string" ? value.codePointAt(0) : 0;
  return code3 === 67 || code3 === 99 ? 99 : code3 === 76 || code3 === 108 ? 108 : code3 === 82 || code3 === 114 ? 114 : 0;
}

// ../../../node_modules/.pnpm/mdast-util-gfm-table@1.0.7/node_modules/mdast-util-gfm-table/lib/index.js
var gfmTableFromMarkdown = {
  enter: {
    table: enterTable,
    tableData: enterCell,
    tableHeader: enterCell,
    tableRow: enterRow
  },
  exit: {
    codeText: exitCodeText,
    table: exitTable,
    tableData: exit2,
    tableHeader: exit2,
    tableRow: exit2
  }
};
function enterTable(token) {
  const align = token._align;
  this.enter(
    {
      type: "table",
      align: align.map((d) => d === "none" ? null : d),
      children: []
    },
    token
  );
  this.setData("inTable", true);
}
function exitTable(token) {
  this.exit(token);
  this.setData("inTable");
}
function enterRow(token) {
  this.enter({ type: "tableRow", children: [] }, token);
}
function exit2(token) {
  this.exit(token);
}
function enterCell(token) {
  this.enter({ type: "tableCell", children: [] }, token);
}
function exitCodeText(token) {
  let value = this.resume();
  if (this.getData("inTable")) {
    value = value.replace(/\\([\\|])/g, replace2);
  }
  const node2 = (
    /** @type {InlineCode} */
    this.stack[this.stack.length - 1]
  );
  node2.value = value;
  this.exit(token);
}
function replace2($0, $1) {
  return $1 === "|" ? $1 : $0;
}
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      table: handleTable,
      tableRow: handleTableRow,
      tableCell: handleTableCell,
      inlineCode: inlineCodeWithTable
    }
  };
  function handleTable(node2, _, context, safeOptions) {
    return serializeData(
      handleTableAsData(node2, context, safeOptions),
      node2.align
    );
  }
  function handleTableRow(node2, _, context, safeOptions) {
    const row = handleTableRowAsData(node2, context, safeOptions);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node2, _, context, safeOptions) {
    const exit3 = context.enter("tableCell");
    const subexit = context.enter("phrasing");
    const value = containerPhrasing(node2, context, {
      ...safeOptions,
      before: around,
      after: around
    });
    subexit();
    exit3();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    });
  }
  function handleTableAsData(node2, context, safeOptions) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = context.enter("table");
    while (++index2 < children.length) {
      result[index2] = handleTableRowAsData(
        children[index2],
        context,
        safeOptions
      );
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node2, context, safeOptions) {
    const children = node2.children;
    let index2 = -1;
    const result = [];
    const subexit = context.enter("tableRow");
    while (++index2 < children.length) {
      result[index2] = handleTableCell(
        children[index2],
        node2,
        context,
        safeOptions
      );
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node2, parent, context) {
    let value = inlineCode(node2, parent, context);
    if (context.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}

// ../../../node_modules/.pnpm/mdast-util-gfm-task-list-item@1.0.2/node_modules/mdast-util-gfm-task-list-item/lib/index.js
var gfmTaskListItemFromMarkdown = {
  exit: {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
  }
};
var gfmTaskListItemToMarkdown = {
  unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
  handlers: { listItem: listItemWithTaskListItem }
};
function exitCheck(token) {
  const node2 = (
    /** @type {ListItem} */
    this.stack[this.stack.length - 2]
  );
  node2.checked = token.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(token) {
  const parent = (
    /** @type {Parents} */
    this.stack[this.stack.length - 2]
  );
  if (parent && parent.type === "listItem" && typeof parent.checked === "boolean") {
    const node2 = (
      /** @type {Paragraph} */
      this.stack[this.stack.length - 1]
    );
    const head = node2.children[0];
    if (head && head.type === "text") {
      const siblings = parent.children;
      let index2 = -1;
      let firstParaghraph;
      while (++index2 < siblings.length) {
        const sibling = siblings[index2];
        if (sibling.type === "paragraph") {
          firstParaghraph = sibling;
          break;
        }
      }
      if (firstParaghraph === node2) {
        head.value = head.value.slice(1);
        if (head.value.length === 0) {
          node2.children.shift();
        } else if (node2.position && head.position && typeof head.position.start.offset === "number") {
          head.position.start.column++;
          head.position.start.offset++;
          node2.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }
  this.exit(token);
}
function listItemWithTaskListItem(node2, parent, context, safeOptions) {
  const head = node2.children[0];
  const checkable = typeof node2.checked === "boolean" && head && head.type === "paragraph";
  const checkbox = "[" + (node2.checked ? "x" : " ") + "] ";
  const tracker = track(safeOptions);
  if (checkable) {
    tracker.move(checkbox);
  }
  let value = listItem(node2, parent, context, {
    ...safeOptions,
    ...tracker.current()
  });
  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + checkbox;
  }
}

// ../../../node_modules/.pnpm/mdast-util-gfm@2.0.2/node_modules/mdast-util-gfm/lib/index.js
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown,
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown,
    gfmTableFromMarkdown,
    gfmTaskListItemFromMarkdown
  ];
}
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown,
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown,
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown
    ]
  };
}

// ../../../node_modules/.pnpm/micromark-extension-gfm@1.0.0/node_modules/micromark-extension-gfm/index.js
function gfm2(options) {
  return combineExtensions([
    gfmAutolinkLiteral,
    gfmStrikethrough(options),
    gfmTable,
    gfmTaskListItem
  ]);
}
var gfmHtml = combineHtmlExtensions([
  gfmAutolinkLiteralHtml,
  gfmStrikethroughHtml,
  gfmTableHtml,
  gfmTagfilterHtml,
  gfmTaskListItemHtml
]);

// ../../../node_modules/.pnpm/mdast-util-gfm@1.0.0/node_modules/mdast-util-gfm/index.js
var gfmFromMarkdown2 = [
  gfmAutolinkLiteralFromMarkdown,
  gfmStrikethroughFromMarkdown,
  gfmTableFromMarkdown,
  gfmTaskListItemFromMarkdown
];
function gfmToMarkdown2(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown,
      gfmStrikethroughToMarkdown,
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown
    ]
  };
}

// ../../../node_modules/.pnpm/remark-gfm@2.0.0/node_modules/remark-gfm/index.js
function remarkGfm(options = {}) {
  const data2 = this.data();
  add("micromarkExtensions", gfm2(options));
  add("fromMarkdownExtensions", gfmFromMarkdown2);
  add("toMarkdownExtensions", gfmToMarkdown2(options));
  function add(field, value) {
    const list3 = (
      /** @type {unknown[]} */
      // Other extensions
      /* c8 ignore next 2 */
      data2[field] ? data2[field] : data2[field] = []
    );
    list3.push(value);
  }
}

// src/next/shortcodes/mdast/index.ts
function mdxJsxFromMarkdown2({ patterns }) {
  const buffer2 = function() {
    this.buffer();
  };
  const data2 = function(token) {
    this.config?.enter?.data?.call(this, token);
    this.config?.exit?.data?.call(this, token);
  };
  const enterMdxJsxTag = function(token) {
    const tag = {
      name: void 0,
      attributes: [],
      close: false,
      selfClosing: false,
      start: token.start,
      end: token.end
    };
    if (!this.getData("mdxJsxTagStack")) this.setData("mdxJsxTagStack", []);
    this.setData("mdxJsxTag", tag);
    this.buffer();
  };
  const enterMdxJsxTagClosingMarker = function(token) {
    const stack = this.getData("mdxJsxTagStack");
    const tag = this.getData("mdxJsxTag");
    if (stack?.length === 0) {
      if (tag) {
        tag.shouldFallback = true;
      }
    }
  };
  const enterMdxJsxTagAnyAttribute = function(token) {
    const tag = this.getData("mdxJsxTag");
  };
  const enterMdxJsxTagSelfClosingMarker = function(token) {
    const tag = this.getData("mdxJsxTag");
    if (tag?.close) {
      throw new VFileMessage(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
    }
  };
  const exitMdxJsxTagClosingMarker = function() {
    const tag = this.getData("mdxJsxTag");
    if (tag) {
      tag.close = true;
    }
  };
  const exitMdxJsxTagNamePrimary = function(token) {
    const tag = this.getData("mdxJsxTag");
    if (tag) {
      tag.name = this.sliceSerialize(token);
    }
  };
  const exitMdxJsxTagNameMember = function(token) {
    const tag = this.getData("mdxJsxTag");
    if (tag) {
      tag.name += "." + this.sliceSerialize(token);
    }
  };
  const exitMdxJsxTagNameLocal = function(token) {
    const tag = this.getData("mdxJsxTag");
    if (tag) {
      tag.name += ":" + this.sliceSerialize(token);
    }
  };
  const enterMdxJsxTagAttribute = function(token) {
    const tag = this.getData("mdxJsxTag");
    enterMdxJsxTagAnyAttribute.call(this, token);
    if (tag) {
      tag.attributes.push({ type: "mdxJsxAttribute", name: "", value: null });
    }
  };
  const enterMdxJsxTagExpressionAttribute = function(token) {
    const tag = this.getData("mdxJsxTag");
    enterMdxJsxTagAnyAttribute.call(this, token);
    if (tag) {
      tag.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" });
    }
    this.buffer();
  };
  const exitMdxJsxTagExpressionAttribute = function(token) {
    const tag = this.getData("mdxJsxTag");
    if (tag) {
      const tail = tag.attributes[tag.attributes.length - 1];
      const estree = token.estree;
      if (tail) {
        tail.value = this.resume();
        if (estree) {
          tail.data = { estree };
        }
      }
    }
  };
  const exitMdxJsxTagAttributeNamePrimary = function(token) {
    const tag = this.getData("mdxJsxTag");
    if (tag) {
      const node2 = tag.attributes[tag.attributes.length - 1];
      if (node2) {
        node2.name = this.sliceSerialize(token);
      }
    }
  };
  const exitMdxJsxTagAttributeNameLocal = function(token) {
    const tag = this.getData("mdxJsxTag");
    if (tag) {
      const node2 = tag.attributes[tag.attributes.length - 1];
      if (node2) {
        node2.name += ":" + this.sliceSerialize(token);
      }
    }
  };
  const exitMdxJsxTagAttributeValueLiteral = function() {
    const tag = this.getData("mdxJsxTag");
    if (tag) {
      const attribute = tag.attributes[tag.attributes.length - 1];
      if (attribute) {
        if (attribute.name === "") {
          attribute.name = "_value";
        }
        attribute.value = parseEntities(this.resume(), {
          nonTerminated: false
        });
      }
    }
  };
  const exitMdxJsxTagAttributeValueExpression = function(token) {
    const tag = this.getData("mdxJsxTag");
    if (!tag) return;
    const tail = tag.attributes[tag.attributes.length - 1];
    const node2 = {
      type: "mdxJsxAttributeValueExpression",
      value: this.resume()
    };
    const estree = token.estree;
    if (estree) {
      node2.data = { estree };
    }
    if (tail) {
      tail.value = node2;
    }
  };
  const exitMdxJsxTagSelfClosingMarker = function() {
    const tag = this.getData("mdxJsxTag");
    if (tag) {
      tag.selfClosing = true;
    }
  };
  const exitMdxJsxTag = function(token) {
    const tag = this.getData("mdxJsxTag");
    const stack = this.getData("mdxJsxTagStack");
    if (!stack) return;
    const tail = stack[stack.length - 1];
    if (!tag) return;
    if (tail && tag.close && tail.name !== tag.name) {
      throw new VFileMessage(
        "Unexpected closing tag `" + serializeAbbreviatedTag(tag) + "`, expected corresponding closing tag for `" + serializeAbbreviatedTag(tail) + "` (" + stringifyPosition(tail) + ")",
        { start: token.start, end: token.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    }
    this.resume();
    if (tag.close) {
      stack.pop();
    } else {
      const pattern = patterns.find((pattern2) => pattern2.name === tag.name);
      const tagName = pattern?.templateName || tag.name;
      this.enter(
        {
          type: token.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
          name: tagName || null,
          attributes: tag.attributes,
          children: []
        },
        token,
        // This template allows block children, so
        // we didn't mark it as self-closing. But
        // We didn't receive a closing tag, so close it now.
        // Without this, we would be calling onErrorRightIsTag
        (left, right) => {
          this.exit(right);
        }
      );
    }
    if (tag.selfClosing || tag.close) {
      if (tag.shouldFallback) {
        if (token.type === "mdxJsxFlowTag") {
          this.enter(
            {
              type: "paragraph",
              children: [{ type: "text", value: this.sliceSerialize(token) }]
            },
            token
          );
          this.exit(token);
        } else {
          this.enter(
            {
              type: "text",
              value: this.sliceSerialize(token)
            },
            token
          );
          this.exit(token);
        }
      } else {
        this.exit(token, onErrorLeftIsTag);
      }
    } else {
      stack.push(tag);
    }
  };
  const onErrorRightIsTag = function(closing, open) {
    const tag = this.getData("mdxJsxTag");
    if (!tag) return;
    const place = closing ? " before the end of `" + closing.type + "`" : "";
    const position2 = closing ? { start: closing.start, end: closing.end } : void 0;
    throw new VFileMessage(
      "Expected a closing tag for `" + serializeAbbreviatedTag(tag) + "` (" + stringifyPosition({ start: open.start, end: open.end }) + ")" + place,
      position2,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  };
  const onErrorLeftIsTag = function(a, b) {
    const tag = (
      /** @type {Tag} */
      this.getData("mdxJsxTag")
    );
  };
  function serializeAbbreviatedTag(tag) {
    return "<" + (tag.close ? "/" : "") + (tag.name || "") + ">";
  }
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: enterMdxJsxTag,
      mdxJsxFlowTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxFlowTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxFlowTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagAttributeValueLiteral: buffer2,
      mdxJsxFlowTagAttributeValueExpression: buffer2,
      mdxJsxFlowTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: enterMdxJsxTag,
      mdxJsxTextTagClosingMarker: enterMdxJsxTagClosingMarker,
      mdxJsxTextTagAttribute: enterMdxJsxTagAttribute,
      mdxJsxTextTagExpressionAttribute: enterMdxJsxTagExpressionAttribute,
      mdxJsxTextTagAttributeValueLiteral: buffer2,
      mdxJsxTextTagAttributeValueExpression: buffer2,
      mdxJsxTextTagSelfClosingMarker: enterMdxJsxTagSelfClosingMarker
    },
    exit: {
      mdxJsxFlowTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxFlowTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxFlowTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxFlowTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxFlowTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxFlowTagExpressionAttributeValue: data2,
      mdxJsxFlowTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxFlowTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxFlowTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxFlowTagAttributeValueLiteralValue: data2,
      mdxJsxFlowTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxFlowTagAttributeValueExpressionValue: data2,
      mdxJsxFlowTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxFlowTag: exitMdxJsxTag,
      mdxJsxTextTagClosingMarker: exitMdxJsxTagClosingMarker,
      mdxJsxTextTagNamePrimary: exitMdxJsxTagNamePrimary,
      mdxJsxTextTagNameMember: exitMdxJsxTagNameMember,
      mdxJsxTextTagNameLocal: exitMdxJsxTagNameLocal,
      mdxJsxTextTagExpressionAttribute: exitMdxJsxTagExpressionAttribute,
      mdxJsxTextTagExpressionAttributeValue: data2,
      mdxJsxTextTagAttributeNamePrimary: exitMdxJsxTagAttributeNamePrimary,
      mdxJsxTextTagAttributeNameLocal: exitMdxJsxTagAttributeNameLocal,
      mdxJsxTextTagAttributeValueLiteral: exitMdxJsxTagAttributeValueLiteral,
      mdxJsxTextTagAttributeValueLiteralValue: data2,
      mdxJsxTextTagAttributeValueExpression: exitMdxJsxTagAttributeValueExpression,
      mdxJsxTextTagAttributeValueExpressionValue: data2,
      mdxJsxTextTagSelfClosingMarker: exitMdxJsxTagSelfClosingMarker,
      mdxJsxTextTag: exitMdxJsxTag
    }
  };
}
var mdxJsxToMarkdown2 = function(options) {
  const patterns = options.patterns || [];
  const options_ = options || {};
  const quote = options_.quote || '"';
  const quoteSmart = options_.quoteSmart || false;
  const tightSelfClosing = options_.tightSelfClosing || false;
  const printWidth = options_.printWidth || Number.POSITIVE_INFINITY;
  const alternative = quote === '"' ? "'" : '"';
  if (quote !== '"' && quote !== "'") {
    throw new Error(
      "Cannot serialize attribute values with `" + quote + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  const mdxElement = function(node2, _, context, safeOptions) {
    const pattern = patterns.find((p) => p.templateName === node2.name);
    if (!pattern) {
      return "";
    }
    const patternName = pattern.name || pattern?.templateName;
    const tracker = track(safeOptions);
    const selfClosing = pattern.leaf;
    const exit3 = context.enter(node2.type);
    let index2 = -1;
    const serializedAttributes = [];
    let value = tracker.move(pattern.start + " " + (patternName || ""));
    if (node2.attributes && node2.attributes.length > 0) {
      if (!node2.name) {
        throw new Error("Cannot serialize fragment w/ attributes");
      }
      while (++index2 < node2.attributes.length) {
        const attribute = node2.attributes[index2];
        let result;
        if (attribute?.type === "mdxJsxExpressionAttribute") {
          result = "{" + (attribute.value || "") + "}";
        } else {
          if (!attribute?.name) {
            throw new Error("Cannot serialize attribute w/o name");
          }
          const value2 = attribute.value;
          const left = attribute.name;
          let right = "";
          if (value2 === void 0 || value2 === null) {
          } else if (typeof value2 === "object") {
            right = "{" + (value2.value || "") + "}";
          } else {
            const appliedQuote = quoteSmart && ccount(value2, quote) > ccount(value2, alternative) ? alternative : quote;
            right = appliedQuote + stringifyEntitiesLight(value2, { subset: [appliedQuote] }) + appliedQuote;
          }
          if (left === "_value") {
            result = right;
          } else {
            result = left + (right ? "=" : "") + right;
          }
        }
        serializedAttributes.push(result);
      }
    }
    let attributesOnTheirOwnLine = false;
    const attributesOnOneLine = serializedAttributes.join(" ");
    if (
      // Block:
      node2.type === "mdxJsxFlowElement" && // Including a line ending (expressions).
      (/\r?\n|\r/.test(attributesOnOneLine) || // Current position (including `<tag`).
      tracker.current().now.column + // -1 because columns, +1 for ` ` before attributes.
      // Attributes joined by spaces.
      attributesOnOneLine.length + // ` />`.
      (selfClosing ? tightSelfClosing ? 2 : 3 : 1) > printWidth)
    ) {
      attributesOnTheirOwnLine = true;
    }
    if (attributesOnTheirOwnLine) {
      value += tracker.move(
        "\n" + indentLines(serializedAttributes.join("\n"), map4)
      );
    } else if (attributesOnOneLine) {
      value += tracker.move(" " + attributesOnOneLine);
    }
    if (attributesOnTheirOwnLine) {
      value += tracker.move("\n");
    }
    if (selfClosing) {
      value += tracker.move(
        tightSelfClosing || attributesOnTheirOwnLine ? "" : ""
      );
    }
    value += tracker.move(" " + pattern.end);
    if (node2.children) {
      if (node2.type === "mdxJsxFlowElement") {
        const emptyChildren = node2.children.length === 1 && node2.children[0]?.type === "paragraph" && node2.children[0].children[0]?.type === "text" && node2.children[0].children[0].value === "";
        if (!emptyChildren) {
          tracker.shift(2);
          value += tracker.move("\n");
          value += tracker.move(
            containerFlow(node2, context, tracker.current())
          );
          value += tracker.move("\n");
        }
      } else {
        value += tracker.move(
          containerPhrasing(node2, context, {
            ...tracker.current(),
            before: "<",
            after: ">"
          })
        );
      }
    }
    if (!selfClosing) {
      const closingTag = pattern.start + " /" + (patternName || " ") + " " + pattern.end;
      value += tracker.move(closingTag);
    }
    exit3();
    return value;
  };
  const map4 = function(line2, _, blank) {
    return (blank ? "" : "  ") + line2;
  };
  const peekElement = function() {
    return "<";
  };
  mdxElement.peek = peekElement;
  return {
    ...options,
    handlers: {
      mdxJsxFlowElement: mdxElement,
      mdxJsxTextElement: mdxElement
    },
    unsafe: [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: true, character: "<" }
    ],
    // Always generate fenced code (never indented code).
    fences: true,
    // Always generate links with resources (never autolinks).
    resourceLink: true
  };
};

// src/next/util.ts
var getFieldPatterns = (field) => {
  const patterns = [];
  const templates = [];
  hoistAllTemplates(field, templates);
  templates?.forEach((template) => {
    if (typeof template === "string") {
      throw new Error("Global templates not supported");
    }
    if (template.match) {
      patterns.push({
        start: template.match.start,
        end: template.match.end,
        name: template.match.name || template.name,
        templateName: template.name,
        type: template.inline ? "inline" : "flow",
        leaf: !template.fields.some((f) => f.name === "children")
      });
    }
  });
  return patterns;
};
var hoistAllTemplates = (field, templates = []) => {
  field.templates?.forEach((template) => {
    if (typeof template === "string") {
      throw new Error("Global templates not supported");
    }
    templates.push(template);
    template.fields.forEach((field2) => {
      if (field2.type === "rich-text") {
        hoistAllTemplates(field2, templates);
      }
    });
  });
  return templates;
};

// src/next/stringify/to-markdown.ts
var toTinaMarkdown = (tree, field) => {
  const patterns = getFieldPatterns(field);
  const handlers = {};
  handlers["text"] = (node2, parent, context, safeOptions) => {
    context.unsafe = context.unsafe.filter((unsafeItem) => {
      if (unsafeItem.character === " " && unsafeItem.inConstruct === "phrasing") {
        return false;
      }
      return true;
    });
    if (field.parser?.type === "markdown") {
      if (field.parser.skipEscaping === "all") {
        return node2.value;
      }
      if (field.parser.skipEscaping === "html") {
        context.unsafe = context.unsafe.filter((unsafeItem) => {
          if (unsafeItem.character === "<") {
            return false;
          }
          return true;
        });
      }
    }
    return text3(node2, parent, context, safeOptions);
  };
  return toMarkdown(tree, {
    extensions: [mdxJsxToMarkdown2({ patterns }), gfmToMarkdown()],
    listItemIndent: "one",
    handlers
  });
};

// ../../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/esm/standalone.mjs
var Te = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
var pt = Te((Vg, ou) => {
  var ur = function(e) {
    return e && e.Math == Math && e;
  };
  ou.exports = ur(typeof globalThis == "object" && globalThis) || ur(typeof window == "object" && window) || ur(typeof self == "object" && self) || ur(typeof global == "object" && global) || /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")();
});
var Dt = Te((Wg, lu) => {
  lu.exports = function(e) {
    try {
      return !!e();
    } catch {
      return true;
    }
  };
});
var yt = Te((Hg, cu) => {
  var wo = Dt();
  cu.exports = !wo(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
});
var sr = Te((Gg, pu) => {
  var _o = Dt();
  pu.exports = !_o(function() {
    var e = function() {
    }.bind();
    return typeof e != "function" || e.hasOwnProperty("prototype");
  });
});
var At = Te((Ug, fu) => {
  var Po = sr(), ir = Function.prototype.call;
  fu.exports = Po ? ir.bind(ir) : function() {
    return ir.apply(ir, arguments);
  };
});
var gu = Te((du) => {
  "use strict";
  var Du = {}.propertyIsEnumerable, mu = Object.getOwnPropertyDescriptor, Io = mu && !Du.call({ 1: 2 }, 1);
  du.f = Io ? function(r) {
    var t = mu(this, r);
    return !!t && t.enumerable;
  } : Du;
});
var ar = Te((zg, yu) => {
  yu.exports = function(e, r) {
    return { enumerable: !(e & 1), configurable: !(e & 2), writable: !(e & 4), value: r };
  };
});
var mt = Te((Xg, Cu) => {
  var hu = sr(), vu = Function.prototype, $r = vu.call, ko = hu && vu.bind.bind($r, $r);
  Cu.exports = hu ? ko : function(e) {
    return function() {
      return $r.apply(e, arguments);
    };
  };
});
var Rt = Te((Kg, Fu) => {
  var Eu = mt(), Lo = Eu({}.toString), Oo = Eu("".slice);
  Fu.exports = function(e) {
    return Oo(Lo(e), 8, -1);
  };
});
var Su = Te((Yg, Au) => {
  var jo = mt(), qo = Dt(), Mo = Rt(), Vr = Object, Ro = jo("".split);
  Au.exports = qo(function() {
    return !Vr("z").propertyIsEnumerable(0);
  }) ? function(e) {
    return Mo(e) == "String" ? Ro(e, "") : Vr(e);
  } : Vr;
});
var or = Te((Qg, xu) => {
  xu.exports = function(e) {
    return e == null;
  };
});
var Wr = Te((Zg, bu) => {
  var $o = or(), Vo = TypeError;
  bu.exports = function(e) {
    if ($o(e)) throw Vo("Can't call method on " + e);
    return e;
  };
});
var lr = Te((e0, Tu) => {
  var Wo = Su(), Ho = Wr();
  Tu.exports = function(e) {
    return Wo(Ho(e));
  };
});
var Gr = Te((t0, Bu) => {
  var Hr = typeof document == "object" && document.all, Go = typeof Hr > "u" && Hr !== void 0;
  Bu.exports = { all: Hr, IS_HTMLDDA: Go };
});
var ot = Te((r0, wu) => {
  var Nu = Gr(), Uo = Nu.all;
  wu.exports = Nu.IS_HTMLDDA ? function(e) {
    return typeof e == "function" || e === Uo;
  } : function(e) {
    return typeof e == "function";
  };
});
var St = Te((n0, Iu) => {
  var _u = ot(), Pu = Gr(), Jo = Pu.all;
  Iu.exports = Pu.IS_HTMLDDA ? function(e) {
    return typeof e == "object" ? e !== null : _u(e) || e === Jo;
  } : function(e) {
    return typeof e == "object" ? e !== null : _u(e);
  };
});
var $t = Te((u0, ku) => {
  var Ur = pt(), zo = ot(), Xo = function(e) {
    return zo(e) ? e : void 0;
  };
  ku.exports = function(e, r) {
    return arguments.length < 2 ? Xo(Ur[e]) : Ur[e] && Ur[e][r];
  };
});
var Jr = Te((s0, Lu) => {
  var Ko = mt();
  Lu.exports = Ko({}.isPrototypeOf);
});
var ju = Te((i0, Ou) => {
  var Yo = $t();
  Ou.exports = Yo("navigator", "userAgent") || "";
});
var Hu = Te((a0, Wu) => {
  var Vu = pt(), zr = ju(), qu = Vu.process, Mu = Vu.Deno, Ru = qu && qu.versions || Mu && Mu.version, $u = Ru && Ru.v8, dt, cr2;
  $u && (dt = $u.split("."), cr2 = dt[0] > 0 && dt[0] < 4 ? 1 : +(dt[0] + dt[1]));
  !cr2 && zr && (dt = zr.match(/Edge\/(\d+)/), (!dt || dt[1] >= 74) && (dt = zr.match(/Chrome\/(\d+)/), dt && (cr2 = +dt[1])));
  Wu.exports = cr2;
});
var Xr = Te((o0, Uu) => {
  var Gu = Hu(), Qo = Dt();
  Uu.exports = !!Object.getOwnPropertySymbols && !Qo(function() {
    var e = Symbol();
    return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && Gu && Gu < 41;
  });
});
var Kr = Te((l0, Ju) => {
  var Zo = Xr();
  Ju.exports = Zo && !Symbol.sham && typeof Symbol.iterator == "symbol";
});
var Yr = Te((c0, zu) => {
  var el = $t(), tl = ot(), rl = Jr(), nl = Kr(), ul = Object;
  zu.exports = nl ? function(e) {
    return typeof e == "symbol";
  } : function(e) {
    var r = el("Symbol");
    return tl(r) && rl(r.prototype, ul(e));
  };
});
var pr = Te((p0, Xu) => {
  var sl = String;
  Xu.exports = function(e) {
    try {
      return sl(e);
    } catch {
      return "Object";
    }
  };
});
var Vt = Te((f0, Ku) => {
  var il = ot(), al = pr(), ol = TypeError;
  Ku.exports = function(e) {
    if (il(e)) return e;
    throw ol(al(e) + " is not a function");
  };
});
var fr = Te((D0, Yu) => {
  var ll = Vt(), cl = or();
  Yu.exports = function(e, r) {
    var t = e[r];
    return cl(t) ? void 0 : ll(t);
  };
});
var Zu = Te((m0, Qu) => {
  var Qr = At(), Zr = ot(), en = St(), pl = TypeError;
  Qu.exports = function(e, r) {
    var t, s;
    if (r === "string" && Zr(t = e.toString) && !en(s = Qr(t, e)) || Zr(t = e.valueOf) && !en(s = Qr(t, e)) || r !== "string" && Zr(t = e.toString) && !en(s = Qr(t, e))) return s;
    throw pl("Can't convert object to primitive value");
  };
});
var ts = Te((d0, es) => {
  es.exports = false;
});
var Dr = Te((g0, ns) => {
  var rs = pt(), fl = Object.defineProperty;
  ns.exports = function(e, r) {
    try {
      fl(rs, e, { value: r, configurable: true, writable: true });
    } catch {
      rs[e] = r;
    }
    return r;
  };
});
var mr = Te((y0, ss2) => {
  var Dl = pt(), ml = Dr(), us = "__core-js_shared__", dl = Dl[us] || ml(us, {});
  ss2.exports = dl;
});
var tn = Te((h0, as) => {
  var gl = ts(), is3 = mr();
  (as.exports = function(e, r) {
    return is3[e] || (is3[e] = r !== void 0 ? r : {});
  })("versions", []).push({ version: "3.26.1", mode: gl ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
});
var dr = Te((v0, os2) => {
  var yl = Wr(), hl = Object;
  os2.exports = function(e) {
    return hl(yl(e));
  };
});
var Ct = Te((C0, ls) => {
  var vl = mt(), Cl = dr(), El = vl({}.hasOwnProperty);
  ls.exports = Object.hasOwn || function(r, t) {
    return El(Cl(r), t);
  };
});
var rn = Te((E0, cs) => {
  var Fl = mt(), Al = 0, Sl = Math.random(), xl = Fl(1 .toString);
  cs.exports = function(e) {
    return "Symbol(" + (e === void 0 ? "" : e) + ")_" + xl(++Al + Sl, 36);
  };
});
var bt = Te((F0, ds) => {
  var bl = pt(), Tl = tn(), ps2 = Ct(), Bl = rn(), fs = Xr(), ms = Kr(), Pt = Tl("wks"), xt = bl.Symbol, Ds = xt && xt.for, Nl = ms ? xt : xt && xt.withoutSetter || Bl;
  ds.exports = function(e) {
    if (!ps2(Pt, e) || !(fs || typeof Pt[e] == "string")) {
      var r = "Symbol." + e;
      fs && ps2(xt, e) ? Pt[e] = xt[e] : ms && Ds ? Pt[e] = Ds(r) : Pt[e] = Nl(r);
    }
    return Pt[e];
  };
});
var vs = Te((A0, hs) => {
  var wl = At(), gs2 = St(), ys = Yr(), _l = fr(), Pl = Zu(), Il = bt(), kl = TypeError, Ll = Il("toPrimitive");
  hs.exports = function(e, r) {
    if (!gs2(e) || ys(e)) return e;
    var t = _l(e, Ll), s;
    if (t) {
      if (r === void 0 && (r = "default"), s = wl(t, e, r), !gs2(s) || ys(s)) return s;
      throw kl("Can't convert object to primitive value");
    }
    return r === void 0 && (r = "number"), Pl(e, r);
  };
});
var gr = Te((S0, Cs) => {
  var Ol = vs(), jl = Yr();
  Cs.exports = function(e) {
    var r = Ol(e, "string");
    return jl(r) ? r : r + "";
  };
});
var As = Te((x0, Fs) => {
  var ql = pt(), Es = St(), nn = ql.document, Ml = Es(nn) && Es(nn.createElement);
  Fs.exports = function(e) {
    return Ml ? nn.createElement(e) : {};
  };
});
var un = Te((b0, Ss) => {
  var Rl = yt(), $l = Dt(), Vl = As();
  Ss.exports = !Rl && !$l(function() {
    return Object.defineProperty(Vl("div"), "a", { get: function() {
      return 7;
    } }).a != 7;
  });
});
var sn = Te((bs) => {
  var Wl = yt(), Hl = At(), Gl = gu(), Ul = ar(), Jl = lr(), zl = gr(), Xl = Ct(), Kl = un(), xs = Object.getOwnPropertyDescriptor;
  bs.f = Wl ? xs : function(r, t) {
    if (r = Jl(r), t = zl(t), Kl) try {
      return xs(r, t);
    } catch {
    }
    if (Xl(r, t)) return Ul(!Hl(Gl.f, r, t), r[t]);
  };
});
var Bs = Te((B0, Ts) => {
  var Yl = yt(), Ql = Dt();
  Ts.exports = Yl && Ql(function() {
    return Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype != 42;
  });
});
var Tt = Te((N0, Ns) => {
  var Zl = St(), ec = String, tc = TypeError;
  Ns.exports = function(e) {
    if (Zl(e)) return e;
    throw tc(ec(e) + " is not an object");
  };
});
var It = Te((_s2) => {
  var rc = yt(), nc = un(), uc = Bs(), yr = Tt(), ws2 = gr(), sc = TypeError, an = Object.defineProperty, ic = Object.getOwnPropertyDescriptor, on = "enumerable", ln = "configurable", cn = "writable";
  _s2.f = rc ? uc ? function(r, t, s) {
    if (yr(r), t = ws2(t), yr(s), typeof r == "function" && t === "prototype" && "value" in s && cn in s && !s[cn]) {
      var a = ic(r, t);
      a && a[cn] && (r[t] = s.value, s = { configurable: ln in s ? s[ln] : a[ln], enumerable: on in s ? s[on] : a[on], writable: false });
    }
    return an(r, t, s);
  } : an : function(r, t, s) {
    if (yr(r), t = ws2(t), yr(s), nc) try {
      return an(r, t, s);
    } catch {
    }
    if ("get" in s || "set" in s) throw sc("Accessors not supported");
    return "value" in s && (r[t] = s.value), r;
  };
});
var pn = Te((_0, Ps2) => {
  var ac = yt(), oc = It(), lc = ar();
  Ps2.exports = ac ? function(e, r, t) {
    return oc.f(e, r, lc(1, t));
  } : function(e, r, t) {
    return e[r] = t, e;
  };
});
var Ls = Te((P0, ks) => {
  var fn = yt(), cc = Ct(), Is = Function.prototype, pc = fn && Object.getOwnPropertyDescriptor, Dn = cc(Is, "name"), fc = Dn && function() {
  }.name === "something", Dc = Dn && (!fn || fn && pc(Is, "name").configurable);
  ks.exports = { EXISTS: Dn, PROPER: fc, CONFIGURABLE: Dc };
});
var dn = Te((I0, Os) => {
  var mc2 = mt(), dc = ot(), mn = mr(), gc = mc2(Function.toString);
  dc(mn.inspectSource) || (mn.inspectSource = function(e) {
    return gc(e);
  });
  Os.exports = mn.inspectSource;
});
var Ms = Te((k0, qs) => {
  var yc = pt(), hc = ot(), js = yc.WeakMap;
  qs.exports = hc(js) && /native code/.test(String(js));
});
var Vs = Te((L0, $s) => {
  var vc = tn(), Cc = rn(), Rs = vc("keys");
  $s.exports = function(e) {
    return Rs[e] || (Rs[e] = Cc(e));
  };
});
var gn = Te((O0, Ws2) => {
  Ws2.exports = {};
});
var Js = Te((j0, Us) => {
  var Ec = Ms(), Gs = pt(), Fc = St(), Ac = pn(), yn = Ct(), hn = mr(), Sc = Vs(), xc = gn(), Hs2 = "Object already initialized", vn = Gs.TypeError, bc = Gs.WeakMap, hr2, Wt2, vr, Tc = function(e) {
    return vr(e) ? Wt2(e) : hr2(e, {});
  }, Bc = function(e) {
    return function(r) {
      var t;
      if (!Fc(r) || (t = Wt2(r)).type !== e) throw vn("Incompatible receiver, " + e + " required");
      return t;
    };
  };
  Ec || hn.state ? (gt = hn.state || (hn.state = new bc()), gt.get = gt.get, gt.has = gt.has, gt.set = gt.set, hr2 = function(e, r) {
    if (gt.has(e)) throw vn(Hs2);
    return r.facade = e, gt.set(e, r), r;
  }, Wt2 = function(e) {
    return gt.get(e) || {};
  }, vr = function(e) {
    return gt.has(e);
  }) : (Bt = Sc("state"), xc[Bt] = true, hr2 = function(e, r) {
    if (yn(e, Bt)) throw vn(Hs2);
    return r.facade = e, Ac(e, Bt, r), r;
  }, Wt2 = function(e) {
    return yn(e, Bt) ? e[Bt] : {};
  }, vr = function(e) {
    return yn(e, Bt);
  });
  var gt, Bt;
  Us.exports = { set: hr2, get: Wt2, has: vr, enforce: Tc, getterFor: Bc };
});
var En = Te((q0, Xs2) => {
  var Nc = Dt(), wc = ot(), Cr = Ct(), Cn = yt(), _c = Ls().CONFIGURABLE, Pc = dn(), zs = Js(), Ic = zs.enforce, kc = zs.get, Er = Object.defineProperty, Lc = Cn && !Nc(function() {
    return Er(function() {
    }, "length", { value: 8 }).length !== 8;
  }), Oc = String(String).split("String"), jc = Xs2.exports = function(e, r, t) {
    String(r).slice(0, 7) === "Symbol(" && (r = "[" + String(r).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), t && t.getter && (r = "get " + r), t && t.setter && (r = "set " + r), (!Cr(e, "name") || _c && e.name !== r) && (Cn ? Er(e, "name", { value: r, configurable: true }) : e.name = r), Lc && t && Cr(t, "arity") && e.length !== t.arity && Er(e, "length", { value: t.arity });
    try {
      t && Cr(t, "constructor") && t.constructor ? Cn && Er(e, "prototype", { writable: false }) : e.prototype && (e.prototype = void 0);
    } catch {
    }
    var s = Ic(e);
    return Cr(s, "source") || (s.source = Oc.join(typeof r == "string" ? r : "")), e;
  };
  Function.prototype.toString = jc(function() {
    return wc(this) && kc(this).source || Pc(this);
  }, "toString");
});
var Ys = Te((M0, Ks) => {
  var qc = ot(), Mc = It(), Rc = En(), $c = Dr();
  Ks.exports = function(e, r, t, s) {
    s || (s = {});
    var a = s.enumerable, n = s.name !== void 0 ? s.name : r;
    if (qc(t) && Rc(t, n, s), s.global) a ? e[r] = t : $c(r, t);
    else {
      try {
        s.unsafe ? e[r] && (a = true) : delete e[r];
      } catch {
      }
      a ? e[r] = t : Mc.f(e, r, { value: t, enumerable: false, configurable: !s.nonConfigurable, writable: !s.nonWritable });
    }
    return e;
  };
});
var Zs = Te((R0, Qs2) => {
  var Vc = Math.ceil, Wc = Math.floor;
  Qs2.exports = Math.trunc || function(r) {
    var t = +r;
    return (t > 0 ? Wc : Vc)(t);
  };
});
var Fr = Te(($0, ei) => {
  var Hc = Zs();
  ei.exports = function(e) {
    var r = +e;
    return r !== r || r === 0 ? 0 : Hc(r);
  };
});
var ri = Te((V0, ti) => {
  var Gc = Fr(), Uc = Math.max, Jc = Math.min;
  ti.exports = function(e, r) {
    var t = Gc(e);
    return t < 0 ? Uc(t + r, 0) : Jc(t, r);
  };
});
var ui = Te((W0, ni) => {
  var zc = Fr(), Xc = Math.min;
  ni.exports = function(e) {
    return e > 0 ? Xc(zc(e), 9007199254740991) : 0;
  };
});
var kt = Te((H0, si) => {
  var Kc = ui();
  si.exports = function(e) {
    return Kc(e.length);
  };
});
var oi = Te((G0, ai2) => {
  var Yc = lr(), Qc = ri(), Zc = kt(), ii = function(e) {
    return function(r, t, s) {
      var a = Yc(r), n = Zc(a), u = Qc(s, n), i;
      if (e && t != t) {
        for (; n > u; ) if (i = a[u++], i != i) return true;
      } else for (; n > u; u++) if ((e || u in a) && a[u] === t) return e || u || 0;
      return !e && -1;
    };
  };
  ai2.exports = { includes: ii(true), indexOf: ii(false) };
});
var pi = Te((U0, ci) => {
  var ep = mt(), Fn = Ct(), tp = lr(), rp = oi().indexOf, np = gn(), li = ep([].push);
  ci.exports = function(e, r) {
    var t = tp(e), s = 0, a = [], n;
    for (n in t) !Fn(np, n) && Fn(t, n) && li(a, n);
    for (; r.length > s; ) Fn(t, n = r[s++]) && (~rp(a, n) || li(a, n));
    return a;
  };
});
var Di = Te((J0, fi) => {
  fi.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
});
var di = Te((mi) => {
  var up = pi(), sp = Di(), ip = sp.concat("length", "prototype");
  mi.f = Object.getOwnPropertyNames || function(r) {
    return up(r, ip);
  };
});
var yi = Te((gi) => {
  gi.f = Object.getOwnPropertySymbols;
});
var vi = Te((K0, hi) => {
  var ap = $t(), op = mt(), lp = di(), cp = yi(), pp2 = Tt(), fp = op([].concat);
  hi.exports = ap("Reflect", "ownKeys") || function(r) {
    var t = lp.f(pp2(r)), s = cp.f;
    return s ? fp(t, s(r)) : t;
  };
});
var Fi = Te((Y0, Ei) => {
  var Ci2 = Ct(), Dp = vi(), mp = sn(), dp = It();
  Ei.exports = function(e, r, t) {
    for (var s = Dp(r), a = dp.f, n = mp.f, u = 0; u < s.length; u++) {
      var i = s[u];
      !Ci2(e, i) && !(t && Ci2(t, i)) && a(e, i, n(r, i));
    }
  };
});
var Si = Te((Q0, Ai) => {
  var gp = Dt(), yp = ot(), hp = /#|\.prototype\./, Ht = function(e, r) {
    var t = Cp[vp(e)];
    return t == Fp ? true : t == Ep ? false : yp(r) ? gp(r) : !!r;
  }, vp = Ht.normalize = function(e) {
    return String(e).replace(hp, ".").toLowerCase();
  }, Cp = Ht.data = {}, Ep = Ht.NATIVE = "N", Fp = Ht.POLYFILL = "P";
  Ai.exports = Ht;
});
var Gt = Te((Z0, xi) => {
  var An = pt(), Ap = sn().f, Sp = pn(), xp = Ys(), bp = Dr(), Tp = Fi(), Bp = Si();
  xi.exports = function(e, r) {
    var t = e.target, s = e.global, a = e.stat, n, u, i, l, p, d;
    if (s ? u = An : a ? u = An[t] || bp(t, {}) : u = (An[t] || {}).prototype, u) for (i in r) {
      if (p = r[i], e.dontCallGetSet ? (d = Ap(u, i), l = d && d.value) : l = u[i], n = Bp(s ? i : t + (a ? "." : "#") + i, e.forced), !n && l !== void 0) {
        if (typeof p == typeof l) continue;
        Tp(p, l);
      }
      (e.sham || l && l.sham) && Sp(p, "sham", true), xp(u, i, p, e);
    }
  };
});
var Sn = Te((ey, bi) => {
  var Np = Rt();
  bi.exports = Array.isArray || function(r) {
    return Np(r) == "Array";
  };
});
var Bi = Te((ty, Ti) => {
  var wp = TypeError, _p = 9007199254740991;
  Ti.exports = function(e) {
    if (e > _p) throw wp("Maximum allowed index exceeded");
    return e;
  };
});
var wi = Te((ry, Ni2) => {
  var Pp = Rt(), Ip = mt();
  Ni2.exports = function(e) {
    if (Pp(e) === "Function") return Ip(e);
  };
});
var xn = Te((ny, Pi) => {
  var _i = wi(), kp = Vt(), Lp = sr(), Op = _i(_i.bind);
  Pi.exports = function(e, r) {
    return kp(e), r === void 0 ? e : Lp ? Op(e, r) : function() {
      return e.apply(r, arguments);
    };
  };
});
var bn = Te((uy, ki) => {
  "use strict";
  var jp = Sn(), qp = kt(), Mp = Bi(), Rp = xn(), Ii = function(e, r, t, s, a, n, u, i) {
    for (var l = a, p = 0, d = u ? Rp(u, i) : false, y, g; p < s; ) p in t && (y = d ? d(t[p], p, r) : t[p], n > 0 && jp(y) ? (g = qp(y), l = Ii(e, r, y, g, l, n - 1) - 1) : (Mp(l + 1), e[l] = y), l++), p++;
    return l;
  };
  ki.exports = Ii;
});
var ji = Te((sy, Oi) => {
  var $p = bt(), Vp = $p("toStringTag"), Li2 = {};
  Li2[Vp] = "z";
  Oi.exports = String(Li2) === "[object z]";
});
var Tn = Te((iy, qi2) => {
  var Wp = ji(), Hp = ot(), Ar = Rt(), Gp = bt(), Up = Gp("toStringTag"), Jp = Object, zp = Ar(/* @__PURE__ */ function() {
    return arguments;
  }()) == "Arguments", Xp = function(e, r) {
    try {
      return e[r];
    } catch {
    }
  };
  qi2.exports = Wp ? Ar : function(e) {
    var r, t, s;
    return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (t = Xp(r = Jp(e), Up)) == "string" ? t : zp ? Ar(r) : (s = Ar(r)) == "Object" && Hp(r.callee) ? "Arguments" : s;
  };
});
var Hi = Te((ay, Wi) => {
  var Kp = mt(), Yp = Dt(), Mi = ot(), Qp = Tn(), Zp = $t(), ef = dn(), Ri2 = function() {
  }, tf = [], $i = Zp("Reflect", "construct"), Bn = /^\s*(?:class|function)\b/, rf = Kp(Bn.exec), nf = !Bn.exec(Ri2), Ut = function(r) {
    if (!Mi(r)) return false;
    try {
      return $i(Ri2, tf, r), true;
    } catch {
      return false;
    }
  }, Vi = function(r) {
    if (!Mi(r)) return false;
    switch (Qp(r)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return false;
    }
    try {
      return nf || !!rf(Bn, ef(r));
    } catch {
      return true;
    }
  };
  Vi.sham = true;
  Wi.exports = !$i || Yp(function() {
    var e;
    return Ut(Ut.call) || !Ut(Object) || !Ut(function() {
      e = true;
    }) || e;
  }) ? Vi : Ut;
});
var zi = Te((oy, Ji) => {
  var Gi = Sn(), uf = Hi(), sf = St(), af = bt(), of = af("species"), Ui2 = Array;
  Ji.exports = function(e) {
    var r;
    return Gi(e) && (r = e.constructor, uf(r) && (r === Ui2 || Gi(r.prototype)) ? r = void 0 : sf(r) && (r = r[of], r === null && (r = void 0))), r === void 0 ? Ui2 : r;
  };
});
var Nn = Te((ly, Xi) => {
  var lf = zi();
  Xi.exports = function(e, r) {
    return new (lf(e))(r === 0 ? 0 : r);
  };
});
var wn = Te((cy, Ki) => {
  Ki.exports = {};
});
var Qi = Te((py, Yi) => {
  var gf = bt(), yf = wn(), hf = gf("iterator"), vf = Array.prototype;
  Yi.exports = function(e) {
    return e !== void 0 && (yf.Array === e || vf[hf] === e);
  };
});
var _n = Te((fy, ea) => {
  var Cf = Tn(), Zi = fr(), Ef = or(), Ff = wn(), Af = bt(), Sf = Af("iterator");
  ea.exports = function(e) {
    if (!Ef(e)) return Zi(e, Sf) || Zi(e, "@@iterator") || Ff[Cf(e)];
  };
});
var ra = Te((Dy, ta) => {
  var xf = At(), bf = Vt(), Tf = Tt(), Bf = pr(), Nf = _n(), wf = TypeError;
  ta.exports = function(e, r) {
    var t = arguments.length < 2 ? Nf(e) : r;
    if (bf(t)) return Tf(xf(t, e));
    throw wf(Bf(e) + " is not iterable");
  };
});
var sa = Te((my, ua) => {
  var _f = At(), na2 = Tt(), Pf = fr();
  ua.exports = function(e, r, t) {
    var s, a;
    na2(e);
    try {
      if (s = Pf(e, "return"), !s) {
        if (r === "throw") throw t;
        return t;
      }
      s = _f(s, e);
    } catch (n) {
      a = true, s = n;
    }
    if (r === "throw") throw t;
    if (a) throw s;
    return na2(s), t;
  };
});
var ca = Te((dy, la2) => {
  var If = xn(), kf = At(), Lf = Tt(), Of = pr(), jf = Qi(), qf = kt(), ia = Jr(), Mf = ra(), Rf = _n(), aa = sa(), $f = TypeError, Sr = function(e, r) {
    this.stopped = e, this.result = r;
  }, oa2 = Sr.prototype;
  la2.exports = function(e, r, t) {
    var s = t && t.that, a = !!(t && t.AS_ENTRIES), n = !!(t && t.IS_RECORD), u = !!(t && t.IS_ITERATOR), i = !!(t && t.INTERRUPTED), l = If(r, s), p, d, y, g, c, f, E2, _ = function(F) {
      return p && aa(p, "normal", F), new Sr(true, F);
    }, w = function(F) {
      return a ? (Lf(F), i ? l(F[0], F[1], _) : l(F[0], F[1])) : i ? l(F, _) : l(F);
    };
    if (n) p = e.iterator;
    else if (u) p = e;
    else {
      if (d = Rf(e), !d) throw $f(Of(e) + " is not iterable");
      if (jf(d)) {
        for (y = 0, g = qf(e); g > y; y++) if (c = w(e[y]), c && ia(oa2, c)) return c;
        return new Sr(false);
      }
      p = Mf(e, d);
    }
    for (f = n ? e.next : p.next; !(E2 = kf(f, p)).done; ) {
      try {
        c = w(E2.value);
      } catch (F) {
        aa(p, "throw", F);
      }
      if (typeof c == "object" && c && ia(oa2, c)) return c;
    }
    return new Sr(false);
  };
});
var fa = Te((gy, pa) => {
  "use strict";
  var Vf = gr(), Wf = It(), Hf = ar();
  pa.exports = function(e, r, t) {
    var s = Vf(r);
    s in e ? Wf.f(e, s, Hf(0, t)) : e[s] = t;
  };
});
var da = Te((yy, ma2) => {
  var Da2 = En(), zf = It();
  ma2.exports = function(e, r, t) {
    return t.get && Da2(t.get, r, { getter: true }), t.set && Da2(t.set, r, { setter: true }), zf.f(e, r, t);
  };
});
var ya = Te((hy, ga2) => {
  "use strict";
  var Xf = Tt();
  ga2.exports = function() {
    var e = Xf(this), r = "";
    return e.hasIndices && (r += "d"), e.global && (r += "g"), e.ignoreCase && (r += "i"), e.multiline && (r += "m"), e.dotAll && (r += "s"), e.unicode && (r += "u"), e.unicodeSets && (r += "v"), e.sticky && (r += "y"), r;
  };
});
var Ca = Te(() => {
  var rD = Gt(), Pn = pt();
  rD({ global: true, forced: Pn.globalThis !== Pn }, { globalThis: Pn });
});
var cf = Gt();
var pf = bn();
var ff = Vt();
var Df = dr();
var mf = kt();
var df = Nn();
cf({ target: "Array", proto: true }, { flatMap: function(r) {
  var t = Df(this), s = mf(t), a;
  return ff(r), a = df(t, 0), a.length = pf(a, t, t, s, 0, 1, r, arguments.length > 1 ? arguments[1] : void 0), a;
} });
var Gf = Gt();
var Uf = ca();
var Jf = fa();
Gf({ target: "Object", stat: true }, { fromEntries: function(r) {
  var t = {};
  return Uf(r, function(s, a) {
    Jf(t, s, a);
  }, { AS_ENTRIES: true }), t;
} });
var Kf = pt();
var Yf = yt();
var Qf = da();
var Zf = ya();
var eD = Dt();
var ha = Kf.RegExp;
var va = ha.prototype;
var tD = Yf && eD(function() {
  var e = true;
  try {
    ha(".", "d");
  } catch {
    e = false;
  }
  var r = {}, t = "", s = e ? "dgimsy" : "gimsy", a = function(l, p) {
    Object.defineProperty(r, l, { get: function() {
      return t += p, true;
    } });
  }, n = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
  e && (n.hasIndices = "d");
  for (var u in n) a(u, n[u]);
  var i = Object.getOwnPropertyDescriptor(va, "flags").get.call(r);
  return i !== s || t !== s;
});
tD && Qf(va, "flags", { configurable: true, get: Zf });
Ca();
var nD = Gt();
var uD = bn();
var sD = dr();
var iD = kt();
var aD = Fr();
var oD = Nn();
nD({ target: "Array", proto: true }, { flat: function() {
  var r = arguments.length ? arguments[0] : void 0, t = sD(this), s = iD(t), a = oD(t, 0);
  return a.length = uD(a, t, t, s, 0, r === void 0 ? 1 : aD(r)), a;
} });
var lD = ["cliName", "cliCategory", "cliDescription"];
var cD = ["_"];
var pD = ["languageId"];
function $n(e, r) {
  if (e == null) return {};
  var t = fD(e, r), s, a;
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (a = 0; a < n.length; a++) s = n[a], !(r.indexOf(s) >= 0) && Object.prototype.propertyIsEnumerable.call(e, s) && (t[s] = e[s]);
  }
  return t;
}
function fD(e, r) {
  if (e == null) return {};
  var t = {}, s = Object.keys(e), a, n;
  for (n = 0; n < s.length; n++) a = s[n], !(r.indexOf(a) >= 0) && (t[a] = e[a]);
  return t;
}
var DD = Object.create;
var Nr = Object.defineProperty;
var mD = Object.getOwnPropertyDescriptor;
var Vn = Object.getOwnPropertyNames;
var dD = Object.getPrototypeOf;
var gD = Object.prototype.hasOwnProperty;
var ht = (e, r) => function() {
  return e && (r = (0, e[Vn(e)[0]])(e = 0)), r;
};
var te = (e, r) => function() {
  return r || (0, e[Vn(e)[0]])((r = { exports: {} }).exports, r), r.exports;
};
var zt = (e, r) => {
  for (var t in r) Nr(e, t, { get: r[t], enumerable: true });
};
var Sa = (e, r, t, s) => {
  if (r && typeof r == "object" || typeof r == "function") for (let a of Vn(r)) !gD.call(e, a) && a !== t && Nr(e, a, { get: () => r[a], enumerable: !(s = mD(r, a)) || s.enumerable });
  return e;
};
var yD = (e, r, t) => (t = e != null ? DD(dD(e)) : {}, Sa(r || !e || !e.__esModule ? Nr(t, "default", { value: e, enumerable: true }) : t, e));
var ft = (e) => Sa(Nr({}, "__esModule", { value: true }), e);
var Nt;
var ne = ht({ "<define:process>"() {
  Nt = { env: {}, argv: [] };
} });
var xa = te({ "package.json"(e, r) {
  r.exports = { version: "2.8.8" };
} });
var hD = te({ "node_modules/diff/lib/diff/base.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.default = r;
  function r() {
  }
  r.prototype = { diff: function(n, u) {
    var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, l = i.callback;
    typeof i == "function" && (l = i, i = {}), this.options = i;
    var p = this;
    function d(N) {
      return l ? (setTimeout(function() {
        l(void 0, N);
      }, 0), true) : N;
    }
    n = this.castInput(n), u = this.castInput(u), n = this.removeEmpty(this.tokenize(n)), u = this.removeEmpty(this.tokenize(u));
    var y = u.length, g = n.length, c = 1, f = y + g, E2 = [{ newPos: -1, components: [] }], _ = this.extractCommon(E2[0], u, n, 0);
    if (E2[0].newPos + 1 >= y && _ + 1 >= g) return d([{ value: this.join(u), count: u.length }]);
    function w() {
      for (var N = -1 * c; N <= c; N += 2) {
        var x = void 0, I = E2[N - 1], P = E2[N + 1], $2 = (P ? P.newPos : 0) - N;
        I && (E2[N - 1] = void 0);
        var D = I && I.newPos + 1 < y, T = P && 0 <= $2 && $2 < g;
        if (!D && !T) {
          E2[N] = void 0;
          continue;
        }
        if (!D || T && I.newPos < P.newPos ? (x = s(P), p.pushComponent(x.components, void 0, true)) : (x = I, x.newPos++, p.pushComponent(x.components, true, void 0)), $2 = p.extractCommon(x, u, n, N), x.newPos + 1 >= y && $2 + 1 >= g) return d(t(p, x.components, u, n, p.useLongestToken));
        E2[N] = x;
      }
      c++;
    }
    if (l) (function N() {
      setTimeout(function() {
        if (c > f) return l();
        w() || N();
      }, 0);
    })();
    else for (; c <= f; ) {
      var F = w();
      if (F) return F;
    }
  }, pushComponent: function(n, u, i) {
    var l = n[n.length - 1];
    l && l.added === u && l.removed === i ? n[n.length - 1] = { count: l.count + 1, added: u, removed: i } : n.push({ count: 1, added: u, removed: i });
  }, extractCommon: function(n, u, i, l) {
    for (var p = u.length, d = i.length, y = n.newPos, g = y - l, c = 0; y + 1 < p && g + 1 < d && this.equals(u[y + 1], i[g + 1]); ) y++, g++, c++;
    return c && n.components.push({ count: c }), n.newPos = y, g;
  }, equals: function(n, u) {
    return this.options.comparator ? this.options.comparator(n, u) : n === u || this.options.ignoreCase && n.toLowerCase() === u.toLowerCase();
  }, removeEmpty: function(n) {
    for (var u = [], i = 0; i < n.length; i++) n[i] && u.push(n[i]);
    return u;
  }, castInput: function(n) {
    return n;
  }, tokenize: function(n) {
    return n.split("");
  }, join: function(n) {
    return n.join("");
  } };
  function t(a, n, u, i, l) {
    for (var p = 0, d = n.length, y = 0, g = 0; p < d; p++) {
      var c = n[p];
      if (c.removed) {
        if (c.value = a.join(i.slice(g, g + c.count)), g += c.count, p && n[p - 1].added) {
          var E2 = n[p - 1];
          n[p - 1] = n[p], n[p] = E2;
        }
      } else {
        if (!c.added && l) {
          var f = u.slice(y, y + c.count);
          f = f.map(function(w, F) {
            var N = i[g + F];
            return N.length > w.length ? N : w;
          }), c.value = a.join(f);
        } else c.value = a.join(u.slice(y, y + c.count));
        y += c.count, c.added || (g += c.count);
      }
    }
    var _ = n[d - 1];
    return d > 1 && typeof _.value == "string" && (_.added || _.removed) && a.equals("", _.value) && (n[d - 2].value += _.value, n.pop()), n;
  }
  function s(a) {
    return { newPos: a.newPos, components: a.components.slice(0) };
  }
} });
var vD = te({ "node_modules/diff/lib/diff/array.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.diffArrays = a, e.arrayDiff = void 0;
  var r = t(hD());
  function t(n) {
    return n && n.__esModule ? n : { default: n };
  }
  var s = new r.default();
  e.arrayDiff = s, s.tokenize = function(n) {
    return n.slice();
  }, s.join = s.removeEmpty = function(n) {
    return n;
  };
  function a(n, u, i) {
    return s.diff(n, u, i);
  }
} });
var Wn = te({ "src/document/doc-builders.js"(e, r) {
  "use strict";
  ne();
  function t(C) {
    return { type: "concat", parts: C };
  }
  function s(C) {
    return { type: "indent", contents: C };
  }
  function a(C, o) {
    return { type: "align", contents: o, n: C };
  }
  function n(C) {
    let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return { type: "group", id: o.id, contents: C, break: Boolean(o.shouldBreak), expandedStates: o.expandedStates };
  }
  function u(C) {
    return a(Number.NEGATIVE_INFINITY, C);
  }
  function i(C) {
    return a({ type: "root" }, C);
  }
  function l(C) {
    return a(-1, C);
  }
  function p(C, o) {
    return n(C[0], Object.assign(Object.assign({}, o), {}, { expandedStates: C }));
  }
  function d(C) {
    return { type: "fill", parts: C };
  }
  function y(C, o) {
    let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return { type: "if-break", breakContents: C, flatContents: o, groupId: h.groupId };
  }
  function g(C, o) {
    return { type: "indent-if-break", contents: C, groupId: o.groupId, negate: o.negate };
  }
  function c(C) {
    return { type: "line-suffix", contents: C };
  }
  var f = { type: "line-suffix-boundary" }, E2 = { type: "break-parent" }, _ = { type: "trim" }, w = { type: "line", hard: true }, F = { type: "line", hard: true, literal: true }, N = { type: "line" }, x = { type: "line", soft: true }, I = t([w, E2]), P = t([F, E2]), $2 = { type: "cursor", placeholder: Symbol("cursor") };
  function D(C, o) {
    let h = [];
    for (let v = 0; v < o.length; v++) v !== 0 && h.push(C), h.push(o[v]);
    return t(h);
  }
  function T(C, o, h) {
    let v = C;
    if (o > 0) {
      for (let S = 0; S < Math.floor(o / h); ++S) v = s(v);
      v = a(o % h, v), v = a(Number.NEGATIVE_INFINITY, v);
    }
    return v;
  }
  function m(C, o) {
    return { type: "label", label: C, contents: o };
  }
  r.exports = { concat: t, join: D, line: N, softline: x, hardline: I, literalline: P, group: n, conditionalGroup: p, fill: d, lineSuffix: c, lineSuffixBoundary: f, cursor: $2, breakParent: E2, ifBreak: y, trim: _, indent: s, indentIfBreak: g, align: a, addAlignmentToDoc: T, markAsRoot: i, dedentToRoot: u, dedent: l, hardlineWithoutBreakParent: w, literallineWithoutBreakParent: F, label: m };
} });
var Hn = te({ "src/common/end-of-line.js"(e, r) {
  "use strict";
  ne();
  function t(u) {
    let i = u.indexOf("\r");
    return i >= 0 ? u.charAt(i + 1) === `
` ? "crlf" : "cr" : "lf";
  }
  function s(u) {
    switch (u) {
      case "cr":
        return "\r";
      case "crlf":
        return `\r
`;
      default:
        return `
`;
    }
  }
  function a(u, i) {
    let l;
    switch (i) {
      case `
`:
        l = /\n/g;
        break;
      case "\r":
        l = /\r/g;
        break;
      case `\r
`:
        l = /\r\n/g;
        break;
      default:
        throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`);
    }
    let p = u.match(l);
    return p ? p.length : 0;
  }
  function n(u) {
    return u.replace(/\r\n?/g, `
`);
  }
  r.exports = { guessEndOfLine: t, convertEndOfLineToChars: s, countEndOfLineChars: a, normalizeEndOfLine: n };
} });
var lt = te({ "src/utils/get-last.js"(e, r) {
  "use strict";
  ne();
  var t = (s) => s[s.length - 1];
  r.exports = t;
} });
function CD() {
  let { onlyFirst: e = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
  return new RegExp(r, e ? void 0 : "g");
}
var ED = ht({ "node_modules/strip-ansi/node_modules/ansi-regex/index.js"() {
  ne();
} });
function FD(e) {
  if (typeof e != "string") throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  return e.replace(CD(), "");
}
var AD = ht({ "node_modules/strip-ansi/index.js"() {
  ne(), ED();
} });
function SD(e) {
  return Number.isInteger(e) ? e >= 4352 && (e <= 4447 || e === 9001 || e === 9002 || 11904 <= e && e <= 12871 && e !== 12351 || 12880 <= e && e <= 19903 || 19968 <= e && e <= 42182 || 43360 <= e && e <= 43388 || 44032 <= e && e <= 55203 || 63744 <= e && e <= 64255 || 65040 <= e && e <= 65049 || 65072 <= e && e <= 65131 || 65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || 110592 <= e && e <= 110593 || 127488 <= e && e <= 127569 || 131072 <= e && e <= 262141) : false;
}
var xD = ht({ "node_modules/is-fullwidth-code-point/index.js"() {
  ne();
} });
var bD = te({ "node_modules/emoji-regex/index.js"(e, r) {
  "use strict";
  ne(), r.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
} });
var ba = {};
zt(ba, { default: () => TD });
function TD(e) {
  if (typeof e != "string" || e.length === 0 || (e = FD(e), e.length === 0)) return 0;
  e = e.replace((0, Ta.default)(), "  ");
  let r = 0;
  for (let t = 0; t < e.length; t++) {
    let s = e.codePointAt(t);
    s <= 31 || s >= 127 && s <= 159 || s >= 768 && s <= 879 || (s > 65535 && t++, r += SD(s) ? 2 : 1);
  }
  return r;
}
var Ta;
var BD = ht({ "node_modules/string-width/index.js"() {
  ne(), AD(), xD(), Ta = yD(bD());
} });
var Ba = te({ "src/utils/get-string-width.js"(e, r) {
  "use strict";
  ne();
  var t = (BD(), ft(ba)).default, s = /[^\x20-\x7F]/;
  function a(n) {
    return n ? s.test(n) ? t(n) : n.length : 0;
  }
  r.exports = a;
} });
var Xt = te({ "src/document/doc-utils.js"(e, r) {
  "use strict";
  ne();
  var t = lt(), { literalline: s, join: a } = Wn(), n = (o) => Array.isArray(o) || o && o.type === "concat", u = (o) => {
    if (Array.isArray(o)) return o;
    if (o.type !== "concat" && o.type !== "fill") throw new Error("Expect doc type to be `concat` or `fill`.");
    return o.parts;
  }, i = {};
  function l(o, h, v, S) {
    let b = [o];
    for (; b.length > 0; ) {
      let B = b.pop();
      if (B === i) {
        v(b.pop());
        continue;
      }
      if (v && b.push(B, i), !h || h(B) !== false) if (n(B) || B.type === "fill") {
        let k = u(B);
        for (let M = k.length, R = M - 1; R >= 0; --R) b.push(k[R]);
      } else if (B.type === "if-break") B.flatContents && b.push(B.flatContents), B.breakContents && b.push(B.breakContents);
      else if (B.type === "group" && B.expandedStates) if (S) for (let k = B.expandedStates.length, M = k - 1; M >= 0; --M) b.push(B.expandedStates[M]);
      else b.push(B.contents);
      else B.contents && b.push(B.contents);
    }
  }
  function p(o, h) {
    let v = /* @__PURE__ */ new Map();
    return S(o);
    function S(B) {
      if (v.has(B)) return v.get(B);
      let k = b(B);
      return v.set(B, k), k;
    }
    function b(B) {
      if (Array.isArray(B)) return h(B.map(S));
      if (B.type === "concat" || B.type === "fill") {
        let k = B.parts.map(S);
        return h(Object.assign(Object.assign({}, B), {}, { parts: k }));
      }
      if (B.type === "if-break") {
        let k = B.breakContents && S(B.breakContents), M = B.flatContents && S(B.flatContents);
        return h(Object.assign(Object.assign({}, B), {}, { breakContents: k, flatContents: M }));
      }
      if (B.type === "group" && B.expandedStates) {
        let k = B.expandedStates.map(S), M = k[0];
        return h(Object.assign(Object.assign({}, B), {}, { contents: M, expandedStates: k }));
      }
      if (B.contents) {
        let k = S(B.contents);
        return h(Object.assign(Object.assign({}, B), {}, { contents: k }));
      }
      return h(B);
    }
  }
  function d(o, h, v) {
    let S = v, b = false;
    function B(k) {
      let M = h(k);
      if (M !== void 0 && (b = true, S = M), b) return false;
    }
    return l(o, B), S;
  }
  function y(o) {
    if (o.type === "group" && o.break || o.type === "line" && o.hard || o.type === "break-parent") return true;
  }
  function g(o) {
    return d(o, y, false);
  }
  function c(o) {
    if (o.length > 0) {
      let h = t(o);
      !h.expandedStates && !h.break && (h.break = "propagated");
    }
    return null;
  }
  function f(o) {
    let h = /* @__PURE__ */ new Set(), v = [];
    function S(B) {
      if (B.type === "break-parent" && c(v), B.type === "group") {
        if (v.push(B), h.has(B)) return false;
        h.add(B);
      }
    }
    function b(B) {
      B.type === "group" && v.pop().break && c(v);
    }
    l(o, S, b, true);
  }
  function E2(o) {
    return o.type === "line" && !o.hard ? o.soft ? "" : " " : o.type === "if-break" ? o.flatContents || "" : o;
  }
  function _(o) {
    return p(o, E2);
  }
  var w = (o, h) => o && o.type === "line" && o.hard && h && h.type === "break-parent";
  function F(o) {
    if (!o) return o;
    if (n(o) || o.type === "fill") {
      let h = u(o);
      for (; h.length > 1 && w(...h.slice(-2)); ) h.length -= 2;
      if (h.length > 0) {
        let v = F(t(h));
        h[h.length - 1] = v;
      }
      return Array.isArray(o) ? h : Object.assign(Object.assign({}, o), {}, { parts: h });
    }
    switch (o.type) {
      case "align":
      case "indent":
      case "indent-if-break":
      case "group":
      case "line-suffix":
      case "label": {
        let h = F(o.contents);
        return Object.assign(Object.assign({}, o), {}, { contents: h });
      }
      case "if-break": {
        let h = F(o.breakContents), v = F(o.flatContents);
        return Object.assign(Object.assign({}, o), {}, { breakContents: h, flatContents: v });
      }
    }
    return o;
  }
  function N(o) {
    return F(I(o));
  }
  function x(o) {
    switch (o.type) {
      case "fill":
        if (o.parts.every((v) => v === "")) return "";
        break;
      case "group":
        if (!o.contents && !o.id && !o.break && !o.expandedStates) return "";
        if (o.contents.type === "group" && o.contents.id === o.id && o.contents.break === o.break && o.contents.expandedStates === o.expandedStates) return o.contents;
        break;
      case "align":
      case "indent":
      case "indent-if-break":
      case "line-suffix":
        if (!o.contents) return "";
        break;
      case "if-break":
        if (!o.flatContents && !o.breakContents) return "";
        break;
    }
    if (!n(o)) return o;
    let h = [];
    for (let v of u(o)) {
      if (!v) continue;
      let [S, ...b] = n(v) ? u(v) : [v];
      typeof S == "string" && typeof t(h) == "string" ? h[h.length - 1] += S : h.push(S), h.push(...b);
    }
    return h.length === 0 ? "" : h.length === 1 ? h[0] : Array.isArray(o) ? h : Object.assign(Object.assign({}, o), {}, { parts: h });
  }
  function I(o) {
    return p(o, (h) => x(h));
  }
  function P(o) {
    let h = [], v = o.filter(Boolean);
    for (; v.length > 0; ) {
      let S = v.shift();
      if (S) {
        if (n(S)) {
          v.unshift(...u(S));
          continue;
        }
        if (h.length > 0 && typeof t(h) == "string" && typeof S == "string") {
          h[h.length - 1] += S;
          continue;
        }
        h.push(S);
      }
    }
    return h;
  }
  function $2(o) {
    return p(o, (h) => Array.isArray(h) ? P(h) : h.parts ? Object.assign(Object.assign({}, h), {}, { parts: P(h.parts) }) : h);
  }
  function D(o) {
    return p(o, (h) => typeof h == "string" && h.includes(`
`) ? T(h) : h);
  }
  function T(o) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
    return a(h, o.split(`
`)).parts;
  }
  function m(o) {
    if (o.type === "line") return true;
  }
  function C(o) {
    return d(o, m, false);
  }
  r.exports = { isConcat: n, getDocParts: u, willBreak: g, traverseDoc: l, findInDoc: d, mapDoc: p, propagateBreaks: f, removeLines: _, stripTrailingHardline: N, normalizeParts: P, normalizeDoc: $2, cleanDoc: I, replaceTextEndOfLine: T, replaceEndOfLine: D, canBreak: C };
} });
var ND = te({ "src/document/doc-printer.js"(e, r) {
  "use strict";
  ne();
  var { convertEndOfLineToChars: t } = Hn(), s = lt(), a = Ba(), { fill: n, cursor: u, indent: i } = Wn(), { isConcat: l, getDocParts: p } = Xt(), d, y = 1, g = 2;
  function c() {
    return { value: "", length: 0, queue: [] };
  }
  function f(x, I) {
    return _(x, { type: "indent" }, I);
  }
  function E2(x, I, P) {
    return I === Number.NEGATIVE_INFINITY ? x.root || c() : I < 0 ? _(x, { type: "dedent" }, P) : I ? I.type === "root" ? Object.assign(Object.assign({}, x), {}, { root: x }) : _(x, { type: typeof I == "string" ? "stringAlign" : "numberAlign", n: I }, P) : x;
  }
  function _(x, I, P) {
    let $2 = I.type === "dedent" ? x.queue.slice(0, -1) : [...x.queue, I], D = "", T = 0, m = 0, C = 0;
    for (let k of $2) switch (k.type) {
      case "indent":
        v(), P.useTabs ? o(1) : h(P.tabWidth);
        break;
      case "stringAlign":
        v(), D += k.n, T += k.n.length;
        break;
      case "numberAlign":
        m += 1, C += k.n;
        break;
      default:
        throw new Error(`Unexpected type '${k.type}'`);
    }
    return b(), Object.assign(Object.assign({}, x), {}, { value: D, length: T, queue: $2 });
    function o(k) {
      D += "	".repeat(k), T += P.tabWidth * k;
    }
    function h(k) {
      D += " ".repeat(k), T += k;
    }
    function v() {
      P.useTabs ? S() : b();
    }
    function S() {
      m > 0 && o(m), B();
    }
    function b() {
      C > 0 && h(C), B();
    }
    function B() {
      m = 0, C = 0;
    }
  }
  function w(x) {
    if (x.length === 0) return 0;
    let I = 0;
    for (; x.length > 0 && typeof s(x) == "string" && /^[\t ]*$/.test(s(x)); ) I += x.pop().length;
    if (x.length > 0 && typeof s(x) == "string") {
      let P = s(x).replace(/[\t ]*$/, "");
      I += s(x).length - P.length, x[x.length - 1] = P;
    }
    return I;
  }
  function F(x, I, P, $2, D) {
    let T = I.length, m = [x], C = [];
    for (; P >= 0; ) {
      if (m.length === 0) {
        if (T === 0) return true;
        m.push(I[--T]);
        continue;
      }
      let { mode: o, doc: h } = m.pop();
      if (typeof h == "string") C.push(h), P -= a(h);
      else if (l(h) || h.type === "fill") {
        let v = p(h);
        for (let S = v.length - 1; S >= 0; S--) m.push({ mode: o, doc: v[S] });
      } else switch (h.type) {
        case "indent":
        case "align":
        case "indent-if-break":
        case "label":
          m.push({ mode: o, doc: h.contents });
          break;
        case "trim":
          P += w(C);
          break;
        case "group": {
          if (D && h.break) return false;
          let v = h.break ? y : o, S = h.expandedStates && v === y ? s(h.expandedStates) : h.contents;
          m.push({ mode: v, doc: S });
          break;
        }
        case "if-break": {
          let S = (h.groupId ? d[h.groupId] || g : o) === y ? h.breakContents : h.flatContents;
          S && m.push({ mode: o, doc: S });
          break;
        }
        case "line":
          if (o === y || h.hard) return true;
          h.soft || (C.push(" "), P--);
          break;
        case "line-suffix":
          $2 = true;
          break;
        case "line-suffix-boundary":
          if ($2) return false;
          break;
      }
    }
    return false;
  }
  function N(x, I) {
    d = {};
    let P = I.printWidth, $2 = t(I.endOfLine), D = 0, T = [{ ind: c(), mode: y, doc: x }], m = [], C = false, o = [];
    for (; T.length > 0; ) {
      let { ind: v, mode: S, doc: b } = T.pop();
      if (typeof b == "string") {
        let B = $2 !== `
` ? b.replace(/\n/g, $2) : b;
        m.push(B), D += a(B);
      } else if (l(b)) {
        let B = p(b);
        for (let k = B.length - 1; k >= 0; k--) T.push({ ind: v, mode: S, doc: B[k] });
      } else switch (b.type) {
        case "cursor":
          m.push(u.placeholder);
          break;
        case "indent":
          T.push({ ind: f(v, I), mode: S, doc: b.contents });
          break;
        case "align":
          T.push({ ind: E2(v, b.n, I), mode: S, doc: b.contents });
          break;
        case "trim":
          D -= w(m);
          break;
        case "group":
          switch (S) {
            case g:
              if (!C) {
                T.push({ ind: v, mode: b.break ? y : g, doc: b.contents });
                break;
              }
            case y: {
              C = false;
              let B = { ind: v, mode: g, doc: b.contents }, k = P - D, M = o.length > 0;
              if (!b.break && F(B, T, k, M)) T.push(B);
              else if (b.expandedStates) {
                let R = s(b.expandedStates);
                if (b.break) {
                  T.push({ ind: v, mode: y, doc: R });
                  break;
                } else for (let q = 1; q < b.expandedStates.length + 1; q++) if (q >= b.expandedStates.length) {
                  T.push({ ind: v, mode: y, doc: R });
                  break;
                } else {
                  let J2 = b.expandedStates[q], L = { ind: v, mode: g, doc: J2 };
                  if (F(L, T, k, M)) {
                    T.push(L);
                    break;
                  }
                }
              } else T.push({ ind: v, mode: y, doc: b.contents });
              break;
            }
          }
          b.id && (d[b.id] = s(T).mode);
          break;
        case "fill": {
          let B = P - D, { parts: k } = b;
          if (k.length === 0) break;
          let [M, R] = k, q = { ind: v, mode: g, doc: M }, J2 = { ind: v, mode: y, doc: M }, L = F(q, [], B, o.length > 0, true);
          if (k.length === 1) {
            L ? T.push(q) : T.push(J2);
            break;
          }
          let Q2 = { ind: v, mode: g, doc: R }, V = { ind: v, mode: y, doc: R };
          if (k.length === 2) {
            L ? T.push(Q2, q) : T.push(V, J2);
            break;
          }
          k.splice(0, 2);
          let j = { ind: v, mode: S, doc: n(k) }, Y = k[0];
          F({ ind: v, mode: g, doc: [M, R, Y] }, [], B, o.length > 0, true) ? T.push(j, Q2, q) : L ? T.push(j, V, q) : T.push(j, V, J2);
          break;
        }
        case "if-break":
        case "indent-if-break": {
          let B = b.groupId ? d[b.groupId] : S;
          if (B === y) {
            let k = b.type === "if-break" ? b.breakContents : b.negate ? b.contents : i(b.contents);
            k && T.push({ ind: v, mode: S, doc: k });
          }
          if (B === g) {
            let k = b.type === "if-break" ? b.flatContents : b.negate ? i(b.contents) : b.contents;
            k && T.push({ ind: v, mode: S, doc: k });
          }
          break;
        }
        case "line-suffix":
          o.push({ ind: v, mode: S, doc: b.contents });
          break;
        case "line-suffix-boundary":
          o.length > 0 && T.push({ ind: v, mode: S, doc: { type: "line", hard: true } });
          break;
        case "line":
          switch (S) {
            case g:
              if (b.hard) C = true;
              else {
                b.soft || (m.push(" "), D += 1);
                break;
              }
            case y:
              if (o.length > 0) {
                T.push({ ind: v, mode: S, doc: b }, ...o.reverse()), o.length = 0;
                break;
              }
              b.literal ? v.root ? (m.push($2, v.root.value), D = v.root.length) : (m.push($2), D = 0) : (D -= w(m), m.push($2 + v.value), D = v.length);
              break;
          }
          break;
        case "label":
          T.push({ ind: v, mode: S, doc: b.contents });
          break;
        default:
      }
      T.length === 0 && o.length > 0 && (T.push(...o.reverse()), o.length = 0);
    }
    let h = m.indexOf(u.placeholder);
    if (h !== -1) {
      let v = m.indexOf(u.placeholder, h + 1), S = m.slice(0, h).join(""), b = m.slice(h + 1, v).join(""), B = m.slice(v + 1).join("");
      return { formatted: S + b + B, cursorNodeStart: S.length, cursorNodeText: b };
    }
    return { formatted: m.join("") };
  }
  r.exports = { printDocToString: N };
} });
var wD = te({ "src/document/doc-debug.js"(e, r) {
  "use strict";
  ne();
  var { isConcat: t, getDocParts: s } = Xt();
  function a(u) {
    if (!u) return "";
    if (t(u)) {
      let i = [];
      for (let l of s(u)) if (t(l)) i.push(...a(l).parts);
      else {
        let p = a(l);
        p !== "" && i.push(p);
      }
      return { type: "concat", parts: i };
    }
    return u.type === "if-break" ? Object.assign(Object.assign({}, u), {}, { breakContents: a(u.breakContents), flatContents: a(u.flatContents) }) : u.type === "group" ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents), expandedStates: u.expandedStates && u.expandedStates.map(a) }) : u.type === "fill" ? { type: "fill", parts: u.parts.map(a) } : u.contents ? Object.assign(Object.assign({}, u), {}, { contents: a(u.contents) }) : u;
  }
  function n(u) {
    let i = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ new Set();
    return p(a(u));
    function p(y, g, c) {
      if (typeof y == "string") return JSON.stringify(y);
      if (t(y)) {
        let f = s(y).map(p).filter(Boolean);
        return f.length === 1 ? f[0] : `[${f.join(", ")}]`;
      }
      if (y.type === "line") {
        let f = Array.isArray(c) && c[g + 1] && c[g + 1].type === "break-parent";
        return y.literal ? f ? "literalline" : "literallineWithoutBreakParent" : y.hard ? f ? "hardline" : "hardlineWithoutBreakParent" : y.soft ? "softline" : "line";
      }
      if (y.type === "break-parent") return Array.isArray(c) && c[g - 1] && c[g - 1].type === "line" && c[g - 1].hard ? void 0 : "breakParent";
      if (y.type === "trim") return "trim";
      if (y.type === "indent") return "indent(" + p(y.contents) + ")";
      if (y.type === "align") return y.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + p(y.contents) + ")" : y.n < 0 ? "dedent(" + p(y.contents) + ")" : y.n.type === "root" ? "markAsRoot(" + p(y.contents) + ")" : "align(" + JSON.stringify(y.n) + ", " + p(y.contents) + ")";
      if (y.type === "if-break") return "ifBreak(" + p(y.breakContents) + (y.flatContents ? ", " + p(y.flatContents) : "") + (y.groupId ? (y.flatContents ? "" : ', ""') + `, { groupId: ${d(y.groupId)} }` : "") + ")";
      if (y.type === "indent-if-break") {
        let f = [];
        y.negate && f.push("negate: true"), y.groupId && f.push(`groupId: ${d(y.groupId)}`);
        let E2 = f.length > 0 ? `, { ${f.join(", ")} }` : "";
        return `indentIfBreak(${p(y.contents)}${E2})`;
      }
      if (y.type === "group") {
        let f = [];
        y.break && y.break !== "propagated" && f.push("shouldBreak: true"), y.id && f.push(`id: ${d(y.id)}`);
        let E2 = f.length > 0 ? `, { ${f.join(", ")} }` : "";
        return y.expandedStates ? `conditionalGroup([${y.expandedStates.map((_) => p(_)).join(",")}]${E2})` : `group(${p(y.contents)}${E2})`;
      }
      if (y.type === "fill") return `fill([${y.parts.map((f) => p(f)).join(", ")}])`;
      if (y.type === "line-suffix") return "lineSuffix(" + p(y.contents) + ")";
      if (y.type === "line-suffix-boundary") return "lineSuffixBoundary";
      if (y.type === "label") return `label(${JSON.stringify(y.label)}, ${p(y.contents)})`;
      throw new Error("Unknown doc type " + y.type);
    }
    function d(y) {
      if (typeof y != "symbol") return JSON.stringify(String(y));
      if (y in i) return i[y];
      let g = String(y).slice(7, -1) || "symbol";
      for (let c = 0; ; c++) {
        let f = g + (c > 0 ? ` #${c}` : "");
        if (!l.has(f)) return l.add(f), i[y] = `Symbol.for(${JSON.stringify(f)})`;
      }
    }
  }
  r.exports = { printDocToDebug: n };
} });
var qe = te({ "src/document/index.js"(e, r) {
  "use strict";
  ne(), r.exports = { builders: Wn(), printer: ND(), utils: Xt(), debug: wD() };
} });
var Na = {};
zt(Na, { default: () => _D });
function _D(e) {
  if (typeof e != "string") throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
var PD = ht({ "node_modules/escape-string-regexp/index.js"() {
  ne();
} });
var wa = te({ "node_modules/semver/internal/debug.js"(e, r) {
  ne();
  var t = typeof Nt == "object" && Nt.env && Nt.env.NODE_DEBUG && /\bsemver\b/i.test(Nt.env.NODE_DEBUG) ? function() {
    for (var s = arguments.length, a = new Array(s), n = 0; n < s; n++) a[n] = arguments[n];
    return console.error("SEMVER", ...a);
  } : () => {
  };
  r.exports = t;
} });
var _a = te({ "node_modules/semver/internal/constants.js"(e, r) {
  ne();
  var t = "2.0.0", s = 256, a = Number.MAX_SAFE_INTEGER || 9007199254740991, n = 16;
  r.exports = { SEMVER_SPEC_VERSION: t, MAX_LENGTH: s, MAX_SAFE_INTEGER: a, MAX_SAFE_COMPONENT_LENGTH: n };
} });
var ID = te({ "node_modules/semver/internal/re.js"(e, r) {
  ne();
  var { MAX_SAFE_COMPONENT_LENGTH: t } = _a(), s = wa();
  e = r.exports = {};
  var a = e.re = [], n = e.src = [], u = e.t = {}, i = 0, l = (p, d, y) => {
    let g = i++;
    s(p, g, d), u[p] = g, n[g] = d, a[g] = new RegExp(d, y ? "g" : void 0);
  };
  l("NUMERICIDENTIFIER", "0|[1-9]\\d*"), l("NUMERICIDENTIFIERLOOSE", "[0-9]+"), l("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), l("MAINVERSION", `(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})`), l("MAINVERSIONLOOSE", `(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`), l("PRERELEASEIDENTIFIER", `(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASEIDENTIFIERLOOSE", `(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`), l("PRERELEASE", `(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\.${n[u.PRERELEASEIDENTIFIER]})*))`), l("PRERELEASELOOSE", `(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`), l("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), l("BUILD", `(?:\\+(${n[u.BUILDIDENTIFIER]}(?:\\.${n[u.BUILDIDENTIFIER]})*))`), l("FULLPLAIN", `v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`), l("FULL", `^${n[u.FULLPLAIN]}$`), l("LOOSEPLAIN", `[v=\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`), l("LOOSE", `^${n[u.LOOSEPLAIN]}$`), l("GTLT", "((?:<|>)?=?)"), l("XRANGEIDENTIFIERLOOSE", `${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), l("XRANGEIDENTIFIER", `${n[u.NUMERICIDENTIFIER]}|x|X|\\*`), l("XRANGEPLAIN", `[v=\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`), l("XRANGEPLAINLOOSE", `[v=\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`), l("XRANGE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAIN]}$`), l("XRANGELOOSE", `^${n[u.GTLT]}\\s*${n[u.XRANGEPLAINLOOSE]}$`), l("COERCE", `(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`), l("COERCERTL", n[u.COERCE], true), l("LONETILDE", "(?:~>?)"), l("TILDETRIM", `(\\s*)${n[u.LONETILDE]}\\s+`, true), e.tildeTrimReplace = "$1~", l("TILDE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`), l("TILDELOOSE", `^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`), l("LONECARET", "(?:\\^)"), l("CARETTRIM", `(\\s*)${n[u.LONECARET]}\\s+`, true), e.caretTrimReplace = "$1^", l("CARET", `^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`), l("CARETLOOSE", `^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`), l("COMPARATORLOOSE", `^${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]})$|^$`), l("COMPARATOR", `^${n[u.GTLT]}\\s*(${n[u.FULLPLAIN]})$|^$`), l("COMPARATORTRIM", `(\\s*)${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`, true), e.comparatorTrimReplace = "$1$2$3", l("HYPHENRANGE", `^\\s*(${n[u.XRANGEPLAIN]})\\s+-\\s+(${n[u.XRANGEPLAIN]})\\s*$`), l("HYPHENRANGELOOSE", `^\\s*(${n[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[u.XRANGEPLAINLOOSE]})\\s*$`), l("STAR", "(<|>)?=?\\s*\\*"), l("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), l("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
} });
var kD = te({ "node_modules/semver/internal/parse-options.js"(e, r) {
  ne();
  var t = ["includePrerelease", "loose", "rtl"], s = (a) => a ? typeof a != "object" ? { loose: true } : t.filter((n) => a[n]).reduce((n, u) => (n[u] = true, n), {}) : {};
  r.exports = s;
} });
var LD = te({ "node_modules/semver/internal/identifiers.js"(e, r) {
  ne();
  var t = /^[0-9]+$/, s = (n, u) => {
    let i = t.test(n), l = t.test(u);
    return i && l && (n = +n, u = +u), n === u ? 0 : i && !l ? -1 : l && !i ? 1 : n < u ? -1 : 1;
  }, a = (n, u) => s(u, n);
  r.exports = { compareIdentifiers: s, rcompareIdentifiers: a };
} });
var OD = te({ "node_modules/semver/classes/semver.js"(e, r) {
  ne();
  var t = wa(), { MAX_LENGTH: s, MAX_SAFE_INTEGER: a } = _a(), { re: n, t: u } = ID(), i = kD(), { compareIdentifiers: l } = LD(), p = class {
    constructor(d, y) {
      if (y = i(y), d instanceof p) {
        if (d.loose === !!y.loose && d.includePrerelease === !!y.includePrerelease) return d;
        d = d.version;
      } else if (typeof d != "string") throw new TypeError(`Invalid Version: ${d}`);
      if (d.length > s) throw new TypeError(`version is longer than ${s} characters`);
      t("SemVer", d, y), this.options = y, this.loose = !!y.loose, this.includePrerelease = !!y.includePrerelease;
      let g = d.trim().match(y.loose ? n[u.LOOSE] : n[u.FULL]);
      if (!g) throw new TypeError(`Invalid Version: ${d}`);
      if (this.raw = d, this.major = +g[1], this.minor = +g[2], this.patch = +g[3], this.major > a || this.major < 0) throw new TypeError("Invalid major version");
      if (this.minor > a || this.minor < 0) throw new TypeError("Invalid minor version");
      if (this.patch > a || this.patch < 0) throw new TypeError("Invalid patch version");
      g[4] ? this.prerelease = g[4].split(".").map((c) => {
        if (/^[0-9]+$/.test(c)) {
          let f = +c;
          if (f >= 0 && f < a) return f;
        }
        return c;
      }) : this.prerelease = [], this.build = g[5] ? g[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(d) {
      if (t("SemVer.compare", this.version, this.options, d), !(d instanceof p)) {
        if (typeof d == "string" && d === this.version) return 0;
        d = new p(d, this.options);
      }
      return d.version === this.version ? 0 : this.compareMain(d) || this.comparePre(d);
    }
    compareMain(d) {
      return d instanceof p || (d = new p(d, this.options)), l(this.major, d.major) || l(this.minor, d.minor) || l(this.patch, d.patch);
    }
    comparePre(d) {
      if (d instanceof p || (d = new p(d, this.options)), this.prerelease.length && !d.prerelease.length) return -1;
      if (!this.prerelease.length && d.prerelease.length) return 1;
      if (!this.prerelease.length && !d.prerelease.length) return 0;
      let y = 0;
      do {
        let g = this.prerelease[y], c = d.prerelease[y];
        if (t("prerelease compare", y, g, c), g === void 0 && c === void 0) return 0;
        if (c === void 0) return 1;
        if (g === void 0) return -1;
        if (g === c) continue;
        return l(g, c);
      } while (++y);
    }
    compareBuild(d) {
      d instanceof p || (d = new p(d, this.options));
      let y = 0;
      do {
        let g = this.build[y], c = d.build[y];
        if (t("prerelease compare", y, g, c), g === void 0 && c === void 0) return 0;
        if (c === void 0) return 1;
        if (g === void 0) return -1;
        if (g === c) continue;
        return l(g, c);
      } while (++y);
    }
    inc(d, y) {
      switch (d) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", y);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", y);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", y), this.inc("pre", y);
          break;
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", y), this.inc("pre", y);
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) this.prerelease = [0];
          else {
            let g = this.prerelease.length;
            for (; --g >= 0; ) typeof this.prerelease[g] == "number" && (this.prerelease[g]++, g = -2);
            g === -1 && this.prerelease.push(0);
          }
          y && (l(this.prerelease[0], y) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = [y, 0]) : this.prerelease = [y, 0]);
          break;
        default:
          throw new Error(`invalid increment argument: ${d}`);
      }
      return this.format(), this.raw = this.version, this;
    }
  };
  r.exports = p;
} });
var Gn = te({ "node_modules/semver/functions/compare.js"(e, r) {
  ne();
  var t = OD(), s = (a, n, u) => new t(a, u).compare(new t(n, u));
  r.exports = s;
} });
var jD = te({ "node_modules/semver/functions/lt.js"(e, r) {
  ne();
  var t = Gn(), s = (a, n, u) => t(a, n, u) < 0;
  r.exports = s;
} });
var qD = te({ "node_modules/semver/functions/gte.js"(e, r) {
  ne();
  var t = Gn(), s = (a, n, u) => t(a, n, u) >= 0;
  r.exports = s;
} });
var MD = te({ "src/utils/arrayify.js"(e, r) {
  "use strict";
  ne(), r.exports = (t, s) => Object.entries(t).map((a) => {
    let [n, u] = a;
    return Object.assign({ [s]: n }, u);
  });
} });
var RD = te({ "node_modules/outdent/lib/index.js"(e, r) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.outdent = void 0;
  function t() {
    for (var F = [], N = 0; N < arguments.length; N++) F[N] = arguments[N];
  }
  function s() {
    return typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : a();
  }
  function a() {
    return { add: t, delete: t, get: t, set: t, has: function(F) {
      return false;
    } };
  }
  var n = Object.prototype.hasOwnProperty, u = function(F, N) {
    return n.call(F, N);
  };
  function i(F, N) {
    for (var x in N) u(N, x) && (F[x] = N[x]);
    return F;
  }
  var l = /^[ \t]*(?:\r\n|\r|\n)/, p = /(?:\r\n|\r|\n)[ \t]*$/, d = /^(?:[\r\n]|$)/, y = /(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/, g = /^[ \t]*[\r\n][ \t\r\n]*$/;
  function c(F, N, x) {
    var I = 0, P = F[0].match(y);
    P && (I = P[1].length);
    var $2 = "(\\r\\n|\\r|\\n).{0," + I + "}", D = new RegExp($2, "g");
    N && (F = F.slice(1));
    var T = x.newline, m = x.trimLeadingNewline, C = x.trimTrailingNewline, o = typeof T == "string", h = F.length, v = F.map(function(S, b) {
      return S = S.replace(D, "$1"), b === 0 && m && (S = S.replace(l, "")), b === h - 1 && C && (S = S.replace(p, "")), o && (S = S.replace(/\r\n|\n|\r/g, function(B) {
        return T;
      })), S;
    });
    return v;
  }
  function f(F, N) {
    for (var x = "", I = 0, P = F.length; I < P; I++) x += F[I], I < P - 1 && (x += N[I]);
    return x;
  }
  function E2(F) {
    return u(F, "raw") && u(F, "length");
  }
  function _(F) {
    var N = s(), x = s();
    function I($2) {
      for (var D = [], T = 1; T < arguments.length; T++) D[T - 1] = arguments[T];
      if (E2($2)) {
        var m = $2, C = (D[0] === I || D[0] === w) && g.test(m[0]) && d.test(m[1]), o = C ? x : N, h = o.get(m);
        if (h || (h = c(m, C, F), o.set(m, h)), D.length === 0) return h[0];
        var v = f(h, C ? D.slice(1) : D);
        return v;
      } else return _(i(i({}, F), $2 || {}));
    }
    var P = i(I, { string: function($2) {
      return c([$2], false, F)[0];
    } });
    return P;
  }
  var w = _({ trimLeadingNewline: true, trimTrailingNewline: true });
  if (e.outdent = w, e.default = w, typeof r < "u") try {
    r.exports = w, Object.defineProperty(w, "__esModule", { value: true }), w.default = w, w.outdent = w;
  } catch {
  }
} });
var $D = te({ "src/main/core-options.js"(e, r) {
  "use strict";
  ne();
  var { outdent: t } = RD(), s = "Config", a = "Editor", n = "Format", u = "Other", i = "Output", l = "Global", p = "Special", d = { cursorOffset: { since: "1.4.0", category: p, type: "int", default: -1, range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `, cliCategory: a }, endOfLine: { since: "1.15.0", category: l, type: "choice", default: [{ since: "1.15.0", value: "auto" }, { since: "2.0.0", value: "lf" }], description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        ` }] }, filepath: { since: "1.4.0", category: p, type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: u, cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { since: "1.8.0", category: p, type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: u }, parser: { since: "0.0.10", category: l, type: "choice", default: [{ since: "0.0.10", value: "babylon" }, { since: "1.13.0", value: void 0 }], description: "Which parser to use.", exception: (y) => typeof y == "string" || typeof y == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", since: "1.16.0", description: "JavaScript" }, { value: "babel-flow", since: "1.16.0", description: "Flow" }, { value: "babel-ts", since: "2.0.0", description: "TypeScript" }, { value: "typescript", since: "1.4.0", description: "TypeScript" }, { value: "acorn", since: "2.6.0", description: "JavaScript" }, { value: "espree", since: "2.2.0", description: "JavaScript" }, { value: "meriyah", since: "2.2.0", description: "JavaScript" }, { value: "css", since: "1.7.1", description: "CSS" }, { value: "less", since: "1.7.1", description: "Less" }, { value: "scss", since: "1.7.1", description: "SCSS" }, { value: "json", since: "1.5.0", description: "JSON" }, { value: "json5", since: "1.13.0", description: "JSON5" }, { value: "json-stringify", since: "1.13.0", description: "JSON.stringify" }, { value: "graphql", since: "1.5.0", description: "GraphQL" }, { value: "markdown", since: "1.8.0", description: "Markdown" }, { value: "mdx", since: "1.15.0", description: "MDX" }, { value: "vue", since: "1.10.0", description: "Vue" }, { value: "yaml", since: "1.14.0", description: "YAML" }, { value: "glimmer", since: "2.3.0", description: "Ember / Handlebars" }, { value: "html", since: "1.15.0", description: "HTML" }, { value: "angular", since: "1.15.0", description: "Angular" }, { value: "lwc", since: "1.17.0", description: "Lightning Web Components" }] }, plugins: { since: "1.10.0", type: "path", array: true, default: [{ value: [] }], category: l, description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (y) => typeof y == "string" || typeof y == "object", cliName: "plugin", cliCategory: s }, pluginSearchDirs: { since: "1.13.0", type: "path", array: true, default: [{ value: [] }], category: l, description: t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `, exception: (y) => typeof y == "string" || typeof y == "object", cliName: "plugin-search-dir", cliCategory: s }, printWidth: { since: "0.0.0", category: l, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, rangeEnd: { since: "1.4.0", category: p, type: "int", default: Number.POSITIVE_INFINITY, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, rangeStart: { since: "1.4.0", category: p, type: "int", default: 0, range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 }, description: t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `, cliCategory: a }, requirePragma: { since: "1.7.0", category: p, type: "boolean", default: false, description: t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `, cliCategory: u }, tabWidth: { type: "int", category: l, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: l, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { since: "2.1.0", category: l, type: "choice", default: [{ since: "2.1.0", value: "auto" }], description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
  r.exports = { CATEGORY_CONFIG: s, CATEGORY_EDITOR: a, CATEGORY_FORMAT: n, CATEGORY_OTHER: u, CATEGORY_OUTPUT: i, CATEGORY_GLOBAL: l, CATEGORY_SPECIAL: p, options: d };
} });
var Un = te({ "src/main/support.js"(e, r) {
  "use strict";
  ne();
  var t = { compare: Gn(), lt: jD(), gte: qD() }, s = MD(), a = xa().version, n = $D().options;
  function u() {
    let { plugins: l = [], showUnreleased: p = false, showDeprecated: d = false, showInternal: y = false } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, g = a.split("-", 1)[0], c = l.flatMap((F) => F.languages || []).filter(E2), f = s(Object.assign({}, ...l.map((F) => {
      let { options: N } = F;
      return N;
    }), n), "name").filter((F) => E2(F) && _(F)).sort((F, N) => F.name === N.name ? 0 : F.name < N.name ? -1 : 1).map(w).map((F) => {
      F = Object.assign({}, F), Array.isArray(F.default) && (F.default = F.default.length === 1 ? F.default[0].value : F.default.filter(E2).sort((x, I) => t.compare(I.since, x.since))[0].value), Array.isArray(F.choices) && (F.choices = F.choices.filter((x) => E2(x) && _(x)), F.name === "parser" && i(F, c, l));
      let N = Object.fromEntries(l.filter((x) => x.defaultOptions && x.defaultOptions[F.name] !== void 0).map((x) => [x.name, x.defaultOptions[F.name]]));
      return Object.assign(Object.assign({}, F), {}, { pluginDefaults: N });
    });
    return { languages: c, options: f };
    function E2(F) {
      return p || !("since" in F) || F.since && t.gte(g, F.since);
    }
    function _(F) {
      return d || !("deprecated" in F) || F.deprecated && t.lt(g, F.deprecated);
    }
    function w(F) {
      if (y) return F;
      let { cliName: N, cliCategory: x, cliDescription: I } = F;
      return $n(F, lD);
    }
  }
  function i(l, p, d) {
    let y = new Set(l.choices.map((g) => g.value));
    for (let g of p) if (g.parsers) {
      for (let c of g.parsers) if (!y.has(c)) {
        y.add(c);
        let f = d.find((_) => _.parsers && _.parsers[c]), E2 = g.name;
        f && f.name && (E2 += ` (plugin: ${f.name})`), l.choices.push({ value: c, description: E2 });
      }
    }
  }
  r.exports = { getSupportInfo: u };
} });
var Jn = te({ "src/utils/is-non-empty-array.js"(e, r) {
  "use strict";
  ne();
  function t(s) {
    return Array.isArray(s) && s.length > 0;
  }
  r.exports = t;
} });
var wr = te({ "src/utils/text/skip.js"(e, r) {
  "use strict";
  ne();
  function t(i) {
    return (l, p, d) => {
      let y = d && d.backwards;
      if (p === false) return false;
      let { length: g } = l, c = p;
      for (; c >= 0 && c < g; ) {
        let f = l.charAt(c);
        if (i instanceof RegExp) {
          if (!i.test(f)) return c;
        } else if (!i.includes(f)) return c;
        y ? c-- : c++;
      }
      return c === -1 || c === g ? c : false;
    };
  }
  var s = t(/\s/), a = t(" 	"), n = t(",; 	"), u = t(/[^\n\r]/);
  r.exports = { skipWhitespace: s, skipSpaces: a, skipToLineEnd: n, skipEverythingButNewLine: u };
} });
var Pa = te({ "src/utils/text/skip-inline-comment.js"(e, r) {
  "use strict";
  ne();
  function t(s, a) {
    if (a === false) return false;
    if (s.charAt(a) === "/" && s.charAt(a + 1) === "*") {
      for (let n = a + 2; n < s.length; ++n) if (s.charAt(n) === "*" && s.charAt(n + 1) === "/") return n + 2;
    }
    return a;
  }
  r.exports = t;
} });
var Ia = te({ "src/utils/text/skip-trailing-comment.js"(e, r) {
  "use strict";
  ne();
  var { skipEverythingButNewLine: t } = wr();
  function s(a, n) {
    return n === false ? false : a.charAt(n) === "/" && a.charAt(n + 1) === "/" ? t(a, n) : n;
  }
  r.exports = s;
} });
var ka = te({ "src/utils/text/skip-newline.js"(e, r) {
  "use strict";
  ne();
  function t(s, a, n) {
    let u = n && n.backwards;
    if (a === false) return false;
    let i = s.charAt(a);
    if (u) {
      if (s.charAt(a - 1) === "\r" && i === `
`) return a - 2;
      if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return a - 1;
    } else {
      if (i === "\r" && s.charAt(a + 1) === `
`) return a + 2;
      if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return a + 1;
    }
    return a;
  }
  r.exports = t;
} });
var VD = te({ "src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e, r) {
  "use strict";
  ne();
  var t = Pa(), s = ka(), a = Ia(), { skipSpaces: n } = wr();
  function u(i, l) {
    let p = null, d = l;
    for (; d !== p; ) p = d, d = n(i, d), d = t(i, d), d = a(i, d), d = s(i, d);
    return d;
  }
  r.exports = u;
} });
var Ue = te({ "src/common/util.js"(e, r) {
  "use strict";
  ne();
  var { default: t } = (PD(), ft(Na)), s = lt(), { getSupportInfo: a } = Un(), n = Jn(), u = Ba(), { skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: d } = wr(), y = Pa(), g = Ia(), c = ka(), f = VD(), E2 = (V) => V[V.length - 2];
  function _(V) {
    return (j, Y, ie) => {
      let ee = ie && ie.backwards;
      if (Y === false) return false;
      let { length: ce } = j, W = Y;
      for (; W >= 0 && W < ce; ) {
        let K = j.charAt(W);
        if (V instanceof RegExp) {
          if (!V.test(K)) return W;
        } else if (!V.includes(K)) return W;
        ee ? W-- : W++;
      }
      return W === -1 || W === ce ? W : false;
    };
  }
  function w(V, j) {
    let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ie = l(V, Y.backwards ? j - 1 : j, Y), ee = c(V, ie, Y);
    return ie !== ee;
  }
  function F(V, j, Y) {
    for (let ie = j; ie < Y; ++ie) if (V.charAt(ie) === `
`) return true;
    return false;
  }
  function N(V, j, Y) {
    let ie = Y(j) - 1;
    ie = l(V, ie, { backwards: true }), ie = c(V, ie, { backwards: true }), ie = l(V, ie, { backwards: true });
    let ee = c(V, ie, { backwards: true });
    return ie !== ee;
  }
  function x(V, j) {
    let Y = null, ie = j;
    for (; ie !== Y; ) Y = ie, ie = p(V, ie), ie = y(V, ie), ie = l(V, ie);
    return ie = g(V, ie), ie = c(V, ie), ie !== false && w(V, ie);
  }
  function I(V, j, Y) {
    return x(V, Y(j));
  }
  function P(V, j, Y) {
    return f(V, Y(j));
  }
  function $2(V, j, Y) {
    return V.charAt(P(V, j, Y));
  }
  function D(V, j) {
    let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return l(V, Y.backwards ? j - 1 : j, Y) !== j;
  }
  function T(V, j) {
    let Y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ie = 0;
    for (let ee = Y; ee < V.length; ++ee) V[ee] === "	" ? ie = ie + j - ie % j : ie++;
    return ie;
  }
  function m(V, j) {
    let Y = V.lastIndexOf(`
`);
    return Y === -1 ? 0 : T(V.slice(Y + 1).match(/^[\t ]*/)[0], j);
  }
  function C(V, j) {
    let Y = { quote: '"', regex: /"/g, escaped: "&quot;" }, ie = { quote: "'", regex: /'/g, escaped: "&apos;" }, ee = j === "'" ? ie : Y, ce = ee === ie ? Y : ie, W = ee;
    if (V.includes(ee.quote) || V.includes(ce.quote)) {
      let K = (V.match(ee.regex) || []).length, de = (V.match(ce.regex) || []).length;
      W = K > de ? ce : ee;
    }
    return W;
  }
  function o(V, j) {
    let Y = V.slice(1, -1), ie = j.parser === "json" || j.parser === "json5" && j.quoteProps === "preserve" && !j.singleQuote ? '"' : j.__isInHtmlAttribute ? "'" : C(Y, j.singleQuote ? "'" : '"').quote;
    return h(Y, ie, !(j.parser === "css" || j.parser === "less" || j.parser === "scss" || j.__embeddedInHtml));
  }
  function h(V, j, Y) {
    let ie = j === '"' ? "'" : '"', ee = /\\(.)|(["'])/gs, ce = V.replace(ee, (W, K, de) => K === ie ? K : de === j ? "\\" + de : de || (Y && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K) ? K : "\\" + K));
    return j + ce + j;
  }
  function v(V) {
    return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1").replace(/^([+-])?\./, "$10.").replace(/(\.\d+?)0+(?=e|$)/, "$1").replace(/\.(?=e|$)/, "");
  }
  function S(V, j) {
    let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
    return Y === null ? 0 : Y.reduce((ie, ee) => Math.max(ie, ee.length / j.length), 0);
  }
  function b(V, j) {
    let Y = V.match(new RegExp(`(${t(j)})+`, "g"));
    if (Y === null) return 0;
    let ie = /* @__PURE__ */ new Map(), ee = 0;
    for (let ce of Y) {
      let W = ce.length / j.length;
      ie.set(W, true), W > ee && (ee = W);
    }
    for (let ce = 1; ce < ee; ce++) if (!ie.get(ce)) return ce;
    return ee + 1;
  }
  function B(V, j) {
    (V.comments || (V.comments = [])).push(j), j.printed = false, j.nodeDescription = Q2(V);
  }
  function k(V, j) {
    j.leading = true, j.trailing = false, B(V, j);
  }
  function M(V, j, Y) {
    j.leading = false, j.trailing = false, Y && (j.marker = Y), B(V, j);
  }
  function R(V, j) {
    j.leading = false, j.trailing = true, B(V, j);
  }
  function q(V, j) {
    let { languages: Y } = a({ plugins: j.plugins }), ie = Y.find((ee) => {
      let { name: ce } = ee;
      return ce.toLowerCase() === V;
    }) || Y.find((ee) => {
      let { aliases: ce } = ee;
      return Array.isArray(ce) && ce.includes(V);
    }) || Y.find((ee) => {
      let { extensions: ce } = ee;
      return Array.isArray(ce) && ce.includes(`.${V}`);
    });
    return ie && ie.parsers[0];
  }
  function J2(V) {
    return V && V.type === "front-matter";
  }
  function L(V) {
    let j = /* @__PURE__ */ new WeakMap();
    return function(Y) {
      return j.has(Y) || j.set(Y, Symbol(V)), j.get(Y);
    };
  }
  function Q2(V) {
    let j = V.type || V.kind || "(unknown type)", Y = String(V.name || V.id && (typeof V.id == "object" ? V.id.name : V.id) || V.key && (typeof V.key == "object" ? V.key.name : V.key) || V.value && (typeof V.value == "object" ? "" : String(V.value)) || V.operator || "");
    return Y.length > 20 && (Y = Y.slice(0, 19) + "\u2026"), j + (Y ? " " + Y : "");
  }
  r.exports = { inferParserByLanguage: q, getStringWidth: u, getMaxContinuousCount: S, getMinNotPresentContinuousCount: b, getPenultimate: E2, getLast: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: f, getNextNonSpaceNonCommentCharacterIndex: P, getNextNonSpaceNonCommentCharacter: $2, skip: _, skipWhitespace: i, skipSpaces: l, skipToLineEnd: p, skipEverythingButNewLine: d, skipInlineComment: y, skipTrailingComment: g, skipNewline: c, isNextLineEmptyAfterIndex: x, isNextLineEmpty: I, isPreviousLineEmpty: N, hasNewline: w, hasNewlineInRange: F, hasSpaces: D, getAlignmentSize: T, getIndentSize: m, getPreferredQuote: C, printString: o, printNumber: v, makeString: h, addLeadingComment: k, addDanglingComment: M, addTrailingComment: R, isFrontMatterNode: J2, isNonEmptyArray: n, createGroupIdMapper: L };
} });
var La = {};
zt(La, { basename: () => Ra, default: () => Va, delimiter: () => On, dirname: () => Ma, extname: () => $a, isAbsolute: () => Xn, join: () => ja, normalize: () => zn, relative: () => qa, resolve: () => Br, sep: () => Ln });
function Oa(e, r) {
  for (var t = 0, s = e.length - 1; s >= 0; s--) {
    var a = e[s];
    a === "." ? e.splice(s, 1) : a === ".." ? (e.splice(s, 1), t++) : t && (e.splice(s, 1), t--);
  }
  if (r) for (; t--; t) e.unshift("..");
  return e;
}
function Br() {
  for (var e = "", r = false, t = arguments.length - 1; t >= -1 && !r; t--) {
    var s = t >= 0 ? arguments[t] : "/";
    if (typeof s != "string") throw new TypeError("Arguments to path.resolve must be strings");
    if (!s) continue;
    e = s + "/" + e, r = s.charAt(0) === "/";
  }
  return e = Oa(Kn(e.split("/"), function(a) {
    return !!a;
  }), !r).join("/"), (r ? "/" : "") + e || ".";
}
function zn(e) {
  var r = Xn(e), t = Wa(e, -1) === "/";
  return e = Oa(Kn(e.split("/"), function(s) {
    return !!s;
  }), !r).join("/"), !e && !r && (e = "."), e && t && (e += "/"), (r ? "/" : "") + e;
}
function Xn(e) {
  return e.charAt(0) === "/";
}
function ja() {
  var e = Array.prototype.slice.call(arguments, 0);
  return zn(Kn(e, function(r, t) {
    if (typeof r != "string") throw new TypeError("Arguments to path.join must be strings");
    return r;
  }).join("/"));
}
function qa(e, r) {
  e = Br(e).substr(1), r = Br(r).substr(1);
  function t(p) {
    for (var d = 0; d < p.length && p[d] === ""; d++) ;
    for (var y = p.length - 1; y >= 0 && p[y] === ""; y--) ;
    return d > y ? [] : p.slice(d, y - d + 1);
  }
  for (var s = t(e.split("/")), a = t(r.split("/")), n = Math.min(s.length, a.length), u = n, i = 0; i < n; i++) if (s[i] !== a[i]) {
    u = i;
    break;
  }
  for (var l = [], i = u; i < s.length; i++) l.push("..");
  return l = l.concat(a.slice(u)), l.join("/");
}
function Ma(e) {
  var r = _r(e), t = r[0], s = r[1];
  return !t && !s ? "." : (s && (s = s.substr(0, s.length - 1)), t + s);
}
function Ra(e, r) {
  var t = _r(e)[2];
  return r && t.substr(-1 * r.length) === r && (t = t.substr(0, t.length - r.length)), t;
}
function $a(e) {
  return _r(e)[3];
}
function Kn(e, r) {
  if (e.filter) return e.filter(r);
  for (var t = [], s = 0; s < e.length; s++) r(e[s], s, e) && t.push(e[s]);
  return t;
}
var Ea;
var _r;
var Ln;
var On;
var Va;
var Wa;
var WD = ht({ "node-modules-polyfills:path"() {
  ne(), Ea = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, _r = function(e) {
    return Ea.exec(e).slice(1);
  }, Ln = "/", On = ":", Va = { extname: $a, basename: Ra, dirname: Ma, sep: Ln, delimiter: On, relative: qa, join: ja, isAbsolute: Xn, normalize: zn, resolve: Br }, Wa = "ab".substr(-1) === "b" ? function(e, r, t) {
    return e.substr(r, t);
  } : function(e, r, t) {
    return r < 0 && (r = e.length + r), e.substr(r, t);
  };
} });
var HD = te({ "node-modules-polyfills-commonjs:path"(e, r) {
  ne();
  var t = (WD(), ft(La));
  if (t && t.default) {
    r.exports = t.default;
    for (let s in t) r.exports[s] = t[s];
  } else t && (r.exports = t);
} });
var Kt = te({ "src/common/errors.js"(e, r) {
  "use strict";
  ne();
  var t = class extends Error {
  }, s = class extends Error {
  }, a = class extends Error {
  }, n = class extends Error {
  };
  r.exports = { ConfigError: t, DebugError: s, UndefinedParserError: a, ArgExpansionBailout: n };
} });
var vt = {};
zt(vt, { __assign: () => Tr, __asyncDelegator: () => nm, __asyncGenerator: () => rm, __asyncValues: () => um, __await: () => Jt, __awaiter: () => KD, __classPrivateFieldGet: () => om, __classPrivateFieldSet: () => lm, __createBinding: () => QD, __decorate: () => JD, __exportStar: () => ZD, __extends: () => GD, __generator: () => YD, __importDefault: () => am, __importStar: () => im, __makeTemplateObject: () => sm, __metadata: () => XD, __param: () => zD, __read: () => Ha, __rest: () => UD, __spread: () => em, __spreadArrays: () => tm, __values: () => jn });
function GD(e, r) {
  br(e, r);
  function t() {
    this.constructor = e;
  }
  e.prototype = r === null ? Object.create(r) : (t.prototype = r.prototype, new t());
}
function UD(e, r) {
  var t = {};
  for (var s in e) Object.prototype.hasOwnProperty.call(e, s) && r.indexOf(s) < 0 && (t[s] = e[s]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var a = 0, s = Object.getOwnPropertySymbols(e); a < s.length; a++) r.indexOf(s[a]) < 0 && Object.prototype.propertyIsEnumerable.call(e, s[a]) && (t[s[a]] = e[s[a]]);
  return t;
}
function JD(e, r, t, s) {
  var a = arguments.length, n = a < 3 ? r : s === null ? s = Object.getOwnPropertyDescriptor(r, t) : s, u;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") n = Reflect.decorate(e, r, t, s);
  else for (var i = e.length - 1; i >= 0; i--) (u = e[i]) && (n = (a < 3 ? u(n) : a > 3 ? u(r, t, n) : u(r, t)) || n);
  return a > 3 && n && Object.defineProperty(r, t, n), n;
}
function zD(e, r) {
  return function(t, s) {
    r(t, s, e);
  };
}
function XD(e, r) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function") return Reflect.metadata(e, r);
}
function KD(e, r, t, s) {
  function a(n) {
    return n instanceof t ? n : new t(function(u) {
      u(n);
    });
  }
  return new (t || (t = Promise))(function(n, u) {
    function i(d) {
      try {
        p(s.next(d));
      } catch (y) {
        u(y);
      }
    }
    function l(d) {
      try {
        p(s.throw(d));
      } catch (y) {
        u(y);
      }
    }
    function p(d) {
      d.done ? n(d.value) : a(d.value).then(i, l);
    }
    p((s = s.apply(e, r || [])).next());
  });
}
function YD(e, r) {
  var t = { label: 0, sent: function() {
    if (n[0] & 1) throw n[1];
    return n[1];
  }, trys: [], ops: [] }, s, a, n, u;
  return u = { next: i(0), throw: i(1), return: i(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
    return this;
  }), u;
  function i(p) {
    return function(d) {
      return l([p, d]);
    };
  }
  function l(p) {
    if (s) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (s = 1, a && (n = p[0] & 2 ? a.return : p[0] ? a.throw || ((n = a.return) && n.call(a), 0) : a.next) && !(n = n.call(a, p[1])).done) return n;
      switch (a = 0, n && (p = [p[0] & 2, n.value]), p[0]) {
        case 0:
        case 1:
          n = p;
          break;
        case 4:
          return t.label++, { value: p[1], done: false };
        case 5:
          t.label++, a = p[1], p = [0];
          continue;
        case 7:
          p = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (n = t.trys, !(n = n.length > 0 && n[n.length - 1]) && (p[0] === 6 || p[0] === 2)) {
            t = 0;
            continue;
          }
          if (p[0] === 3 && (!n || p[1] > n[0] && p[1] < n[3])) {
            t.label = p[1];
            break;
          }
          if (p[0] === 6 && t.label < n[1]) {
            t.label = n[1], n = p;
            break;
          }
          if (n && t.label < n[2]) {
            t.label = n[2], t.ops.push(p);
            break;
          }
          n[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      p = r.call(e, t);
    } catch (d) {
      p = [6, d], a = 0;
    } finally {
      s = n = 0;
    }
    if (p[0] & 5) throw p[1];
    return { value: p[0] ? p[1] : void 0, done: true };
  }
}
function QD(e, r, t, s) {
  s === void 0 && (s = t), e[s] = r[t];
}
function ZD(e, r) {
  for (var t in e) t !== "default" && !r.hasOwnProperty(t) && (r[t] = e[t]);
}
function jn(e) {
  var r = typeof Symbol == "function" && Symbol.iterator, t = r && e[r], s = 0;
  if (t) return t.call(e);
  if (e && typeof e.length == "number") return { next: function() {
    return e && s >= e.length && (e = void 0), { value: e && e[s++], done: !e };
  } };
  throw new TypeError(r ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Ha(e, r) {
  var t = typeof Symbol == "function" && e[Symbol.iterator];
  if (!t) return e;
  var s = t.call(e), a, n = [], u;
  try {
    for (; (r === void 0 || r-- > 0) && !(a = s.next()).done; ) n.push(a.value);
  } catch (i) {
    u = { error: i };
  } finally {
    try {
      a && !a.done && (t = s.return) && t.call(s);
    } finally {
      if (u) throw u.error;
    }
  }
  return n;
}
function em() {
  for (var e = [], r = 0; r < arguments.length; r++) e = e.concat(Ha(arguments[r]));
  return e;
}
function tm() {
  for (var e = 0, r = 0, t = arguments.length; r < t; r++) e += arguments[r].length;
  for (var s = Array(e), a = 0, r = 0; r < t; r++) for (var n = arguments[r], u = 0, i = n.length; u < i; u++, a++) s[a] = n[u];
  return s;
}
function Jt(e) {
  return this instanceof Jt ? (this.v = e, this) : new Jt(e);
}
function rm(e, r, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var s = t.apply(e, r || []), a, n = [];
  return a = {}, u("next"), u("throw"), u("return"), a[Symbol.asyncIterator] = function() {
    return this;
  }, a;
  function u(g) {
    s[g] && (a[g] = function(c) {
      return new Promise(function(f, E2) {
        n.push([g, c, f, E2]) > 1 || i(g, c);
      });
    });
  }
  function i(g, c) {
    try {
      l(s[g](c));
    } catch (f) {
      y(n[0][3], f);
    }
  }
  function l(g) {
    g.value instanceof Jt ? Promise.resolve(g.value.v).then(p, d) : y(n[0][2], g);
  }
  function p(g) {
    i("next", g);
  }
  function d(g) {
    i("throw", g);
  }
  function y(g, c) {
    g(c), n.shift(), n.length && i(n[0][0], n[0][1]);
  }
}
function nm(e) {
  var r, t;
  return r = {}, s("next"), s("throw", function(a) {
    throw a;
  }), s("return"), r[Symbol.iterator] = function() {
    return this;
  }, r;
  function s(a, n) {
    r[a] = e[a] ? function(u) {
      return (t = !t) ? { value: Jt(e[a](u)), done: a === "return" } : n ? n(u) : u;
    } : n;
  }
}
function um(e) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = e[Symbol.asyncIterator], t;
  return r ? r.call(e) : (e = typeof jn == "function" ? jn(e) : e[Symbol.iterator](), t = {}, s("next"), s("throw"), s("return"), t[Symbol.asyncIterator] = function() {
    return this;
  }, t);
  function s(n) {
    t[n] = e[n] && function(u) {
      return new Promise(function(i, l) {
        u = e[n](u), a(i, l, u.done, u.value);
      });
    };
  }
  function a(n, u, i, l) {
    Promise.resolve(l).then(function(p) {
      n({ value: p, done: i });
    }, u);
  }
}
function sm(e, r) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", { value: r }) : e.raw = r, e;
}
function im(e) {
  if (e && e.__esModule) return e;
  var r = {};
  if (e != null) for (var t in e) Object.hasOwnProperty.call(e, t) && (r[t] = e[t]);
  return r.default = e, r;
}
function am(e) {
  return e && e.__esModule ? e : { default: e };
}
function om(e, r) {
  if (!r.has(e)) throw new TypeError("attempted to get private field on non-instance");
  return r.get(e);
}
function lm(e, r, t) {
  if (!r.has(e)) throw new TypeError("attempted to set private field on non-instance");
  return r.set(e, t), t;
}
var br;
var Tr;
var Et = ht({ "node_modules/tslib/tslib.es6.js"() {
  ne(), br = function(e, r) {
    return br = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, s) {
      t.__proto__ = s;
    } || function(t, s) {
      for (var a in s) s.hasOwnProperty(a) && (t[a] = s[a]);
    }, br(e, r);
  }, Tr = function() {
    return Tr = Object.assign || function(r) {
      for (var t, s = 1, a = arguments.length; s < a; s++) {
        t = arguments[s];
        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);
      }
      return r;
    }, Tr.apply(this, arguments);
  };
} });
var Ga = te({ "node_modules/vnopts/lib/descriptors/api.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.apiDescriptor = { key: (r) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r) ? r : JSON.stringify(r), value(r) {
    if (r === null || typeof r != "object") return JSON.stringify(r);
    if (Array.isArray(r)) return `[${r.map((s) => e.apiDescriptor.value(s)).join(", ")}]`;
    let t = Object.keys(r);
    return t.length === 0 ? "{}" : `{ ${t.map((s) => `${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(r[s])}`).join(", ")} }`;
  }, pair: (r) => {
    let { key: t, value: s } = r;
    return e.apiDescriptor.value({ [t]: s });
  } };
} });
var cm = te({ "node_modules/vnopts/lib/descriptors/index.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et(), ft(vt));
  r.__exportStar(Ga(), e);
} });
var Pr = te({ "scripts/build/shims/chalk.cjs"(e, r) {
  "use strict";
  ne();
  var t = (s) => s;
  t.grey = t, t.red = t, t.bold = t, t.yellow = t, t.blue = t, t.default = t, r.exports = t;
} });
var Ua = te({ "node_modules/vnopts/lib/handlers/deprecated/common.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Pr();
  e.commonDeprecatedHandler = (t, s, a) => {
    let { descriptor: n } = a, u = [`${r.default.yellow(typeof t == "string" ? n.key(t) : n.pair(t))} is deprecated`];
    return s && u.push(`we now treat it as ${r.default.blue(typeof s == "string" ? n.key(s) : n.pair(s))}`), u.join("; ") + ".";
  };
} });
var pm = te({ "node_modules/vnopts/lib/handlers/deprecated/index.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et(), ft(vt));
  r.__exportStar(Ua(), e);
} });
var fm = te({ "node_modules/vnopts/lib/handlers/invalid/common.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Pr();
  e.commonInvalidHandler = (t, s, a) => [`Invalid ${r.default.red(a.descriptor.key(t))} value.`, `Expected ${r.default.blue(a.schemas[t].expected(a))},`, `but received ${r.default.red(a.descriptor.value(s))}.`].join(" ");
} });
var Ja = te({ "node_modules/vnopts/lib/handlers/invalid/index.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et(), ft(vt));
  r.__exportStar(fm(), e);
} });
var Dm = te({ "node_modules/vnopts/node_modules/leven/index.js"(e, r) {
  "use strict";
  ne();
  var t = [], s = [];
  r.exports = function(a, n) {
    if (a === n) return 0;
    var u = a;
    a.length > n.length && (a = n, n = u);
    var i = a.length, l = n.length;
    if (i === 0) return l;
    if (l === 0) return i;
    for (; i > 0 && a.charCodeAt(~-i) === n.charCodeAt(~-l); ) i--, l--;
    if (i === 0) return l;
    for (var p = 0; p < i && a.charCodeAt(p) === n.charCodeAt(p); ) p++;
    if (i -= p, l -= p, i === 0) return l;
    for (var d, y, g, c, f = 0, E2 = 0; f < i; ) s[p + f] = a.charCodeAt(p + f), t[f] = ++f;
    for (; E2 < l; ) for (d = n.charCodeAt(p + E2), g = E2++, y = E2, f = 0; f < i; f++) c = d === s[p + f] ? g : g + 1, g = t[f], y = t[f] = g > y ? c > y ? y + 1 : c : c > g ? g + 1 : c;
    return y;
  };
} });
var za = te({ "node_modules/vnopts/lib/handlers/unknown/leven.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Pr(), t = Dm();
  e.levenUnknownHandler = (s, a, n) => {
    let { descriptor: u, logger: i, schemas: l } = n, p = [`Ignored unknown option ${r.default.yellow(u.pair({ key: s, value: a }))}.`], d = Object.keys(l).sort().find((y) => t(s, y) < 3);
    d && p.push(`Did you mean ${r.default.blue(u.key(d))}?`), i.warn(p.join(" "));
  };
} });
var mm = te({ "node_modules/vnopts/lib/handlers/unknown/index.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et(), ft(vt));
  r.__exportStar(za(), e);
} });
var dm = te({ "node_modules/vnopts/lib/handlers/index.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et(), ft(vt));
  r.__exportStar(pm(), e), r.__exportStar(Ja(), e), r.__exportStar(mm(), e);
} });
var Ft = te({ "node_modules/vnopts/lib/schema.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
  function t(n, u) {
    let i = new n(u), l = Object.create(i);
    for (let p of r) p in u && (l[p] = a(u[p], i, s.prototype[p].length));
    return l;
  }
  e.createSchema = t;
  var s = class {
    constructor(n) {
      this.name = n.name;
    }
    static create(n) {
      return t(this, n);
    }
    default(n) {
    }
    expected(n) {
      return "nothing";
    }
    validate(n, u) {
      return false;
    }
    deprecated(n, u) {
      return false;
    }
    forward(n, u) {
    }
    redirect(n, u) {
    }
    overlap(n, u, i) {
      return n;
    }
    preprocess(n, u) {
      return n;
    }
    postprocess(n, u) {
      return n;
    }
  };
  e.Schema = s;
  function a(n, u, i) {
    return typeof n == "function" ? function() {
      for (var l = arguments.length, p = new Array(l), d = 0; d < l; d++) p[d] = arguments[d];
      return n(...p.slice(0, i - 1), u, ...p.slice(i - 1));
    } : () => n;
  }
} });
var gm = te({ "node_modules/vnopts/lib/schemas/alias.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft(), t = class extends r.Schema {
    constructor(s) {
      super(s), this._sourceName = s.sourceName;
    }
    expected(s) {
      return s.schemas[this._sourceName].expected(s);
    }
    validate(s, a) {
      return a.schemas[this._sourceName].validate(s, a);
    }
    redirect(s, a) {
      return this._sourceName;
    }
  };
  e.AliasSchema = t;
} });
var ym = te({ "node_modules/vnopts/lib/schemas/any.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft(), t = class extends r.Schema {
    expected() {
      return "anything";
    }
    validate() {
      return true;
    }
  };
  e.AnySchema = t;
} });
var hm = te({ "node_modules/vnopts/lib/schemas/array.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et(), ft(vt)), t = Ft(), s = class extends t.Schema {
    constructor(n) {
      var { valueSchema: u, name: i = u.name } = n, l = r.__rest(n, ["valueSchema", "name"]);
      super(Object.assign({}, l, { name: i })), this._valueSchema = u;
    }
    expected(n) {
      return `an array of ${this._valueSchema.expected(n)}`;
    }
    validate(n, u) {
      if (!Array.isArray(n)) return false;
      let i = [];
      for (let l of n) {
        let p = u.normalizeValidateResult(this._valueSchema.validate(l, u), l);
        p !== true && i.push(p.value);
      }
      return i.length === 0 ? true : { value: i };
    }
    deprecated(n, u) {
      let i = [];
      for (let l of n) {
        let p = u.normalizeDeprecatedResult(this._valueSchema.deprecated(l, u), l);
        p !== false && i.push(...p.map((d) => {
          let { value: y } = d;
          return { value: [y] };
        }));
      }
      return i;
    }
    forward(n, u) {
      let i = [];
      for (let l of n) {
        let p = u.normalizeForwardResult(this._valueSchema.forward(l, u), l);
        i.push(...p.map(a));
      }
      return i;
    }
    redirect(n, u) {
      let i = [], l = [];
      for (let p of n) {
        let d = u.normalizeRedirectResult(this._valueSchema.redirect(p, u), p);
        "remain" in d && i.push(d.remain), l.push(...d.redirect.map(a));
      }
      return i.length === 0 ? { redirect: l } : { redirect: l, remain: i };
    }
    overlap(n, u) {
      return n.concat(u);
    }
  };
  e.ArraySchema = s;
  function a(n) {
    let { from: u, to: i } = n;
    return { from: [u], to: i };
  }
} });
var vm = te({ "node_modules/vnopts/lib/schemas/boolean.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft(), t = class extends r.Schema {
    expected() {
      return "true or false";
    }
    validate(s) {
      return typeof s == "boolean";
    }
  };
  e.BooleanSchema = t;
} });
var Yn = te({ "node_modules/vnopts/lib/utils.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  function r(c, f) {
    let E2 = /* @__PURE__ */ Object.create(null);
    for (let _ of c) {
      let w = _[f];
      if (E2[w]) throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
      E2[w] = _;
    }
    return E2;
  }
  e.recordFromArray = r;
  function t(c, f) {
    let E2 = /* @__PURE__ */ new Map();
    for (let _ of c) {
      let w = _[f];
      if (E2.has(w)) throw new Error(`Duplicate ${f} ${JSON.stringify(w)}`);
      E2.set(w, _);
    }
    return E2;
  }
  e.mapFromArray = t;
  function s() {
    let c = /* @__PURE__ */ Object.create(null);
    return (f) => {
      let E2 = JSON.stringify(f);
      return c[E2] ? true : (c[E2] = true, false);
    };
  }
  e.createAutoChecklist = s;
  function a(c, f) {
    let E2 = [], _ = [];
    for (let w of c) f(w) ? E2.push(w) : _.push(w);
    return [E2, _];
  }
  e.partition = a;
  function n(c) {
    return c === Math.floor(c);
  }
  e.isInt = n;
  function u(c, f) {
    if (c === f) return 0;
    let E2 = typeof c, _ = typeof f, w = ["undefined", "object", "boolean", "number", "string"];
    return E2 !== _ ? w.indexOf(E2) - w.indexOf(_) : E2 !== "string" ? Number(c) - Number(f) : c.localeCompare(f);
  }
  e.comparePrimitive = u;
  function i(c) {
    return c === void 0 ? {} : c;
  }
  e.normalizeDefaultResult = i;
  function l(c, f) {
    return c === true ? true : c === false ? { value: f } : c;
  }
  e.normalizeValidateResult = l;
  function p(c, f) {
    let E2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    return c === false ? false : c === true ? E2 ? true : [{ value: f }] : "value" in c ? [c] : c.length === 0 ? false : c;
  }
  e.normalizeDeprecatedResult = p;
  function d(c, f) {
    return typeof c == "string" || "key" in c ? { from: f, to: c } : "from" in c ? { from: c.from, to: c.to } : { from: f, to: c.to };
  }
  e.normalizeTransferResult = d;
  function y(c, f) {
    return c === void 0 ? [] : Array.isArray(c) ? c.map((E2) => d(E2, f)) : [d(c, f)];
  }
  e.normalizeForwardResult = y;
  function g(c, f) {
    let E2 = y(typeof c == "object" && "redirect" in c ? c.redirect : c, f);
    return E2.length === 0 ? { remain: f, redirect: E2 } : typeof c == "object" && "remain" in c ? { remain: c.remain, redirect: E2 } : { redirect: E2 };
  }
  e.normalizeRedirectResult = g;
} });
var Cm = te({ "node_modules/vnopts/lib/schemas/choice.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft(), t = Yn(), s = class extends r.Schema {
    constructor(a) {
      super(a), this._choices = t.mapFromArray(a.choices.map((n) => n && typeof n == "object" ? n : { value: n }), "value");
    }
    expected(a) {
      let { descriptor: n } = a, u = Array.from(this._choices.keys()).map((p) => this._choices.get(p)).filter((p) => !p.deprecated).map((p) => p.value).sort(t.comparePrimitive).map(n.value), i = u.slice(0, -2), l = u.slice(-2);
      return i.concat(l.join(" or ")).join(", ");
    }
    validate(a) {
      return this._choices.has(a);
    }
    deprecated(a) {
      let n = this._choices.get(a);
      return n && n.deprecated ? { value: a } : false;
    }
    forward(a) {
      let n = this._choices.get(a);
      return n ? n.forward : void 0;
    }
    redirect(a) {
      let n = this._choices.get(a);
      return n ? n.redirect : void 0;
    }
  };
  e.ChoiceSchema = s;
} });
var Xa = te({ "node_modules/vnopts/lib/schemas/number.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft(), t = class extends r.Schema {
    expected() {
      return "a number";
    }
    validate(s, a) {
      return typeof s == "number";
    }
  };
  e.NumberSchema = t;
} });
var Em = te({ "node_modules/vnopts/lib/schemas/integer.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Yn(), t = Xa(), s = class extends t.NumberSchema {
    expected() {
      return "an integer";
    }
    validate(a, n) {
      return n.normalizeValidateResult(super.validate(a, n), a) === true && r.isInt(a);
    }
  };
  e.IntegerSchema = s;
} });
var Fm = te({ "node_modules/vnopts/lib/schemas/string.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ft(), t = class extends r.Schema {
    expected() {
      return "a string";
    }
    validate(s) {
      return typeof s == "string";
    }
  };
  e.StringSchema = t;
} });
var Am = te({ "node_modules/vnopts/lib/schemas/index.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et(), ft(vt));
  r.__exportStar(gm(), e), r.__exportStar(ym(), e), r.__exportStar(hm(), e), r.__exportStar(vm(), e), r.__exportStar(Cm(), e), r.__exportStar(Em(), e), r.__exportStar(Xa(), e), r.__exportStar(Fm(), e);
} });
var Sm = te({ "node_modules/vnopts/lib/defaults.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Ga(), t = Ua(), s = Ja(), a = za();
  e.defaultDescriptor = r.apiDescriptor, e.defaultUnknownHandler = a.levenUnknownHandler, e.defaultInvalidHandler = s.commonInvalidHandler, e.defaultDeprecatedHandler = t.commonDeprecatedHandler;
} });
var xm = te({ "node_modules/vnopts/lib/normalize.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = Sm(), t = Yn();
  e.normalize = (a, n, u) => new s(n, u).normalize(a);
  var s = class {
    constructor(a, n) {
      let { logger: u = console, descriptor: i = r.defaultDescriptor, unknown: l = r.defaultUnknownHandler, invalid: p = r.defaultInvalidHandler, deprecated: d = r.defaultDeprecatedHandler } = n || {};
      this._utils = { descriptor: i, logger: u || { warn: () => {
      } }, schemas: t.recordFromArray(a, "name"), normalizeDefaultResult: t.normalizeDefaultResult, normalizeDeprecatedResult: t.normalizeDeprecatedResult, normalizeForwardResult: t.normalizeForwardResult, normalizeRedirectResult: t.normalizeRedirectResult, normalizeValidateResult: t.normalizeValidateResult }, this._unknownHandler = l, this._invalidHandler = p, this._deprecatedHandler = d, this.cleanHistory();
    }
    cleanHistory() {
      this._hasDeprecationWarned = t.createAutoChecklist();
    }
    normalize(a) {
      let n = {}, u = [a], i = () => {
        for (; u.length !== 0; ) {
          let l = u.shift(), p = this._applyNormalization(l, n);
          u.push(...p);
        }
      };
      i();
      for (let l of Object.keys(this._utils.schemas)) {
        let p = this._utils.schemas[l];
        if (!(l in n)) {
          let d = t.normalizeDefaultResult(p.default(this._utils));
          "value" in d && u.push({ [l]: d.value });
        }
      }
      i();
      for (let l of Object.keys(this._utils.schemas)) {
        let p = this._utils.schemas[l];
        l in n && (n[l] = p.postprocess(n[l], this._utils));
      }
      return n;
    }
    _applyNormalization(a, n) {
      let u = [], [i, l] = t.partition(Object.keys(a), (p) => p in this._utils.schemas);
      for (let p of i) {
        let d = this._utils.schemas[p], y = d.preprocess(a[p], this._utils), g = t.normalizeValidateResult(d.validate(y, this._utils), y);
        if (g !== true) {
          let { value: w } = g, F = this._invalidHandler(p, w, this._utils);
          throw typeof F == "string" ? new Error(F) : F;
        }
        let c = (w) => {
          let { from: F, to: N } = w;
          u.push(typeof N == "string" ? { [N]: F } : { [N.key]: N.value });
        }, f = (w) => {
          let { value: F, redirectTo: N } = w, x = t.normalizeDeprecatedResult(d.deprecated(F, this._utils), y, true);
          if (x !== false) if (x === true) this._hasDeprecationWarned(p) || this._utils.logger.warn(this._deprecatedHandler(p, N, this._utils));
          else for (let { value: I } of x) {
            let P = { key: p, value: I };
            if (!this._hasDeprecationWarned(P)) {
              let $2 = typeof N == "string" ? { key: N, value: I } : N;
              this._utils.logger.warn(this._deprecatedHandler(P, $2, this._utils));
            }
          }
        };
        t.normalizeForwardResult(d.forward(y, this._utils), y).forEach(c);
        let _ = t.normalizeRedirectResult(d.redirect(y, this._utils), y);
        if (_.redirect.forEach(c), "remain" in _) {
          let w = _.remain;
          n[p] = p in n ? d.overlap(n[p], w, this._utils) : w, f({ value: w });
        }
        for (let { from: w, to: F } of _.redirect) f({ value: w, redirectTo: F });
      }
      for (let p of l) {
        let d = a[p], y = this._unknownHandler(p, d, this._utils);
        if (y) for (let g of Object.keys(y)) {
          let c = { [g]: y[g] };
          g in this._utils.schemas ? u.push(c) : Object.assign(n, c);
        }
      }
      return u;
    }
  };
  e.Normalizer = s;
} });
var bm = te({ "node_modules/vnopts/lib/index.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = (Et(), ft(vt));
  r.__exportStar(cm(), e), r.__exportStar(dm(), e), r.__exportStar(Am(), e), r.__exportStar(xm(), e), r.__exportStar(Ft(), e);
} });
var Tm = te({ "src/main/options-normalizer.js"(e, r) {
  "use strict";
  ne();
  var t = bm(), s = lt(), a = { key: (g) => g.length === 1 ? `-${g}` : `--${g}`, value: (g) => t.apiDescriptor.value(g), pair: (g) => {
    let { key: c, value: f } = g;
    return f === false ? `--no-${c}` : f === true ? a.key(c) : f === "" ? `${a.key(c)} without an argument` : `${a.key(c)}=${f}`;
  } }, n = (g) => {
    let { colorsModule: c, levenshteinDistance: f } = g;
    return class extends t.ChoiceSchema {
      constructor(_) {
        let { name: w, flags: F } = _;
        super({ name: w, choices: F }), this._flags = [...F].sort();
      }
      preprocess(_, w) {
        if (typeof _ == "string" && _.length > 0 && !this._flags.includes(_)) {
          let F = this._flags.find((N) => f(N, _) < 3);
          if (F) return w.logger.warn([`Unknown flag ${c.yellow(w.descriptor.value(_))},`, `did you mean ${c.blue(w.descriptor.value(F))}?`].join(" ")), F;
        }
        return _;
      }
      expected() {
        return "a flag";
      }
    };
  }, u;
  function i(g, c) {
    let { logger: f = false, isCLI: E2 = false, passThrough: _ = false, colorsModule: w = null, levenshteinDistance: F = null } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, N = _ ? Array.isArray(_) ? (T, m) => _.includes(T) ? { [T]: m } : void 0 : (T, m) => ({ [T]: m }) : (T, m, C) => {
      let o = C.schemas, { _: h } = o, v = $n(o, cD);
      return t.levenUnknownHandler(T, m, Object.assign(Object.assign({}, C), {}, { schemas: v }));
    }, x = E2 ? a : t.apiDescriptor, I = l(c, { isCLI: E2, colorsModule: w, levenshteinDistance: F }), P = new t.Normalizer(I, { logger: f, unknown: N, descriptor: x }), $2 = f !== false;
    $2 && u && (P._hasDeprecationWarned = u);
    let D = P.normalize(g);
    return $2 && (u = P._hasDeprecationWarned), E2 && D["plugin-search"] === false && (D["plugin-search-dir"] = false), D;
  }
  function l(g, c) {
    let { isCLI: f, colorsModule: E2, levenshteinDistance: _ } = c, w = [];
    f && w.push(t.AnySchema.create({ name: "_" }));
    for (let F of g) w.push(p(F, { isCLI: f, optionInfos: g, colorsModule: E2, levenshteinDistance: _ })), F.alias && f && w.push(t.AliasSchema.create({ name: F.alias, sourceName: F.name }));
    return w;
  }
  function p(g, c) {
    let { isCLI: f, optionInfos: E2, colorsModule: _, levenshteinDistance: w } = c, { name: F } = g;
    if (F === "plugin-search-dir" || F === "pluginSearchDirs") return t.AnySchema.create({ name: F, preprocess(P) {
      return P === false || (P = Array.isArray(P) ? P : [P]), P;
    }, validate(P) {
      return P === false ? true : P.every(($2) => typeof $2 == "string");
    }, expected() {
      return "false or paths to plugin search dir";
    } });
    let N = { name: F }, x, I = {};
    switch (g.type) {
      case "int":
        x = t.IntegerSchema, f && (N.preprocess = Number);
        break;
      case "string":
        x = t.StringSchema;
        break;
      case "choice":
        x = t.ChoiceSchema, N.choices = g.choices.map((P) => typeof P == "object" && P.redirect ? Object.assign(Object.assign({}, P), {}, { redirect: { to: { key: g.name, value: P.redirect } } }) : P);
        break;
      case "boolean":
        x = t.BooleanSchema;
        break;
      case "flag":
        x = n({ colorsModule: _, levenshteinDistance: w }), N.flags = E2.flatMap((P) => [P.alias, P.description && P.name, P.oppositeDescription && `no-${P.name}`].filter(Boolean));
        break;
      case "path":
        x = t.StringSchema;
        break;
      default:
        throw new Error(`Unexpected type ${g.type}`);
    }
    if (g.exception ? N.validate = (P, $2, D) => g.exception(P) || $2.validate(P, D) : N.validate = (P, $2, D) => P === void 0 || $2.validate(P, D), g.redirect && (I.redirect = (P) => P ? { to: { key: g.redirect.option, value: g.redirect.value } } : void 0), g.deprecated && (I.deprecated = true), f && !g.array) {
      let P = N.preprocess || (($2) => $2);
      N.preprocess = ($2, D, T) => D.preprocess(P(Array.isArray($2) ? s($2) : $2), T);
    }
    return g.array ? t.ArraySchema.create(Object.assign(Object.assign(Object.assign({}, f ? { preprocess: (P) => Array.isArray(P) ? P : [P] } : {}), I), {}, { valueSchema: x.create(N) })) : x.create(Object.assign(Object.assign({}, N), I));
  }
  function d(g, c, f) {
    return i(g, c, f);
  }
  function y(g, c, f) {
    return i(g, c, Object.assign({ isCLI: true }, f));
  }
  r.exports = { normalizeApiOptions: d, normalizeCliOptions: y };
} });
var ut = te({ "src/language-js/loc.js"(e, r) {
  "use strict";
  ne();
  var t = Jn();
  function s(l) {
    var p, d;
    let y = l.range ? l.range[0] : l.start, g = (p = (d = l.declaration) === null || d === void 0 ? void 0 : d.decorators) !== null && p !== void 0 ? p : l.decorators;
    return t(g) ? Math.min(s(g[0]), y) : y;
  }
  function a(l) {
    return l.range ? l.range[1] : l.end;
  }
  function n(l, p) {
    let d = s(l);
    return Number.isInteger(d) && d === s(p);
  }
  function u(l, p) {
    let d = a(l);
    return Number.isInteger(d) && d === a(p);
  }
  function i(l, p) {
    return n(l, p) && u(l, p);
  }
  r.exports = { locStart: s, locEnd: a, hasSameLocStart: n, hasSameLoc: i };
} });
var Bm = te({ "src/main/load-parser.js"(e, r) {
  ne(), r.exports = () => {
  };
} });
var Nm = te({ "scripts/build/shims/babel-highlight.cjs"(e, r) {
  "use strict";
  ne();
  var t = Pr(), s = { shouldHighlight: () => false, getChalk: () => t };
  r.exports = s;
} });
var wm = te({ "node_modules/@babel/code-frame/lib/index.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.codeFrameColumns = u, e.default = i;
  var r = Nm(), t = false;
  function s(l) {
    return { gutter: l.grey, marker: l.red.bold, message: l.red.bold };
  }
  var a = /\r\n|[\n\r\u2028\u2029]/;
  function n(l, p, d) {
    let y = Object.assign({ column: 0, line: -1 }, l.start), g = Object.assign({}, y, l.end), { linesAbove: c = 2, linesBelow: f = 3 } = d || {}, E2 = y.line, _ = y.column, w = g.line, F = g.column, N = Math.max(E2 - (c + 1), 0), x = Math.min(p.length, w + f);
    E2 === -1 && (N = 0), w === -1 && (x = p.length);
    let I = w - E2, P = {};
    if (I) for (let $2 = 0; $2 <= I; $2++) {
      let D = $2 + E2;
      if (!_) P[D] = true;
      else if ($2 === 0) {
        let T = p[D - 1].length;
        P[D] = [_, T - _ + 1];
      } else if ($2 === I) P[D] = [0, F];
      else {
        let T = p[D - $2].length;
        P[D] = [0, T];
      }
    }
    else _ === F ? _ ? P[E2] = [_, 0] : P[E2] = true : P[E2] = [_, F - _];
    return { start: N, end: x, markerLines: P };
  }
  function u(l, p) {
    let d = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, y = (d.highlightCode || d.forceColor) && (0, r.shouldHighlight)(d), g = (0, r.getChalk)(d), c = s(g), f = ($2, D) => y ? $2(D) : D, E2 = l.split(a), { start: _, end: w, markerLines: F } = n(p, E2, d), N = p.start && typeof p.start.column == "number", x = String(w).length, P = (y ? (0, r.default)(l, d) : l).split(a, w).slice(_, w).map(($2, D) => {
      let T = _ + 1 + D, C = ` ${` ${T}`.slice(-x)} |`, o = F[T], h = !F[T + 1];
      if (o) {
        let v = "";
        if (Array.isArray(o)) {
          let S = $2.slice(0, Math.max(o[0] - 1, 0)).replace(/[^\t]/g, " "), b = o[1] || 1;
          v = [`
 `, f(c.gutter, C.replace(/\d/g, " ")), " ", S, f(c.marker, "^").repeat(b)].join(""), h && d.message && (v += " " + f(c.message, d.message));
        }
        return [f(c.marker, ">"), f(c.gutter, C), $2.length > 0 ? ` ${$2}` : "", v].join("");
      } else return ` ${f(c.gutter, C)}${$2.length > 0 ? ` ${$2}` : ""}`;
    }).join(`
`);
    return d.message && !N && (P = `${" ".repeat(x + 1)}${d.message}
${P}`), y ? g.reset(P) : P;
  }
  function i(l, p, d) {
    let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (!t) {
      t = true;
      let c = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (Nt.emitWarning) Nt.emitWarning(c, "DeprecationWarning");
      else {
        let f = new Error(c);
        f.name = "DeprecationWarning", console.warn(new Error(c));
      }
    }
    return d = Math.max(d, 0), u(l, { start: { column: d, line: p } }, y);
  }
} });
var Qn = te({ "src/main/parser.js"(e, r) {
  "use strict";
  ne();
  var { ConfigError: t } = Kt(), s = ut(), a = Bm(), { locStart: n, locEnd: u } = s, i = Object.getOwnPropertyNames, l = Object.getOwnPropertyDescriptor;
  function p(g) {
    let c = {};
    for (let f of g.plugins) if (f.parsers) for (let E2 of i(f.parsers)) Object.defineProperty(c, E2, l(f.parsers, E2));
    return c;
  }
  function d(g) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : p(g);
    if (typeof g.parser == "function") return { parse: g.parser, astFormat: "estree", locStart: n, locEnd: u };
    if (typeof g.parser == "string") {
      if (Object.prototype.hasOwnProperty.call(c, g.parser)) return c[g.parser];
      throw new t(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`);
    }
  }
  function y(g, c) {
    let f = p(c), E2 = Object.defineProperties({}, Object.fromEntries(Object.keys(f).map((w) => [w, { enumerable: true, get() {
      return f[w].parse;
    } }]))), _ = d(c, f);
    try {
      return _.preprocess && (g = _.preprocess(g, c)), { text: g, ast: _.parse(g, E2, c) };
    } catch (w) {
      let { loc: F } = w;
      if (F) {
        let { codeFrameColumns: N } = wm();
        throw w.codeFrame = N(g, F, { highlightCode: true }), w.message += `
` + w.codeFrame, w;
      }
      throw w;
    }
  }
  r.exports = { parse: y, resolveParser: d };
} });
var Ka = te({ "src/main/options.js"(e, r) {
  "use strict";
  ne();
  var t = HD(), { UndefinedParserError: s } = Kt(), { getSupportInfo: a } = Un(), n = Tm(), { resolveParser: u } = Qn(), i = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
  function l(y) {
    let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, c = Object.assign({}, y), f = a({ plugins: y.plugins, showUnreleased: true, showDeprecated: true }).options, E2 = Object.assign(Object.assign({}, i), Object.fromEntries(f.filter((x) => x.default !== void 0).map((x) => [x.name, x.default])));
    if (!c.parser) {
      if (!c.filepath) (g.logger || console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."), c.parser = "babel";
      else if (c.parser = d(c.filepath, c.plugins), !c.parser) throw new s(`No parser could be inferred for file: ${c.filepath}`);
    }
    let _ = u(n.normalizeApiOptions(c, [f.find((x) => x.name === "parser")], { passThrough: true, logger: false }));
    c.astFormat = _.astFormat, c.locEnd = _.locEnd, c.locStart = _.locStart;
    let w = p(c);
    c.printer = w.printers[c.astFormat];
    let F = Object.fromEntries(f.filter((x) => x.pluginDefaults && x.pluginDefaults[w.name] !== void 0).map((x) => [x.name, x.pluginDefaults[w.name]])), N = Object.assign(Object.assign({}, E2), F);
    for (let [x, I] of Object.entries(N)) (c[x] === null || c[x] === void 0) && (c[x] = I);
    return c.parser === "json" && (c.trailingComma = "none"), n.normalizeApiOptions(c, f, Object.assign({ passThrough: Object.keys(i) }, g));
  }
  function p(y) {
    let { astFormat: g } = y;
    if (!g) throw new Error("getPlugin() requires astFormat to be set");
    let c = y.plugins.find((f) => f.printers && f.printers[g]);
    if (!c) throw new Error(`Couldn't find plugin for AST format "${g}"`);
    return c;
  }
  function d(y, g) {
    let c = t.basename(y).toLowerCase(), E2 = a({ plugins: g }).languages.filter((_) => _.since !== null).find((_) => _.extensions && _.extensions.some((w) => c.endsWith(w)) || _.filenames && _.filenames.some((w) => w.toLowerCase() === c));
    return E2 && E2.parsers[0];
  }
  r.exports = { normalize: l, hiddenDefaults: i, inferParser: d };
} });
var _m = te({ "src/main/massage-ast.js"(e, r) {
  "use strict";
  ne();
  function t(s, a, n) {
    if (Array.isArray(s)) return s.map((p) => t(p, a, n)).filter(Boolean);
    if (!s || typeof s != "object") return s;
    let u = a.printer.massageAstNode, i;
    u && u.ignoredProperties ? i = u.ignoredProperties : i = /* @__PURE__ */ new Set();
    let l = {};
    for (let [p, d] of Object.entries(s)) !i.has(p) && typeof d != "function" && (l[p] = t(d, a, s));
    if (u) {
      let p = u(s, l, n);
      if (p === null) return;
      if (p) return p;
    }
    return l;
  }
  r.exports = t;
} });
var Yt = te({ "scripts/build/shims/assert.cjs"(e, r) {
  "use strict";
  ne();
  var t = () => {
  };
  t.ok = t, t.strictEqual = t, r.exports = t;
} });
var et = te({ "src/main/comments.js"(e, r) {
  "use strict";
  ne();
  var t = Yt(), { builders: { line: s, hardline: a, breakParent: n, indent: u, lineSuffix: i, join: l, cursor: p } } = qe(), { hasNewline: d, skipNewline: y, skipSpaces: g, isPreviousLineEmpty: c, addLeadingComment: f, addDanglingComment: E2, addTrailingComment: _ } = Ue(), w = /* @__PURE__ */ new WeakMap();
  function F(k, M, R) {
    if (!k) return;
    let { printer: q, locStart: J2, locEnd: L } = M;
    if (R) {
      if (q.canAttachComment && q.canAttachComment(k)) {
        let V;
        for (V = R.length - 1; V >= 0 && !(J2(R[V]) <= J2(k) && L(R[V]) <= L(k)); --V) ;
        R.splice(V + 1, 0, k);
        return;
      }
    } else if (w.has(k)) return w.get(k);
    let Q2 = q.getCommentChildNodes && q.getCommentChildNodes(k, M) || typeof k == "object" && Object.entries(k).filter((V) => {
      let [j] = V;
      return j !== "enclosingNode" && j !== "precedingNode" && j !== "followingNode" && j !== "tokens" && j !== "comments" && j !== "parent";
    }).map((V) => {
      let [, j] = V;
      return j;
    });
    if (Q2) {
      R || (R = [], w.set(k, R));
      for (let V of Q2) F(V, M, R);
      return R;
    }
  }
  function N(k, M, R, q) {
    let { locStart: J2, locEnd: L } = R, Q2 = J2(M), V = L(M), j = F(k, R), Y, ie, ee = 0, ce = j.length;
    for (; ee < ce; ) {
      let W = ee + ce >> 1, K = j[W], de = J2(K), ue = L(K);
      if (de <= Q2 && V <= ue) return N(K, M, R, K);
      if (ue <= Q2) {
        Y = K, ee = W + 1;
        continue;
      }
      if (V <= de) {
        ie = K, ce = W;
        continue;
      }
      throw new Error("Comment location overlaps with node location");
    }
    if (q && q.type === "TemplateLiteral") {
      let { quasis: W } = q, K = C(W, M, R);
      Y && C(W, Y, R) !== K && (Y = null), ie && C(W, ie, R) !== K && (ie = null);
    }
    return { enclosingNode: q, precedingNode: Y, followingNode: ie };
  }
  var x = () => false;
  function I(k, M, R, q) {
    if (!Array.isArray(k)) return;
    let J2 = [], { locStart: L, locEnd: Q2, printer: { handleComments: V = {} } } = q, { avoidAstMutation: j, ownLine: Y = x, endOfLine: ie = x, remaining: ee = x } = V, ce = k.map((W, K) => Object.assign(Object.assign({}, N(M, W, q)), {}, { comment: W, text: R, options: q, ast: M, isLastComment: k.length - 1 === K }));
    for (let [W, K] of ce.entries()) {
      let { comment: de, precedingNode: ue, enclosingNode: Fe, followingNode: z, text: U, options: Z, ast: se, isLastComment: fe } = K;
      if (Z.parser === "json" || Z.parser === "json5" || Z.parser === "__js_expression" || Z.parser === "__vue_expression" || Z.parser === "__vue_ts_expression") {
        if (L(de) - L(se) <= 0) {
          f(se, de);
          continue;
        }
        if (Q2(de) - Q2(se) >= 0) {
          _(se, de);
          continue;
        }
      }
      let ge;
      if (j ? ge = [K] : (de.enclosingNode = Fe, de.precedingNode = ue, de.followingNode = z, ge = [de, U, Z, se, fe]), $2(U, Z, ce, W)) de.placement = "ownLine", Y(...ge) || (z ? f(z, de) : ue ? _(ue, de) : E2(Fe || se, de));
      else if (D(U, Z, ce, W)) de.placement = "endOfLine", ie(...ge) || (ue ? _(ue, de) : z ? f(z, de) : E2(Fe || se, de));
      else if (de.placement = "remaining", !ee(...ge)) if (ue && z) {
        let he = J2.length;
        he > 0 && J2[he - 1].followingNode !== z && T(J2, U, Z), J2.push(K);
      } else ue ? _(ue, de) : z ? f(z, de) : E2(Fe || se, de);
    }
    if (T(J2, R, q), !j) for (let W of k) delete W.precedingNode, delete W.enclosingNode, delete W.followingNode;
  }
  var P = (k) => !/[\S\n\u2028\u2029]/.test(k);
  function $2(k, M, R, q) {
    let { comment: J2, precedingNode: L } = R[q], { locStart: Q2, locEnd: V } = M, j = Q2(J2);
    if (L) for (let Y = q - 1; Y >= 0; Y--) {
      let { comment: ie, precedingNode: ee } = R[Y];
      if (ee !== L || !P(k.slice(V(ie), j))) break;
      j = Q2(ie);
    }
    return d(k, j, { backwards: true });
  }
  function D(k, M, R, q) {
    let { comment: J2, followingNode: L } = R[q], { locStart: Q2, locEnd: V } = M, j = V(J2);
    if (L) for (let Y = q + 1; Y < R.length; Y++) {
      let { comment: ie, followingNode: ee } = R[Y];
      if (ee !== L || !P(k.slice(j, Q2(ie)))) break;
      j = V(ie);
    }
    return d(k, j);
  }
  function T(k, M, R) {
    let q = k.length;
    if (q === 0) return;
    let { precedingNode: J2, followingNode: L, enclosingNode: Q2 } = k[0], V = R.printer.getGapRegex && R.printer.getGapRegex(Q2) || /^[\s(]*$/, j = R.locStart(L), Y;
    for (Y = q; Y > 0; --Y) {
      let { comment: ie, precedingNode: ee, followingNode: ce } = k[Y - 1];
      t.strictEqual(ee, J2), t.strictEqual(ce, L);
      let W = M.slice(R.locEnd(ie), j);
      if (V.test(W)) j = R.locStart(ie);
      else break;
    }
    for (let [ie, { comment: ee }] of k.entries()) ie < Y ? _(J2, ee) : f(L, ee);
    for (let ie of [J2, L]) ie.comments && ie.comments.length > 1 && ie.comments.sort((ee, ce) => R.locStart(ee) - R.locStart(ce));
    k.length = 0;
  }
  function m(k, M) {
    let R = k.getValue();
    return R.printed = true, M.printer.printComment(k, M);
  }
  function C(k, M, R) {
    let q = R.locStart(M) - 1;
    for (let J2 = 1; J2 < k.length; ++J2) if (q < R.locStart(k[J2])) return J2 - 1;
    return 0;
  }
  function o(k, M) {
    let R = k.getValue(), q = [m(k, M)], { printer: J2, originalText: L, locStart: Q2, locEnd: V } = M;
    if (J2.isBlockComment && J2.isBlockComment(R)) {
      let ie = d(L, V(R)) ? d(L, Q2(R), { backwards: true }) ? a : s : " ";
      q.push(ie);
    } else q.push(a);
    let Y = y(L, g(L, V(R)));
    return Y !== false && d(L, Y) && q.push(a), q;
  }
  function h(k, M) {
    let R = k.getValue(), q = m(k, M), { printer: J2, originalText: L, locStart: Q2 } = M, V = J2.isBlockComment && J2.isBlockComment(R);
    if (d(L, Q2(R), { backwards: true })) {
      let Y = c(L, R, Q2);
      return i([a, Y ? a : "", q]);
    }
    let j = [" ", q];
    return V || (j = [i(j), n]), j;
  }
  function v(k, M, R, q) {
    let J2 = [], L = k.getValue();
    return !L || !L.comments || (k.each(() => {
      let Q2 = k.getValue();
      !Q2.leading && !Q2.trailing && (!q || q(Q2)) && J2.push(m(k, M));
    }, "comments"), J2.length === 0) ? "" : R ? l(a, J2) : u([a, l(a, J2)]);
  }
  function S(k, M, R) {
    let q = k.getValue();
    if (!q) return {};
    let J2 = q.comments || [];
    R && (J2 = J2.filter((j) => !R.has(j)));
    let L = q === M.cursorNode;
    if (J2.length === 0) {
      let j = L ? p : "";
      return { leading: j, trailing: j };
    }
    let Q2 = [], V = [];
    return k.each(() => {
      let j = k.getValue();
      if (R && R.has(j)) return;
      let { leading: Y, trailing: ie } = j;
      Y ? Q2.push(o(k, M)) : ie && V.push(h(k, M));
    }, "comments"), L && (Q2.unshift(p), V.push(p)), { leading: Q2, trailing: V };
  }
  function b(k, M, R, q) {
    let { leading: J2, trailing: L } = S(k, R, q);
    return !J2 && !L ? M : [J2, M, L];
  }
  function B(k) {
    if (k) for (let M of k) {
      if (!M.printed) throw new Error('Comment "' + M.value.trim() + '" was not printed. Please report this error!');
      delete M.printed;
    }
  }
  r.exports = { attach: I, printComments: b, printCommentsSeparately: S, printDanglingComments: v, getSortedChildNodes: F, ensureAllCommentsPrinted: B };
} });
var Pm = te({ "src/common/ast-path.js"(e, r) {
  "use strict";
  ne();
  var t = lt();
  function s(u, i) {
    let l = a(u.stack, i);
    return l === -1 ? null : u.stack[l];
  }
  function a(u, i) {
    for (let l = u.length - 1; l >= 0; l -= 2) {
      let p = u[l];
      if (p && !Array.isArray(p) && --i < 0) return l;
    }
    return -1;
  }
  var n = class {
    constructor(u) {
      this.stack = [u];
    }
    getName() {
      let { stack: u } = this, { length: i } = u;
      return i > 1 ? u[i - 2] : null;
    }
    getValue() {
      return t(this.stack);
    }
    getNode() {
      let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return s(this, u);
    }
    getParentNode() {
      let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return s(this, u + 1);
    }
    call(u) {
      let { stack: i } = this, { length: l } = i, p = t(i);
      for (var d = arguments.length, y = new Array(d > 1 ? d - 1 : 0), g = 1; g < d; g++) y[g - 1] = arguments[g];
      for (let f of y) p = p[f], i.push(f, p);
      let c = u(this);
      return i.length = l, c;
    }
    callParent(u) {
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, l = a(this.stack, i + 1), p = this.stack.splice(l + 1), d = u(this);
      return this.stack.push(...p), d;
    }
    each(u) {
      let { stack: i } = this, { length: l } = i, p = t(i);
      for (var d = arguments.length, y = new Array(d > 1 ? d - 1 : 0), g = 1; g < d; g++) y[g - 1] = arguments[g];
      for (let c of y) p = p[c], i.push(c, p);
      for (let c = 0; c < p.length; ++c) i.push(c, p[c]), u(this, c, p), i.length -= 2;
      i.length = l;
    }
    map(u) {
      let i = [];
      for (var l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), d = 1; d < l; d++) p[d - 1] = arguments[d];
      return this.each((y, g, c) => {
        i[g] = u(y, g, c);
      }, ...p), i;
    }
    try(u) {
      let { stack: i } = this, l = [...i];
      try {
        return u();
      } finally {
        i.length = 0, i.push(...l);
      }
    }
    match() {
      let u = this.stack.length - 1, i = null, l = this.stack[u--];
      for (var p = arguments.length, d = new Array(p), y = 0; y < p; y++) d[y] = arguments[y];
      for (let g of d) {
        if (l === void 0) return false;
        let c = null;
        if (typeof i == "number" && (c = i, i = this.stack[u--], l = this.stack[u--]), g && !g(l, i, c)) return false;
        i = this.stack[u--], l = this.stack[u--];
      }
      return true;
    }
    findAncestor(u) {
      let i = this.stack.length - 1, l = null, p = this.stack[i--];
      for (; p; ) {
        let d = null;
        if (typeof l == "number" && (d = l, l = this.stack[i--], p = this.stack[i--]), l !== null && u(p, l, d)) return p;
        l = this.stack[i--], p = this.stack[i--];
      }
    }
  };
  r.exports = n;
} });
var Im = te({ "src/main/multiparser.js"(e, r) {
  "use strict";
  ne();
  var { utils: { stripTrailingHardline: t } } = qe(), { normalize: s } = Ka(), a = et();
  function n(i, l, p, d) {
    if (p.printer.embed && p.embeddedLanguageFormatting === "auto") return p.printer.embed(i, l, (y, g, c) => u(y, g, p, d, c), p);
  }
  function u(i, l, p, d) {
    let { stripTrailingHardline: y = false } = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {}, g = s(Object.assign(Object.assign(Object.assign({}, p), l), {}, { parentParser: p.parser, originalText: i }), { passThrough: true }), c = Qn().parse(i, g), { ast: f } = c;
    i = c.text;
    let E2 = f.comments;
    delete f.comments, a.attach(E2, f, i, g), g[Symbol.for("comments")] = E2 || [], g[Symbol.for("tokens")] = f.tokens || [];
    let _ = d(f, g);
    return a.ensureAllCommentsPrinted(E2), y ? typeof _ == "string" ? _.replace(/(?:\r?\n)*$/, "") : t(_) : _;
  }
  r.exports = { printSubtree: n };
} });
var km = te({ "src/main/ast-to-doc.js"(e, r) {
  "use strict";
  ne();
  var t = Pm(), { builders: { hardline: s, addAlignmentToDoc: a }, utils: { propagateBreaks: n } } = qe(), { printComments: u } = et(), i = Im();
  function l(y, g) {
    let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, { printer: f } = g;
    f.preprocess && (y = f.preprocess(y, g));
    let E2 = /* @__PURE__ */ new Map(), _ = new t(y), w = F();
    return c > 0 && (w = a([s, w], c, g.tabWidth)), n(w), w;
    function F(x, I) {
      return x === void 0 || x === _ ? N(I) : Array.isArray(x) ? _.call(() => N(I), ...x) : _.call(() => N(I), x);
    }
    function N(x) {
      let I = _.getValue(), P = I && typeof I == "object" && x === void 0;
      if (P && E2.has(I)) return E2.get(I);
      let $2 = d(_, g, F, x);
      return P && E2.set(I, $2), $2;
    }
  }
  function p(y, g) {
    let { originalText: c, [Symbol.for("comments")]: f, locStart: E2, locEnd: _ } = g, w = E2(y), F = _(y), N = /* @__PURE__ */ new Set();
    for (let x of f) E2(x) >= w && _(x) <= F && (x.printed = true, N.add(x));
    return { doc: c.slice(w, F), printedComments: N };
  }
  function d(y, g, c, f) {
    let E2 = y.getValue(), { printer: _ } = g, w, F;
    if (_.hasPrettierIgnore && _.hasPrettierIgnore(y)) ({ doc: w, printedComments: F } = p(E2, g));
    else {
      if (E2) try {
        w = i.printSubtree(y, c, g, l);
      } catch (N) {
        if (globalThis.PRETTIER_DEBUG) throw N;
      }
      w || (w = _.print(y, g, c, f));
    }
    return (!_.willPrintOwnComments || !_.willPrintOwnComments(y, g)) && (w = u(y, w, g, F)), w;
  }
  r.exports = l;
} });
var Lm = te({ "src/main/range-util.js"(e, r) {
  "use strict";
  ne();
  var t = Yt(), s = et(), a = (f) => {
    let { parser: E2 } = f;
    return E2 === "json" || E2 === "json5" || E2 === "json-stringify";
  };
  function n(f, E2) {
    let _ = [f.node, ...f.parentNodes], w = /* @__PURE__ */ new Set([E2.node, ...E2.parentNodes]);
    return _.find((F) => d.has(F.type) && w.has(F));
  }
  function u(f) {
    let E2 = f.length - 1;
    for (; ; ) {
      let _ = f[E2];
      if (_ && (_.type === "Program" || _.type === "File")) E2--;
      else break;
    }
    return f.slice(0, E2 + 1);
  }
  function i(f, E2, _) {
    let { locStart: w, locEnd: F } = _, N = f.node, x = E2.node;
    if (N === x) return { startNode: N, endNode: x };
    let I = w(f.node);
    for (let $2 of u(E2.parentNodes)) if (w($2) >= I) x = $2;
    else break;
    let P = F(E2.node);
    for (let $2 of u(f.parentNodes)) {
      if (F($2) <= P) N = $2;
      else break;
      if (N === x) break;
    }
    return { startNode: N, endNode: x };
  }
  function l(f, E2, _, w) {
    let F = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [], N = arguments.length > 5 ? arguments[5] : void 0, { locStart: x, locEnd: I } = _, P = x(f), $2 = I(f);
    if (!(E2 > $2 || E2 < P || N === "rangeEnd" && E2 === P || N === "rangeStart" && E2 === $2)) {
      for (let D of s.getSortedChildNodes(f, _)) {
        let T = l(D, E2, _, w, [f, ...F], N);
        if (T) return T;
      }
      if (!w || w(f, F[0])) return { node: f, parentNodes: F };
    }
  }
  function p(f, E2) {
    return E2 !== "DeclareExportDeclaration" && f !== "TypeParameterDeclaration" && (f === "Directive" || f === "TypeAlias" || f === "TSExportAssignment" || f.startsWith("Declare") || f.startsWith("TSDeclare") || f.endsWith("Statement") || f.endsWith("Declaration"));
  }
  var d = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), y = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
  function g(f, E2, _) {
    if (!E2) return false;
    switch (f.parser) {
      case "flow":
      case "babel":
      case "babel-flow":
      case "babel-ts":
      case "typescript":
      case "acorn":
      case "espree":
      case "meriyah":
      case "__babel_estree":
        return p(E2.type, _ && _.type);
      case "json":
      case "json5":
      case "json-stringify":
        return d.has(E2.type);
      case "graphql":
        return y.has(E2.kind);
      case "vue":
        return E2.tag !== "root";
    }
    return false;
  }
  function c(f, E2, _) {
    let { rangeStart: w, rangeEnd: F, locStart: N, locEnd: x } = E2;
    t.ok(F > w);
    let I = f.slice(w, F).search(/\S/), P = I === -1;
    if (!P) for (w += I; F > w && !/\S/.test(f[F - 1]); --F) ;
    let $2 = l(_, w, E2, (C, o) => g(E2, C, o), [], "rangeStart"), D = P ? $2 : l(_, F, E2, (C) => g(E2, C), [], "rangeEnd");
    if (!$2 || !D) return { rangeStart: 0, rangeEnd: 0 };
    let T, m;
    if (a(E2)) {
      let C = n($2, D);
      T = C, m = C;
    } else ({ startNode: T, endNode: m } = i($2, D, E2));
    return { rangeStart: Math.min(N(T), N(m)), rangeEnd: Math.max(x(T), x(m)) };
  }
  r.exports = { calculateRange: c, findNodeAtOffset: l };
} });
var Om = te({ "src/main/core.js"(e, r) {
  "use strict";
  ne();
  var { diffArrays: t } = vD(), { printer: { printDocToString: s }, debug: { printDocToDebug: a } } = qe(), { getAlignmentSize: n } = Ue(), { guessEndOfLine: u, convertEndOfLineToChars: i, countEndOfLineChars: l, normalizeEndOfLine: p } = Hn(), d = Ka().normalize, y = _m(), g = et(), c = Qn(), f = km(), E2 = Lm(), _ = "\uFEFF", w = Symbol("cursor");
  function F(m, C, o) {
    let h = C.comments;
    return h && (delete C.comments, g.attach(h, C, m, o)), o[Symbol.for("comments")] = h || [], o[Symbol.for("tokens")] = C.tokens || [], o.originalText = m, h;
  }
  function N(m, C) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    if (!m || m.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
    let { ast: h, text: v } = c.parse(m, C);
    if (C.cursorOffset >= 0) {
      let k = E2.findNodeAtOffset(h, C.cursorOffset, C);
      k && k.node && (C.cursorNode = k.node);
    }
    let S = F(v, h, C), b = f(h, C, o), B = s(b, C);
    if (g.ensureAllCommentsPrinted(S), o > 0) {
      let k = B.formatted.trim();
      B.cursorNodeStart !== void 0 && (B.cursorNodeStart -= B.formatted.indexOf(k)), B.formatted = k + i(C.endOfLine);
    }
    if (C.cursorOffset >= 0) {
      let k, M, R, q, J2;
      if (C.cursorNode && B.cursorNodeText ? (k = C.locStart(C.cursorNode), M = v.slice(k, C.locEnd(C.cursorNode)), R = C.cursorOffset - k, q = B.cursorNodeStart, J2 = B.cursorNodeText) : (k = 0, M = v, R = C.cursorOffset, q = 0, J2 = B.formatted), M === J2) return { formatted: B.formatted, cursorOffset: q + R, comments: S };
      let L = [...M];
      L.splice(R, 0, w);
      let Q2 = [...J2], V = t(L, Q2), j = q;
      for (let Y of V) if (Y.removed) {
        if (Y.value.includes(w)) break;
      } else j += Y.count;
      return { formatted: B.formatted, cursorOffset: j, comments: S };
    }
    return { formatted: B.formatted, cursorOffset: -1, comments: S };
  }
  function x(m, C) {
    let { ast: o, text: h } = c.parse(m, C), { rangeStart: v, rangeEnd: S } = E2.calculateRange(h, C, o), b = h.slice(v, S), B = Math.min(v, h.lastIndexOf(`
`, v) + 1), k = h.slice(B, v).match(/^\s*/)[0], M = n(k, C.tabWidth), R = N(b, Object.assign(Object.assign({}, C), {}, { rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: C.cursorOffset > v && C.cursorOffset <= S ? C.cursorOffset - v : -1, endOfLine: "lf" }), M), q = R.formatted.trimEnd(), { cursorOffset: J2 } = C;
    J2 > S ? J2 += q.length - b.length : R.cursorOffset >= 0 && (J2 = R.cursorOffset + v);
    let L = h.slice(0, v) + q + h.slice(S);
    if (C.endOfLine !== "lf") {
      let Q2 = i(C.endOfLine);
      J2 >= 0 && Q2 === `\r
` && (J2 += l(L.slice(0, J2), `
`)), L = L.replace(/\n/g, Q2);
    }
    return { formatted: L, cursorOffset: J2, comments: R.comments };
  }
  function I(m, C, o) {
    return typeof C != "number" || Number.isNaN(C) || C < 0 || C > m.length ? o : C;
  }
  function P(m, C) {
    let { cursorOffset: o, rangeStart: h, rangeEnd: v } = C;
    return o = I(m, o, -1), h = I(m, h, 0), v = I(m, v, m.length), Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: h, rangeEnd: v });
  }
  function $2(m, C) {
    let { cursorOffset: o, rangeStart: h, rangeEnd: v, endOfLine: S } = P(m, C), b = m.charAt(0) === _;
    if (b && (m = m.slice(1), o--, h--, v--), S === "auto" && (S = u(m)), m.includes("\r")) {
      let B = (k) => l(m.slice(0, Math.max(k, 0)), `\r
`);
      o -= B(o), h -= B(h), v -= B(v), m = p(m);
    }
    return { hasBOM: b, text: m, options: P(m, Object.assign(Object.assign({}, C), {}, { cursorOffset: o, rangeStart: h, rangeEnd: v, endOfLine: S })) };
  }
  function D(m, C) {
    let o = c.resolveParser(C);
    return !o.hasPragma || o.hasPragma(m);
  }
  function T(m, C) {
    let { hasBOM: o, text: h, options: v } = $2(m, d(C));
    if (v.rangeStart >= v.rangeEnd && h !== "" || v.requirePragma && !D(h, v)) return { formatted: m, cursorOffset: C.cursorOffset, comments: [] };
    let S;
    return v.rangeStart > 0 || v.rangeEnd < h.length ? S = x(h, v) : (!v.requirePragma && v.insertPragma && v.printer.insertPragma && !D(h, v) && (h = v.printer.insertPragma(h)), S = N(h, v)), o && (S.formatted = _ + S.formatted, S.cursorOffset >= 0 && S.cursorOffset++), S;
  }
  r.exports = { formatWithCursor: T, parse(m, C, o) {
    let { text: h, options: v } = $2(m, d(C)), S = c.parse(h, v);
    return o && (S.ast = y(S.ast, v)), S;
  }, formatAST(m, C) {
    C = d(C);
    let o = f(m, C);
    return s(o, C);
  }, formatDoc(m, C) {
    return T(a(m), Object.assign(Object.assign({}, C), {}, { parser: "__js_expression" })).formatted;
  }, printToDoc(m, C) {
    C = d(C);
    let { ast: o, text: h } = c.parse(m, C);
    return F(h, o, C), f(o, C);
  }, printDocToString(m, C) {
    return s(m, d(C));
  } };
} });
var jm = te({ "src/common/util-shared.js"(e, r) {
  "use strict";
  ne();
  var { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: d, skipEverythingButNewLine: y, skipInlineComment: g, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: E2, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I, addLeadingComment: P, addDanglingComment: $2, addTrailingComment: D } = Ue();
  r.exports = { getMaxContinuousCount: t, getStringWidth: s, getAlignmentSize: a, getIndentSize: n, skip: u, skipWhitespace: i, skipSpaces: l, skipNewline: p, skipToLineEnd: d, skipEverythingButNewLine: y, skipInlineComment: g, skipTrailingComment: c, hasNewline: f, hasNewlineInRange: E2, hasSpaces: _, isNextLineEmpty: w, isNextLineEmptyAfterIndex: F, isPreviousLineEmpty: N, getNextNonSpaceNonCommentCharacterIndex: x, makeString: I, addLeadingComment: P, addDanglingComment: $2, addTrailingComment: D };
} });
var wt = te({ "src/utils/create-language.js"(e, r) {
  "use strict";
  ne(), r.exports = function(t, s) {
    let { languageId: a } = t, n = $n(t, pD);
    return Object.assign(Object.assign({ linguistLanguageId: a }, n), s(t));
  };
} });
var qm = te({ "node_modules/esutils/lib/ast.js"(e, r) {
  ne(), function() {
    "use strict";
    function t(l) {
      if (l == null) return false;
      switch (l.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return true;
      }
      return false;
    }
    function s(l) {
      if (l == null) return false;
      switch (l.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return true;
      }
      return false;
    }
    function a(l) {
      if (l == null) return false;
      switch (l.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function n(l) {
      return a(l) || l != null && l.type === "FunctionDeclaration";
    }
    function u(l) {
      switch (l.type) {
        case "IfStatement":
          return l.alternate != null ? l.alternate : l.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return l.body;
      }
      return null;
    }
    function i(l) {
      var p;
      if (l.type !== "IfStatement" || l.alternate == null) return false;
      p = l.consequent;
      do {
        if (p.type === "IfStatement" && p.alternate == null) return true;
        p = u(p);
      } while (p);
      return false;
    }
    r.exports = { isExpression: t, isStatement: a, isIterationStatement: s, isSourceElement: n, isProblematicIfStatement: i, trailingStatement: u };
  }();
} });
var Ya = te({ "node_modules/esutils/lib/code.js"(e, r) {
  ne(), function() {
    "use strict";
    var t, s, a, n, u, i;
    s = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/, NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/ }, t = { NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/, NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/ };
    function l(F) {
      return 48 <= F && F <= 57;
    }
    function p(F) {
      return 48 <= F && F <= 57 || 97 <= F && F <= 102 || 65 <= F && F <= 70;
    }
    function d(F) {
      return F >= 48 && F <= 55;
    }
    a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
    function y(F) {
      return F === 32 || F === 9 || F === 11 || F === 12 || F === 160 || F >= 5760 && a.indexOf(F) >= 0;
    }
    function g(F) {
      return F === 10 || F === 13 || F === 8232 || F === 8233;
    }
    function c(F) {
      if (F <= 65535) return String.fromCharCode(F);
      var N = String.fromCharCode(Math.floor((F - 65536) / 1024) + 55296), x = String.fromCharCode((F - 65536) % 1024 + 56320);
      return N + x;
    }
    for (n = new Array(128), i = 0; i < 128; ++i) n[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i === 36 || i === 95;
    for (u = new Array(128), i = 0; i < 128; ++i) u[i] = i >= 97 && i <= 122 || i >= 65 && i <= 90 || i >= 48 && i <= 57 || i === 36 || i === 95;
    function f(F) {
      return F < 128 ? n[F] : s.NonAsciiIdentifierStart.test(c(F));
    }
    function E2(F) {
      return F < 128 ? u[F] : s.NonAsciiIdentifierPart.test(c(F));
    }
    function _(F) {
      return F < 128 ? n[F] : t.NonAsciiIdentifierStart.test(c(F));
    }
    function w(F) {
      return F < 128 ? u[F] : t.NonAsciiIdentifierPart.test(c(F));
    }
    r.exports = { isDecimalDigit: l, isHexDigit: p, isOctalDigit: d, isWhiteSpace: y, isLineTerminator: g, isIdentifierStartES5: f, isIdentifierPartES5: E2, isIdentifierStartES6: _, isIdentifierPartES6: w };
  }();
} });
var Mm = te({ "node_modules/esutils/lib/keyword.js"(e, r) {
  ne(), function() {
    "use strict";
    var t = Ya();
    function s(f) {
      switch (f) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return true;
        default:
          return false;
      }
    }
    function a(f, E2) {
      return !E2 && f === "yield" ? false : n(f, E2);
    }
    function n(f, E2) {
      if (E2 && s(f)) return true;
      switch (f.length) {
        case 2:
          return f === "if" || f === "in" || f === "do";
        case 3:
          return f === "var" || f === "for" || f === "new" || f === "try";
        case 4:
          return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
        case 5:
          return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" || f === "super";
        case 6:
          return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
        case 7:
          return f === "default" || f === "finally" || f === "extends";
        case 8:
          return f === "function" || f === "continue" || f === "debugger";
        case 10:
          return f === "instanceof";
        default:
          return false;
      }
    }
    function u(f, E2) {
      return f === "null" || f === "true" || f === "false" || a(f, E2);
    }
    function i(f, E2) {
      return f === "null" || f === "true" || f === "false" || n(f, E2);
    }
    function l(f) {
      return f === "eval" || f === "arguments";
    }
    function p(f) {
      var E2, _, w;
      if (f.length === 0 || (w = f.charCodeAt(0), !t.isIdentifierStartES5(w))) return false;
      for (E2 = 1, _ = f.length; E2 < _; ++E2) if (w = f.charCodeAt(E2), !t.isIdentifierPartES5(w)) return false;
      return true;
    }
    function d(f, E2) {
      return (f - 55296) * 1024 + (E2 - 56320) + 65536;
    }
    function y(f) {
      var E2, _, w, F, N;
      if (f.length === 0) return false;
      for (N = t.isIdentifierStartES6, E2 = 0, _ = f.length; E2 < _; ++E2) {
        if (w = f.charCodeAt(E2), 55296 <= w && w <= 56319) {
          if (++E2, E2 >= _ || (F = f.charCodeAt(E2), !(56320 <= F && F <= 57343))) return false;
          w = d(w, F);
        }
        if (!N(w)) return false;
        N = t.isIdentifierPartES6;
      }
      return true;
    }
    function g(f, E2) {
      return p(f) && !u(f, E2);
    }
    function c(f, E2) {
      return y(f) && !i(f, E2);
    }
    r.exports = { isKeywordES5: a, isKeywordES6: n, isReservedWordES5: u, isReservedWordES6: i, isRestrictedWord: l, isIdentifierNameES5: p, isIdentifierNameES6: y, isIdentifierES5: g, isIdentifierES6: c };
  }();
} });
var Rm = te({ "node_modules/esutils/lib/utils.js"(e) {
  ne(), function() {
    "use strict";
    e.ast = qm(), e.code = Ya(), e.keyword = Mm();
  }();
} });
var _t = te({ "src/language-js/utils/is-block-comment.js"(e, r) {
  "use strict";
  ne();
  var t = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), s = (a) => t.has(a == null ? void 0 : a.type);
  r.exports = s;
} });
var $m = te({ "src/language-js/utils/is-node-matches.js"(e, r) {
  "use strict";
  ne();
  function t(a, n) {
    let u = n.split(".");
    for (let i = u.length - 1; i >= 0; i--) {
      let l = u[i];
      if (i === 0) return a.type === "Identifier" && a.name === l;
      if (a.type !== "MemberExpression" || a.optional || a.computed || a.property.type !== "Identifier" || a.property.name !== l) return false;
      a = a.object;
    }
  }
  function s(a, n) {
    return n.some((u) => t(a, u));
  }
  r.exports = s;
} });
var Ke = te({ "src/language-js/utils/index.js"(e, r) {
  "use strict";
  ne();
  var t = Rm().keyword.isIdentifierNameES5, { getLast: s, hasNewline: a, skipWhitespace: n, isNonEmptyArray: u, isNextLineEmptyAfterIndex: i, getStringWidth: l } = Ue(), { locStart: p, locEnd: d, hasSameLocStart: y } = ut(), g = _t(), c = $m(), f = "(?:(?=.)\\s)", E2 = new RegExp(`^${f}*:`), _ = new RegExp(`^${f}*::`);
  function w(O) {
    var me2, _e;
    return ((me2 = O.extra) === null || me2 === void 0 ? void 0 : me2.parenthesized) && g((_e = O.trailingComments) === null || _e === void 0 ? void 0 : _e[0]) && E2.test(O.trailingComments[0].value);
  }
  function F(O) {
    let me2 = O == null ? void 0 : O[0];
    return g(me2) && _.test(me2.value);
  }
  function N(O, me2) {
    if (!O || typeof O != "object") return false;
    if (Array.isArray(O)) return O.some((He) => N(He, me2));
    let _e = me2(O);
    return typeof _e == "boolean" ? _e : Object.values(O).some((He) => N(He, me2));
  }
  function x(O) {
    return O.type === "AssignmentExpression" || O.type === "BinaryExpression" || O.type === "LogicalExpression" || O.type === "NGPipeExpression" || O.type === "ConditionalExpression" || de(O) || ue(O) || O.type === "SequenceExpression" || O.type === "TaggedTemplateExpression" || O.type === "BindExpression" || O.type === "UpdateExpression" && !O.prefix || st2(O) || O.type === "TSNonNullExpression";
  }
  function I(O) {
    var me2, _e, He, Ge, it, Qe;
    return O.expressions ? O.expressions[0] : (me2 = (_e = (He = (Ge = (it = (Qe = O.left) !== null && Qe !== void 0 ? Qe : O.test) !== null && it !== void 0 ? it : O.callee) !== null && Ge !== void 0 ? Ge : O.object) !== null && He !== void 0 ? He : O.tag) !== null && _e !== void 0 ? _e : O.argument) !== null && me2 !== void 0 ? me2 : O.expression;
  }
  function P(O, me2) {
    if (me2.expressions) return ["expressions", 0];
    if (me2.left) return ["left"];
    if (me2.test) return ["test"];
    if (me2.object) return ["object"];
    if (me2.callee) return ["callee"];
    if (me2.tag) return ["tag"];
    if (me2.argument) return ["argument"];
    if (me2.expression) return ["expression"];
    throw new Error("Unexpected node has no left side.");
  }
  function $2(O) {
    return O = new Set(O), (me2) => O.has(me2 == null ? void 0 : me2.type);
  }
  var D = $2(["Line", "CommentLine", "SingleLine", "HashbangComment", "HTMLOpen", "HTMLClose"]), T = $2(["ExportDefaultDeclaration", "ExportDefaultSpecifier", "DeclareExportDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration"]);
  function m(O) {
    let me2 = O.getParentNode();
    return O.getName() === "declaration" && T(me2) ? me2 : null;
  }
  var C = $2(["BooleanLiteral", "DirectiveLiteral", "Literal", "NullLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "RegExpLiteral", "StringLiteral", "TemplateLiteral", "TSTypeLiteral", "JSXText"]);
  function o(O) {
    return O.type === "NumericLiteral" || O.type === "Literal" && typeof O.value == "number";
  }
  function h(O) {
    return O.type === "UnaryExpression" && (O.operator === "+" || O.operator === "-") && o(O.argument);
  }
  function v(O) {
    return O.type === "StringLiteral" || O.type === "Literal" && typeof O.value == "string";
  }
  var S = $2(["ObjectTypeAnnotation", "TSTypeLiteral", "TSMappedType"]), b = $2(["FunctionExpression", "ArrowFunctionExpression"]);
  function B(O) {
    return O.type === "FunctionExpression" || O.type === "ArrowFunctionExpression" && O.body.type === "BlockStatement";
  }
  function k(O) {
    return de(O) && O.callee.type === "Identifier" && ["async", "inject", "fakeAsync", "waitForAsync"].includes(O.callee.name);
  }
  var M = $2(["JSXElement", "JSXFragment"]);
  function R(O, me2) {
    if (O.parentParser !== "markdown" && O.parentParser !== "mdx") return false;
    let _e = me2.getNode();
    if (!_e.expression || !M(_e.expression)) return false;
    let He = me2.getParentNode();
    return He.type === "Program" && He.body.length === 1;
  }
  function q(O) {
    return O.kind === "get" || O.kind === "set";
  }
  function J2(O) {
    return q(O) || y(O, O.value);
  }
  function L(O) {
    return (O.type === "ObjectTypeProperty" || O.type === "ObjectTypeInternalSlot") && O.value.type === "FunctionTypeAnnotation" && !O.static && !J2(O);
  }
  function Q2(O) {
    return (O.type === "TypeAnnotation" || O.type === "TSTypeAnnotation") && O.typeAnnotation.type === "FunctionTypeAnnotation" && !O.static && !y(O, O.typeAnnotation);
  }
  var V = $2(["BinaryExpression", "LogicalExpression", "NGPipeExpression"]);
  function j(O) {
    return ue(O) || O.type === "BindExpression" && Boolean(O.object);
  }
  var Y = /* @__PURE__ */ new Set(["AnyTypeAnnotation", "TSAnyKeyword", "NullLiteralTypeAnnotation", "TSNullKeyword", "ThisTypeAnnotation", "TSThisType", "NumberTypeAnnotation", "TSNumberKeyword", "VoidTypeAnnotation", "TSVoidKeyword", "BooleanTypeAnnotation", "TSBooleanKeyword", "BigIntTypeAnnotation", "TSBigIntKeyword", "SymbolTypeAnnotation", "TSSymbolKeyword", "StringTypeAnnotation", "TSStringKeyword", "BooleanLiteralTypeAnnotation", "StringLiteralTypeAnnotation", "BigIntLiteralTypeAnnotation", "NumberLiteralTypeAnnotation", "TSLiteralType", "TSTemplateLiteralType", "EmptyTypeAnnotation", "MixedTypeAnnotation", "TSNeverKeyword", "TSObjectKeyword", "TSUndefinedKeyword", "TSUnknownKeyword"]);
  function ie(O) {
    return O ? !!((O.type === "GenericTypeAnnotation" || O.type === "TSTypeReference") && !O.typeParameters || Y.has(O.type)) : false;
  }
  function ee(O) {
    let me2 = /^(?:before|after)(?:Each|All)$/;
    return O.callee.type === "Identifier" && me2.test(O.callee.name) && O.arguments.length === 1;
  }
  var ce = ["it", "it.only", "it.skip", "describe", "describe.only", "describe.skip", "test", "test.only", "test.skip", "test.step", "test.describe", "test.describe.only", "test.describe.parallel", "test.describe.parallel.only", "test.describe.serial", "test.describe.serial.only", "skip", "xit", "xdescribe", "xtest", "fit", "fdescribe", "ftest"];
  function W(O) {
    return c(O, ce);
  }
  function K(O, me2) {
    if (O.type !== "CallExpression") return false;
    if (O.arguments.length === 1) {
      if (k(O) && me2 && K(me2)) return b(O.arguments[0]);
      if (ee(O)) return k(O.arguments[0]);
    } else if ((O.arguments.length === 2 || O.arguments.length === 3) && (O.arguments[0].type === "TemplateLiteral" || v(O.arguments[0])) && W(O.callee)) return O.arguments[2] && !o(O.arguments[2]) ? false : (O.arguments.length === 2 ? b(O.arguments[1]) : B(O.arguments[1]) && ve(O.arguments[1]).length <= 1) || k(O.arguments[1]);
    return false;
  }
  var de = $2(["CallExpression", "OptionalCallExpression"]), ue = $2(["MemberExpression", "OptionalMemberExpression"]);
  function Fe(O) {
    let me2 = "expressions";
    O.type === "TSTemplateLiteralType" && (me2 = "types");
    let _e = O[me2];
    return _e.length === 0 ? false : _e.every((He) => {
      if (Me2(He)) return false;
      if (He.type === "Identifier" || He.type === "ThisExpression") return true;
      if (ue(He)) {
        let Ge = He;
        for (; ue(Ge); ) if (Ge.property.type !== "Identifier" && Ge.property.type !== "Literal" && Ge.property.type !== "StringLiteral" && Ge.property.type !== "NumericLiteral" || (Ge = Ge.object, Me2(Ge))) return false;
        return Ge.type === "Identifier" || Ge.type === "ThisExpression";
      }
      return false;
    });
  }
  function z(O, me2) {
    return O === "+" || O === "-" ? O + me2 : me2;
  }
  function U(O, me2) {
    let _e = p(me2), He = n(O, d(me2));
    return He !== false && O.slice(_e, _e + 2) === "/*" && O.slice(He, He + 2) === "*/";
  }
  function Z(O, me2) {
    return M(me2) ? Oe(me2) : Me2(me2, be2.Leading, (_e) => a(O, d(_e)));
  }
  function se(O, me2) {
    return me2.parser !== "json" && v(O.key) && oe2(O.key).slice(1, -1) === O.key.value && (t(O.key.value) && !(me2.parser === "babel-ts" && O.type === "ClassProperty" || me2.parser === "typescript" && O.type === "PropertyDefinition") || fe(O.key.value) && String(Number(O.key.value)) === O.key.value && (me2.parser === "babel" || me2.parser === "acorn" || me2.parser === "espree" || me2.parser === "meriyah" || me2.parser === "__babel_estree"));
  }
  function fe(O) {
    return /^(?:\d+|\d+\.\d+)$/.test(O);
  }
  function ge(O, me2) {
    let _e = /^[fx]?(?:describe|it|test)$/;
    return me2.type === "TaggedTemplateExpression" && me2.quasi === O && me2.tag.type === "MemberExpression" && me2.tag.property.type === "Identifier" && me2.tag.property.name === "each" && (me2.tag.object.type === "Identifier" && _e.test(me2.tag.object.name) || me2.tag.object.type === "MemberExpression" && me2.tag.object.property.type === "Identifier" && (me2.tag.object.property.name === "only" || me2.tag.object.property.name === "skip") && me2.tag.object.object.type === "Identifier" && _e.test(me2.tag.object.object.name));
  }
  function he(O) {
    return O.quasis.some((me2) => me2.value.raw.includes(`
`));
  }
  function we(O, me2) {
    return (O.type === "TemplateLiteral" && he(O) || O.type === "TaggedTemplateExpression" && he(O.quasi)) && !a(me2, p(O), { backwards: true });
  }
  function ke(O) {
    if (!Me2(O)) return false;
    let me2 = s(ae(O, be2.Dangling));
    return me2 && !g(me2);
  }
  function Re(O) {
    if (O.length <= 1) return false;
    let me2 = 0;
    for (let _e of O) if (b(_e)) {
      if (me2 += 1, me2 > 1) return true;
    } else if (de(_e)) {
      for (let He of _e.arguments) if (b(He)) return true;
    }
    return false;
  }
  function Ne(O) {
    let me2 = O.getValue(), _e = O.getParentNode();
    return de(me2) && de(_e) && _e.callee === me2 && me2.arguments.length > _e.arguments.length && _e.arguments.length > 0;
  }
  function Pe2(O, me2) {
    if (me2 >= 2) return false;
    let _e = (Qe) => Pe2(Qe, me2 + 1), He = O.type === "Literal" && "regex" in O && O.regex.pattern || O.type === "RegExpLiteral" && O.pattern;
    if (He && l(He) > 5) return false;
    if (O.type === "Literal" || O.type === "BigIntLiteral" || O.type === "DecimalLiteral" || O.type === "BooleanLiteral" || O.type === "NullLiteral" || O.type === "NumericLiteral" || O.type === "RegExpLiteral" || O.type === "StringLiteral" || O.type === "Identifier" || O.type === "ThisExpression" || O.type === "Super" || O.type === "PrivateName" || O.type === "PrivateIdentifier" || O.type === "ArgumentPlaceholder" || O.type === "Import") return true;
    if (O.type === "TemplateLiteral") return O.quasis.every((Qe) => !Qe.value.raw.includes(`
`)) && O.expressions.every(_e);
    if (O.type === "ObjectExpression") return O.properties.every((Qe) => !Qe.computed && (Qe.shorthand || Qe.value && _e(Qe.value)));
    if (O.type === "ArrayExpression") return O.elements.every((Qe) => Qe === null || _e(Qe));
    if (tt2(O)) return (O.type === "ImportExpression" || Pe2(O.callee, me2)) && Ye(O).every(_e);
    if (ue(O)) return Pe2(O.object, me2) && Pe2(O.property, me2);
    let Ge = { "!": true, "-": true, "+": true, "~": true };
    if (O.type === "UnaryExpression" && Ge[O.operator]) return Pe2(O.argument, me2);
    let it = { "++": true, "--": true };
    return O.type === "UpdateExpression" && it[O.operator] ? Pe2(O.argument, me2) : O.type === "TSNonNullExpression" ? Pe2(O.expression, me2) : false;
  }
  function oe2(O) {
    var me2, _e;
    return (me2 = (_e = O.extra) === null || _e === void 0 ? void 0 : _e.raw) !== null && me2 !== void 0 ? me2 : O.raw;
  }
  function H(O) {
    return O;
  }
  function pe(O) {
    return O.filepath && /\.tsx$/i.test(O.filepath);
  }
  function X(O) {
    let me2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "es5";
    return O.trailingComma === "es5" && me2 === "es5" || O.trailingComma === "all" && (me2 === "all" || me2 === "es5");
  }
  function le2(O, me2) {
    switch (O.type) {
      case "BinaryExpression":
      case "LogicalExpression":
      case "AssignmentExpression":
      case "NGPipeExpression":
        return le2(O.left, me2);
      case "MemberExpression":
      case "OptionalMemberExpression":
        return le2(O.object, me2);
      case "TaggedTemplateExpression":
        return O.tag.type === "FunctionExpression" ? false : le2(O.tag, me2);
      case "CallExpression":
      case "OptionalCallExpression":
        return O.callee.type === "FunctionExpression" ? false : le2(O.callee, me2);
      case "ConditionalExpression":
        return le2(O.test, me2);
      case "UpdateExpression":
        return !O.prefix && le2(O.argument, me2);
      case "BindExpression":
        return O.object && le2(O.object, me2);
      case "SequenceExpression":
        return le2(O.expressions[0], me2);
      case "TSSatisfiesExpression":
      case "TSAsExpression":
      case "TSNonNullExpression":
        return le2(O.expression, me2);
      default:
        return me2(O);
    }
  }
  var Ae = { "==": true, "!=": true, "===": true, "!==": true }, Ee = { "*": true, "/": true, "%": true }, De = { ">>": true, ">>>": true, "<<": true };
  function A(O, me2) {
    return !(re(me2) !== re(O) || O === "**" || Ae[O] && Ae[me2] || me2 === "%" && Ee[O] || O === "%" && Ee[me2] || me2 !== O && Ee[me2] && Ee[O] || De[O] && De[me2]);
  }
  var G = new Map([["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].flatMap((O, me2) => O.map((_e) => [_e, me2])));
  function re(O) {
    return G.get(O);
  }
  function ye2(O) {
    return Boolean(De[O]) || O === "|" || O === "^" || O === "&";
  }
  function Ce(O) {
    var me2;
    if (O.rest) return true;
    let _e = ve(O);
    return ((me2 = s(_e)) === null || me2 === void 0 ? void 0 : me2.type) === "RestElement";
  }
  var Be = /* @__PURE__ */ new WeakMap();
  function ve(O) {
    if (Be.has(O)) return Be.get(O);
    let me2 = [];
    return O.this && me2.push(O.this), Array.isArray(O.parameters) ? me2.push(...O.parameters) : Array.isArray(O.params) && me2.push(...O.params), O.rest && me2.push(O.rest), Be.set(O, me2), me2;
  }
  function ze(O, me2) {
    let _e = O.getValue(), He = 0, Ge = (it) => me2(it, He++);
    _e.this && O.call(Ge, "this"), Array.isArray(_e.parameters) ? O.each(Ge, "parameters") : Array.isArray(_e.params) && O.each(Ge, "params"), _e.rest && O.call(Ge, "rest");
  }
  var xe2 = /* @__PURE__ */ new WeakMap();
  function Ye(O) {
    if (xe2.has(O)) return xe2.get(O);
    let me2 = O.arguments;
    return O.type === "ImportExpression" && (me2 = [O.source], O.attributes && me2.push(O.attributes)), xe2.set(O, me2), me2;
  }
  function Se(O, me2) {
    let _e = O.getValue();
    _e.type === "ImportExpression" ? (O.call((He) => me2(He, 0), "source"), _e.attributes && O.call((He) => me2(He, 1), "attributes")) : O.each(me2, "arguments");
  }
  function Ie(O) {
    return O.value.trim() === "prettier-ignore" && !O.unignore;
  }
  function Oe(O) {
    return O && (O.prettierIgnore || Me2(O, be2.PrettierIgnore));
  }
  function Je(O) {
    let me2 = O.getValue();
    return Oe(me2);
  }
  var be2 = { Leading: 1 << 1, Trailing: 1 << 2, Dangling: 1 << 3, Block: 1 << 4, Line: 1 << 5, PrettierIgnore: 1 << 6, First: 1 << 7, Last: 1 << 8 }, je = (O, me2) => {
    if (typeof O == "function" && (me2 = O, O = 0), O || me2) return (_e, He, Ge) => !(O & be2.Leading && !_e.leading || O & be2.Trailing && !_e.trailing || O & be2.Dangling && (_e.leading || _e.trailing) || O & be2.Block && !g(_e) || O & be2.Line && !D(_e) || O & be2.First && He !== 0 || O & be2.Last && He !== Ge.length - 1 || O & be2.PrettierIgnore && !Ie(_e) || me2 && !me2(_e));
  };
  function Me2(O, me2, _e) {
    if (!u(O == null ? void 0 : O.comments)) return false;
    let He = je(me2, _e);
    return He ? O.comments.some(He) : true;
  }
  function ae(O, me2, _e) {
    if (!Array.isArray(O == null ? void 0 : O.comments)) return [];
    let He = je(me2, _e);
    return He ? O.comments.filter(He) : O.comments;
  }
  var nt2 = (O, me2) => {
    let { originalText: _e } = me2;
    return i(_e, d(O));
  };
  function tt2(O) {
    return de(O) || O.type === "NewExpression" || O.type === "ImportExpression";
  }
  function Ve(O) {
    return O && (O.type === "ObjectProperty" || O.type === "Property" && !O.method && O.kind === "init");
  }
  function We(O) {
    return Boolean(O.__isUsingHackPipeline);
  }
  var Xe = Symbol("ifWithoutBlockAndSameLineComment");
  function st2(O) {
    return O.type === "TSAsExpression" || O.type === "TSSatisfiesExpression";
  }
  r.exports = { getFunctionParameters: ve, iterateFunctionParametersPath: ze, getCallArguments: Ye, iterateCallArgumentsPath: Se, hasRestParameter: Ce, getLeftSide: I, getLeftSidePathName: P, getParentExportDeclaration: m, getTypeScriptMappedTypeModifier: z, hasFlowAnnotationComment: F, hasFlowShorthandAnnotationComment: w, hasLeadingOwnLineComment: Z, hasNakedLeftSide: x, hasNode: N, hasIgnoreComment: Je, hasNodeIgnoreComment: Oe, identity: H, isBinaryish: V, isCallLikeExpression: tt2, isEnabledHackPipeline: We, isLineComment: D, isPrettierIgnoreComment: Ie, isCallExpression: de, isMemberExpression: ue, isExportDeclaration: T, isFlowAnnotationComment: U, isFunctionCompositionArgs: Re, isFunctionNotation: J2, isFunctionOrArrowExpression: b, isGetterOrSetter: q, isJestEachTemplateLiteral: ge, isJsxNode: M, isLiteral: C, isLongCurriedCallExpression: Ne, isSimpleCallArgument: Pe2, isMemberish: j, isNumericLiteral: o, isSignedNumericLiteral: h, isObjectProperty: Ve, isObjectType: S, isObjectTypePropertyAFunction: L, isSimpleType: ie, isSimpleNumber: fe, isSimpleTemplateLiteral: Fe, isStringLiteral: v, isStringPropSafeToUnquote: se, isTemplateOnItsOwnLine: we, isTestCall: K, isTheOnlyJsxElementInMarkdown: R, isTSXFile: pe, isTypeAnnotationAFunction: Q2, isNextLineEmpty: nt2, needsHardlineAfterDanglingComment: ke, rawText: oe2, shouldPrintComma: X, isBitwiseOperator: ye2, shouldFlatten: A, startsWithNoLookaheadToken: le2, getPrecedence: re, hasComment: Me2, getComments: ae, CommentCheckFlags: be2, markerForIfWithoutBlockAndSameLineComment: Xe, isTSTypeExpression: st2 };
} });
var Lt = te({ "src/language-js/print/template-literal.js"(e, r) {
  "use strict";
  ne();
  var t = lt(), { getStringWidth: s, getIndentSize: a } = Ue(), { builders: { join: n, hardline: u, softline: i, group: l, indent: p, align: d, lineSuffixBoundary: y, addAlignmentToDoc: g }, printer: { printDocToString: c }, utils: { mapDoc: f } } = qe(), { isBinaryish: E2, isJestEachTemplateLiteral: _, isSimpleTemplateLiteral: w, hasComment: F, isMemberExpression: N, isTSTypeExpression: x } = Ke();
  function I(C, o, h) {
    let v = C.getValue();
    if (v.type === "TemplateLiteral" && _(v, C.getParentNode())) {
      let R = P(C, h, o);
      if (R) return R;
    }
    let b = "expressions";
    v.type === "TSTemplateLiteralType" && (b = "types");
    let B = [], k = C.map(o, b), M = w(v);
    return M && (k = k.map((R) => c(R, Object.assign(Object.assign({}, h), {}, { printWidth: Number.POSITIVE_INFINITY })).formatted)), B.push(y, "`"), C.each((R) => {
      let q = R.getName();
      if (B.push(o()), q < k.length) {
        let { tabWidth: J2 } = h, L = R.getValue(), Q2 = a(L.value.raw, J2), V = k[q];
        if (!M) {
          let Y = v[b][q];
          (F(Y) || N(Y) || Y.type === "ConditionalExpression" || Y.type === "SequenceExpression" || x(Y) || E2(Y)) && (V = [p([i, V]), i]);
        }
        let j = Q2 === 0 && L.value.raw.endsWith(`
`) ? d(Number.NEGATIVE_INFINITY, V) : g(V, Q2, J2);
        B.push(l(["${", j, y, "}"]));
      }
    }, "quasis"), B.push("`"), B;
  }
  function P(C, o, h) {
    let v = C.getNode(), S = v.quasis[0].value.raw.trim().split(/\s*\|\s*/);
    if (S.length > 1 || S.some((b) => b.length > 0)) {
      o.__inJestEach = true;
      let b = C.map(h, "expressions");
      o.__inJestEach = false;
      let B = [], k = b.map((L) => "${" + c(L, Object.assign(Object.assign({}, o), {}, { printWidth: Number.POSITIVE_INFINITY, endOfLine: "lf" })).formatted + "}"), M = [{ hasLineBreak: false, cells: [] }];
      for (let L = 1; L < v.quasis.length; L++) {
        let Q2 = t(M), V = k[L - 1];
        Q2.cells.push(V), V.includes(`
`) && (Q2.hasLineBreak = true), v.quasis[L].value.raw.includes(`
`) && M.push({ hasLineBreak: false, cells: [] });
      }
      let R = Math.max(S.length, ...M.map((L) => L.cells.length)), q = Array.from({ length: R }).fill(0), J2 = [{ cells: S }, ...M.filter((L) => L.cells.length > 0)];
      for (let { cells: L } of J2.filter((Q2) => !Q2.hasLineBreak)) for (let [Q2, V] of L.entries()) q[Q2] = Math.max(q[Q2], s(V));
      return B.push(y, "`", p([u, n(u, J2.map((L) => n(" | ", L.cells.map((Q2, V) => L.hasLineBreak ? Q2 : Q2 + " ".repeat(q[V] - s(Q2))))))]), u, "`"), B;
    }
  }
  function $2(C, o) {
    let h = C.getValue(), v = o();
    return F(h) && (v = l([p([i, v]), i])), ["${", v, y, "}"];
  }
  function D(C, o) {
    return C.map((h) => $2(h, o), "expressions");
  }
  function T(C, o) {
    return f(C, (h) => typeof h == "string" ? o ? h.replace(/(\\*)`/g, "$1$1\\`") : m(h) : h);
  }
  function m(C) {
    return C.replace(/([\\`]|\${)/g, "\\$1");
  }
  r.exports = { printTemplateLiteral: I, printTemplateExpressions: D, escapeTemplateCharacters: T, uncookTemplateElementValue: m };
} });
var Vm = te({ "src/language-js/embed/markdown.js"(e, r) {
  "use strict";
  ne();
  var { builders: { indent: t, softline: s, literalline: a, dedentToRoot: n } } = qe(), { escapeTemplateCharacters: u } = Lt();
  function i(p, d, y) {
    let c = p.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, (w, F) => "\\".repeat(F.length / 2) + "`"), f = l(c), E2 = f !== "";
    E2 && (c = c.replace(new RegExp(`^${f}`, "gm"), ""));
    let _ = u(y(c, { parser: "markdown", __inJsTemplate: true }, { stripTrailingHardline: true }), true);
    return ["`", E2 ? t([s, _]) : [a, n(_)], s, "`"];
  }
  function l(p) {
    let d = p.match(/^([^\S\n]*)\S/m);
    return d === null ? "" : d[1];
  }
  r.exports = i;
} });
var Wm = te({ "src/language-js/embed/css.js"(e, r) {
  "use strict";
  ne();
  var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, hardline: a, softline: n }, utils: { mapDoc: u, replaceEndOfLine: i, cleanDoc: l } } = qe(), { printTemplateExpressions: p } = Lt();
  function d(c, f, E2) {
    let _ = c.getValue(), w = _.quasis.map((P) => P.value.raw), F = 0, N = w.reduce((P, $2, D) => D === 0 ? $2 : P + "@prettier-placeholder-" + F++ + "-id" + $2, ""), x = E2(N, { parser: "scss" }, { stripTrailingHardline: true }), I = p(c, f);
    return y(x, _, I);
  }
  function y(c, f, E2) {
    if (f.quasis.length === 1 && !f.quasis[0].value.raw.trim()) return "``";
    let w = g(c, E2);
    if (!w) throw new Error("Couldn't insert all the expressions");
    return ["`", s([a, w]), n, "`"];
  }
  function g(c, f) {
    if (!t(f)) return c;
    let E2 = 0, _ = u(l(c), (w) => typeof w != "string" || !w.includes("@prettier-placeholder") ? w : w.split(/@prettier-placeholder-(\d+)-id/).map((F, N) => N % 2 === 0 ? i(F) : (E2++, f[F])));
    return f.length === E2 ? _ : null;
  }
  r.exports = d;
} });
var Hm = te({ "src/language-js/embed/graphql.js"(e, r) {
  "use strict";
  ne();
  var { builders: { indent: t, join: s, hardline: a } } = qe(), { escapeTemplateCharacters: n, printTemplateExpressions: u } = Lt();
  function i(p, d, y) {
    let g = p.getValue(), c = g.quasis.length;
    if (c === 1 && g.quasis[0].value.raw.trim() === "") return "``";
    let f = u(p, d), E2 = [];
    for (let _ = 0; _ < c; _++) {
      let w = g.quasis[_], F = _ === 0, N = _ === c - 1, x = w.value.cooked, I = x.split(`
`), P = I.length, $2 = f[_], D = P > 2 && I[0].trim() === "" && I[1].trim() === "", T = P > 2 && I[P - 1].trim() === "" && I[P - 2].trim() === "", m = I.every((o) => /^\s*(?:#[^\n\r]*)?$/.test(o));
      if (!N && /#[^\n\r]*$/.test(I[P - 1])) return null;
      let C = null;
      m ? C = l(I) : C = y(x, { parser: "graphql" }, { stripTrailingHardline: true }), C ? (C = n(C, false), !F && D && E2.push(""), E2.push(C), !N && T && E2.push("")) : !F && !N && D && E2.push(""), $2 && E2.push($2);
    }
    return ["`", t([a, s(a, E2)]), a, "`"];
  }
  function l(p) {
    let d = [], y = false, g = p.map((c) => c.trim());
    for (let [c, f] of g.entries()) f !== "" && (g[c - 1] === "" && y ? d.push([a, f]) : d.push(f), y = true);
    return d.length === 0 ? null : s(a, d);
  }
  r.exports = i;
} });
var Gm = te({ "src/language-js/embed/html.js"(e, r) {
  "use strict";
  ne();
  var { builders: { indent: t, line: s, hardline: a, group: n }, utils: { mapDoc: u } } = qe(), { printTemplateExpressions: i, uncookTemplateElementValue: l } = Lt(), p = 0;
  function d(y, g, c, f, E2) {
    let { parser: _ } = E2, w = y.getValue(), F = p;
    p = p + 1 >>> 0;
    let N = (h) => `PRETTIER_HTML_PLACEHOLDER_${h}_${F}_IN_JS`, x = w.quasis.map((h, v, S) => v === S.length - 1 ? h.value.cooked : h.value.cooked + N(v)).join(""), I = i(y, g);
    if (I.length === 0 && x.trim().length === 0) return "``";
    let P = new RegExp(N("(\\d+)"), "g"), $2 = 0, D = c(x, { parser: _, __onHtmlRoot(h) {
      $2 = h.children.length;
    } }, { stripTrailingHardline: true }), T = u(D, (h) => {
      if (typeof h != "string") return h;
      let v = [], S = h.split(P);
      for (let b = 0; b < S.length; b++) {
        let B = S[b];
        if (b % 2 === 0) {
          B && (B = l(B), f.__embeddedInHtml && (B = B.replace(/<\/(script)\b/gi, "<\\/$1")), v.push(B));
          continue;
        }
        let k = Number(B);
        v.push(I[k]);
      }
      return v;
    }), m = /^\s/.test(x) ? " " : "", C = /\s$/.test(x) ? " " : "", o = f.htmlWhitespaceSensitivity === "ignore" ? a : m && C ? s : null;
    return n(o ? ["`", t([o, n(T)]), o, "`"] : ["`", m, $2 > 1 ? t(n(T)) : n(T), C, "`"]);
  }
  r.exports = d;
} });
var Um = te({ "src/language-js/embed.js"(e, r) {
  "use strict";
  ne();
  var { hasComment: t, CommentCheckFlags: s, isObjectProperty: a } = Ke(), n = Vm(), u = Wm(), i = Hm(), l = Gm();
  function p(D) {
    if (g(D) || _(D) || w(D) || c(D)) return "css";
    if (x(D)) return "graphql";
    if (P(D)) return "html";
    if (f(D)) return "angular";
    if (y(D)) return "markdown";
  }
  function d(D, T, m, C) {
    let o = D.getValue();
    if (o.type !== "TemplateLiteral" || $2(o)) return;
    let h = p(D);
    if (h) {
      if (h === "markdown") return n(D, T, m);
      if (h === "css") return u(D, T, m);
      if (h === "graphql") return i(D, T, m);
      if (h === "html" || h === "angular") return l(D, T, m, C, { parser: h });
    }
  }
  function y(D) {
    let T = D.getValue(), m = D.getParentNode();
    return m && m.type === "TaggedTemplateExpression" && T.quasis.length === 1 && m.tag.type === "Identifier" && (m.tag.name === "md" || m.tag.name === "markdown");
  }
  function g(D) {
    let T = D.getValue(), m = D.getParentNode(), C = D.getParentNode(1);
    return C && T.quasis && m.type === "JSXExpressionContainer" && C.type === "JSXElement" && C.openingElement.name.name === "style" && C.openingElement.attributes.some((o) => o.name.name === "jsx") || m && m.type === "TaggedTemplateExpression" && m.tag.type === "Identifier" && m.tag.name === "css" || m && m.type === "TaggedTemplateExpression" && m.tag.type === "MemberExpression" && m.tag.object.name === "css" && (m.tag.property.name === "global" || m.tag.property.name === "resolve");
  }
  function c(D) {
    return D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "ArrayExpression" && m === "elements", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "styles" && m === "value", ...E2);
  }
  function f(D) {
    return D.match((T) => T.type === "TemplateLiteral", (T, m) => a(T) && T.key.type === "Identifier" && T.key.name === "template" && m === "value", ...E2);
  }
  var E2 = [(D, T) => D.type === "ObjectExpression" && T === "properties", (D, T) => D.type === "CallExpression" && D.callee.type === "Identifier" && D.callee.name === "Component" && T === "arguments", (D, T) => D.type === "Decorator" && T === "expression"];
  function _(D) {
    let T = D.getParentNode();
    if (!T || T.type !== "TaggedTemplateExpression") return false;
    let m = T.tag.type === "ParenthesizedExpression" ? T.tag.expression : T.tag;
    switch (m.type) {
      case "MemberExpression":
        return F(m.object) || N(m);
      case "CallExpression":
        return F(m.callee) || m.callee.type === "MemberExpression" && (m.callee.object.type === "MemberExpression" && (F(m.callee.object.object) || N(m.callee.object)) || m.callee.object.type === "CallExpression" && F(m.callee.object.callee));
      case "Identifier":
        return m.name === "css";
      default:
        return false;
    }
  }
  function w(D) {
    let T = D.getParentNode(), m = D.getParentNode(1);
    return m && T.type === "JSXExpressionContainer" && m.type === "JSXAttribute" && m.name.type === "JSXIdentifier" && m.name.name === "css";
  }
  function F(D) {
    return D.type === "Identifier" && D.name === "styled";
  }
  function N(D) {
    return /^[A-Z]/.test(D.object.name) && D.property.name === "extend";
  }
  function x(D) {
    let T = D.getValue(), m = D.getParentNode();
    return I(T, "GraphQL") || m && (m.type === "TaggedTemplateExpression" && (m.tag.type === "MemberExpression" && m.tag.object.name === "graphql" && m.tag.property.name === "experimental" || m.tag.type === "Identifier" && (m.tag.name === "gql" || m.tag.name === "graphql")) || m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "graphql");
  }
  function I(D, T) {
    return t(D, s.Block | s.Leading, (m) => {
      let { value: C } = m;
      return C === ` ${T} `;
    });
  }
  function P(D) {
    return I(D.getValue(), "HTML") || D.match((T) => T.type === "TemplateLiteral", (T, m) => T.type === "TaggedTemplateExpression" && T.tag.type === "Identifier" && T.tag.name === "html" && m === "quasi");
  }
  function $2(D) {
    let { quasis: T } = D;
    return T.some((m) => {
      let { value: { cooked: C } } = m;
      return C === null;
    });
  }
  r.exports = d;
} });
var Jm = te({ "src/language-js/clean.js"(e, r) {
  "use strict";
  ne();
  var t = _t(), s = /* @__PURE__ */ new Set(["range", "raw", "comments", "leadingComments", "trailingComments", "innerComments", "extra", "start", "end", "loc", "flags", "errors", "tokens"]), a = (u) => {
    for (let i of u.quasis) delete i.value;
  };
  function n(u, i, l) {
    if (u.type === "Program" && delete i.sourceType, (u.type === "BigIntLiteral" || u.type === "BigIntLiteralTypeAnnotation") && i.value && (i.value = i.value.toLowerCase()), (u.type === "BigIntLiteral" || u.type === "Literal") && i.bigint && (i.bigint = i.bigint.toLowerCase()), u.type === "DecimalLiteral" && (i.value = Number(i.value)), u.type === "Literal" && i.decimal && (i.decimal = Number(i.decimal)), u.type === "EmptyStatement" || u.type === "JSXText" || u.type === "JSXExpressionContainer" && (u.expression.type === "Literal" || u.expression.type === "StringLiteral") && u.expression.value === " ") return null;
    if ((u.type === "Property" || u.type === "ObjectProperty" || u.type === "MethodDefinition" || u.type === "ClassProperty" || u.type === "ClassMethod" || u.type === "PropertyDefinition" || u.type === "TSDeclareMethod" || u.type === "TSPropertySignature" || u.type === "ObjectTypeProperty") && typeof u.key == "object" && u.key && (u.key.type === "Literal" || u.key.type === "NumericLiteral" || u.key.type === "StringLiteral" || u.key.type === "Identifier") && delete i.key, u.type === "JSXElement" && u.openingElement.name.name === "style" && u.openingElement.attributes.some((y) => y.name.name === "jsx")) for (let { type: y, expression: g } of i.children) y === "JSXExpressionContainer" && g.type === "TemplateLiteral" && a(g);
    u.type === "JSXAttribute" && u.name.name === "css" && u.value.type === "JSXExpressionContainer" && u.value.expression.type === "TemplateLiteral" && a(i.value.expression), u.type === "JSXAttribute" && u.value && u.value.type === "Literal" && /["']|&quot;|&apos;/.test(u.value.value) && (i.value.value = i.value.value.replace(/["']|&quot;|&apos;/g, '"'));
    let p = u.expression || u.callee;
    if (u.type === "Decorator" && p.type === "CallExpression" && p.callee.name === "Component" && p.arguments.length === 1) {
      let y = u.expression.arguments[0].properties;
      for (let [g, c] of i.expression.arguments[0].properties.entries()) switch (y[g].key.name) {
        case "styles":
          c.value.type === "ArrayExpression" && a(c.value.elements[0]);
          break;
        case "template":
          c.value.type === "TemplateLiteral" && a(c.value);
          break;
      }
    }
    if (u.type === "TaggedTemplateExpression" && (u.tag.type === "MemberExpression" || u.tag.type === "Identifier" && (u.tag.name === "gql" || u.tag.name === "graphql" || u.tag.name === "css" || u.tag.name === "md" || u.tag.name === "markdown" || u.tag.name === "html") || u.tag.type === "CallExpression") && a(i.quasi), u.type === "TemplateLiteral") {
      var d;
      (((d = u.leadingComments) === null || d === void 0 ? void 0 : d.some((g) => t(g) && ["GraphQL", "HTML"].some((c) => g.value === ` ${c} `))) || l.type === "CallExpression" && l.callee.name === "graphql" || !u.leadingComments) && a(i);
    }
    if (u.type === "InterpreterDirective" && (i.value = i.value.trimEnd()), (u.type === "TSIntersectionType" || u.type === "TSUnionType") && u.types.length === 1) return i.types[0];
  }
  n.ignoredProperties = s, r.exports = n;
} });
var Qa = {};
zt(Qa, { EOL: () => Rn, arch: () => zm, cpus: () => so, default: () => co, endianness: () => Za, freemem: () => no, getNetworkInterfaces: () => lo, hostname: () => eo, loadavg: () => to, networkInterfaces: () => oo, platform: () => Xm, release: () => ao, tmpDir: () => qn, tmpdir: () => Mn, totalmem: () => uo, type: () => io, uptime: () => ro });
function Za() {
  if (typeof xr > "u") {
    var e = new ArrayBuffer(2), r = new Uint8Array(e), t = new Uint16Array(e);
    if (r[0] = 1, r[1] = 2, t[0] === 258) xr = "BE";
    else if (t[0] === 513) xr = "LE";
    else throw new Error("unable to figure out endianess");
  }
  return xr;
}
function eo() {
  return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
}
function to() {
  return [];
}
function ro() {
  return 0;
}
function no() {
  return Number.MAX_VALUE;
}
function uo() {
  return Number.MAX_VALUE;
}
function so() {
  return [];
}
function io() {
  return "Browser";
}
function ao() {
  return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
}
function oo() {
}
function lo() {
}
function zm() {
  return "javascript";
}
function Xm() {
  return "browser";
}
function qn() {
  return "/tmp";
}
var xr;
var Mn;
var Rn;
var co;
var Km = ht({ "node-modules-polyfills:os"() {
  ne(), Mn = qn, Rn = `
`, co = { EOL: Rn, tmpdir: Mn, tmpDir: qn, networkInterfaces: oo, getNetworkInterfaces: lo, release: ao, type: io, cpus: so, totalmem: uo, freemem: no, uptime: ro, loadavg: to, hostname: eo, endianness: Za };
} });
var Ym = te({ "node-modules-polyfills-commonjs:os"(e, r) {
  ne();
  var t = (Km(), ft(Qa));
  if (t && t.default) {
    r.exports = t.default;
    for (let s in t) r.exports[s] = t[s];
  } else t && (r.exports = t);
} });
var Qm = te({ "node_modules/detect-newline/index.js"(e, r) {
  "use strict";
  ne();
  var t = (s) => {
    if (typeof s != "string") throw new TypeError("Expected a string");
    let a = s.match(/(?:\r?\n)/g) || [];
    if (a.length === 0) return;
    let n = a.filter((i) => i === `\r
`).length, u = a.length - n;
    return n > u ? `\r
` : `
`;
  };
  r.exports = t, r.exports.graceful = (s) => typeof s == "string" && t(s) || `
`;
} });
var Zm = te({ "node_modules/jest-docblock/build/index.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.extract = c, e.parse = E2, e.parseWithComments = _, e.print = w, e.strip = f;
  function r() {
    let N = Ym();
    return r = function() {
      return N;
    }, N;
  }
  function t() {
    let N = s(Qm());
    return t = function() {
      return N;
    }, N;
  }
  function s(N) {
    return N && N.__esModule ? N : { default: N };
  }
  var a = /\*\/$/, n = /^\/\*\*?/, u = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, i = /(^|\s+)\/\/([^\r\n]*)/g, l = /^(\r?\n)+/, p = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, d = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, y = /(\r?\n|^) *\* ?/g, g = [];
  function c(N) {
    let x = N.match(u);
    return x ? x[0].trimLeft() : "";
  }
  function f(N) {
    let x = N.match(u);
    return x && x[0] ? N.substring(x[0].length) : N;
  }
  function E2(N) {
    return _(N).pragmas;
  }
  function _(N) {
    let x = (0, t().default)(N) || r().EOL;
    N = N.replace(n, "").replace(a, "").replace(y, "$1");
    let I = "";
    for (; I !== N; ) I = N, N = N.replace(p, `${x}$1 $2${x}`);
    N = N.replace(l, "").trimRight();
    let P = /* @__PURE__ */ Object.create(null), $2 = N.replace(d, "").replace(l, "").trimRight(), D;
    for (; D = d.exec(N); ) {
      let T = D[2].replace(i, "");
      typeof P[D[1]] == "string" || Array.isArray(P[D[1]]) ? P[D[1]] = g.concat(P[D[1]], T) : P[D[1]] = T;
    }
    return { comments: $2, pragmas: P };
  }
  function w(N) {
    let { comments: x = "", pragmas: I = {} } = N, P = (0, t().default)(x) || r().EOL, $2 = "/**", D = " *", T = " */", m = Object.keys(I), C = m.map((h) => F(h, I[h])).reduce((h, v) => h.concat(v), []).map((h) => `${D} ${h}${P}`).join("");
    if (!x) {
      if (m.length === 0) return "";
      if (m.length === 1 && !Array.isArray(I[m[0]])) {
        let h = I[m[0]];
        return `${$2} ${F(m[0], h)[0]}${T}`;
      }
    }
    let o = x.split(P).map((h) => `${D} ${h}`).join(P) + P;
    return $2 + P + (x ? o : "") + (x && m.length ? D + P : "") + C + T;
  }
  function F(N, x) {
    return g.concat(x).map((I) => `@${N} ${I}`.trim());
  }
} });
var ed = te({ "src/language-js/utils/get-shebang.js"(e, r) {
  "use strict";
  ne();
  function t(s) {
    if (!s.startsWith("#!")) return "";
    let a = s.indexOf(`
`);
    return a === -1 ? s : s.slice(0, a);
  }
  r.exports = t;
} });
var po = te({ "src/language-js/pragma.js"(e, r) {
  "use strict";
  ne();
  var { parseWithComments: t, strip: s, extract: a, print: n } = Zm(), { normalizeEndOfLine: u } = Hn(), i = ed();
  function l(y) {
    let g = i(y);
    g && (y = y.slice(g.length + 1));
    let c = a(y), { pragmas: f, comments: E2 } = t(c);
    return { shebang: g, text: y, pragmas: f, comments: E2 };
  }
  function p(y) {
    let g = Object.keys(l(y).pragmas);
    return g.includes("prettier") || g.includes("format");
  }
  function d(y) {
    let { shebang: g, text: c, pragmas: f, comments: E2 } = l(y), _ = s(c), w = n({ pragmas: Object.assign({ format: "" }, f), comments: E2.trimStart() });
    return (g ? `${g}
` : "") + u(w) + (_.startsWith(`
`) ? `
` : `

`) + _;
  }
  r.exports = { hasPragma: p, insertPragma: d };
} });
var td = te({ "src/language-js/utils/is-type-cast-comment.js"(e, r) {
  "use strict";
  ne();
  var t = _t();
  function s(a) {
    return t(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/.test(a.value);
  }
  r.exports = s;
} });
var fo = te({ "src/language-js/comments.js"(e, r) {
  "use strict";
  ne();
  var { getLast: t, hasNewline: s, getNextNonSpaceNonCommentCharacterIndexWithStartIndex: a, getNextNonSpaceNonCommentCharacter: n, hasNewlineInRange: u, addLeadingComment: i, addTrailingComment: l, addDanglingComment: p, getNextNonSpaceNonCommentCharacterIndex: d, isNonEmptyArray: y } = Ue(), { getFunctionParameters: g, isPrettierIgnoreComment: c, isJsxNode: f, hasFlowShorthandAnnotationComment: E2, hasFlowAnnotationComment: _, hasIgnoreComment: w, isCallLikeExpression: F, getCallArguments: N, isCallExpression: x, isMemberExpression: I, isObjectProperty: P, isLineComment: $2, getComments: D, CommentCheckFlags: T, markerForIfWithoutBlockAndSameLineComment: m } = Ke(), { locStart: C, locEnd: o } = ut(), h = _t(), v = td();
  function S(De) {
    return [H, Fe, Q2, q, J2, L, ie, he, se, ge, we, ke, ce, z, U].some((A) => A(De));
  }
  function b(De) {
    return [R, Fe, V, we, q, J2, L, ie, z, Z, fe, ge, Pe2, U, X].some((A) => A(De));
  }
  function B(De) {
    return [H, q, J2, j, ue, ce, ge, de, K, pe, U, oe2].some((A) => A(De));
  }
  function k(De, A) {
    let G = (De.body || De.properties).find((re) => {
      let { type: ye2 } = re;
      return ye2 !== "EmptyStatement";
    });
    G ? i(G, A) : p(De, A);
  }
  function M(De, A) {
    De.type === "BlockStatement" ? k(De, A) : i(De, A);
  }
  function R(De) {
    let { comment: A, followingNode: G } = De;
    return G && v(A) ? (i(G, A), true) : false;
  }
  function q(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce } = De;
    if ((re == null ? void 0 : re.type) !== "IfStatement" || !ye2) return false;
    if (n(Ce, A, o) === ")") return l(G, A), true;
    if (G === re.consequent && ye2 === re.alternate) {
      if (G.type === "BlockStatement") l(G, A);
      else {
        let ve = A.type === "SingleLine" || A.loc.start.line === A.loc.end.line, ze = A.loc.start.line === G.loc.start.line;
        ve && ze ? p(G, A, m) : p(re, A);
      }
      return true;
    }
    return ye2.type === "BlockStatement" ? (k(ye2, A), true) : ye2.type === "IfStatement" ? (M(ye2.consequent, A), true) : re.consequent === ye2 ? (i(ye2, A), true) : false;
  }
  function J2(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce } = De;
    return (re == null ? void 0 : re.type) !== "WhileStatement" || !ye2 ? false : n(Ce, A, o) === ")" ? (l(G, A), true) : ye2.type === "BlockStatement" ? (k(ye2, A), true) : re.body === ye2 ? (i(ye2, A), true) : false;
  }
  function L(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De;
    return (re == null ? void 0 : re.type) !== "TryStatement" && (re == null ? void 0 : re.type) !== "CatchClause" || !ye2 ? false : re.type === "CatchClause" && G ? (l(G, A), true) : ye2.type === "BlockStatement" ? (k(ye2, A), true) : ye2.type === "TryStatement" ? (M(ye2.finalizer, A), true) : ye2.type === "CatchClause" ? (M(ye2.body, A), true) : false;
  }
  function Q2(De) {
    let { comment: A, enclosingNode: G, followingNode: re } = De;
    return I(G) && (re == null ? void 0 : re.type) === "Identifier" ? (i(G, A), true) : false;
  }
  function V(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce } = De, Be = G && !u(Ce, o(G), C(A));
    return (!G || !Be) && ((re == null ? void 0 : re.type) === "ConditionalExpression" || (re == null ? void 0 : re.type) === "TSConditionalType") && ye2 ? (i(ye2, A), true) : false;
  }
  function j(De) {
    let { comment: A, precedingNode: G, enclosingNode: re } = De;
    return P(re) && re.shorthand && re.key === G && re.value.type === "AssignmentPattern" ? (l(re.value.left, A), true) : false;
  }
  var Y = /* @__PURE__ */ new Set(["ClassDeclaration", "ClassExpression", "DeclareClass", "DeclareInterface", "InterfaceDeclaration", "TSInterfaceDeclaration"]);
  function ie(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De;
    if (Y.has(re == null ? void 0 : re.type)) {
      if (y(re.decorators) && !(ye2 && ye2.type === "Decorator")) return l(t(re.decorators), A), true;
      if (re.body && ye2 === re.body) return k(re.body, A), true;
      if (ye2) {
        if (re.superClass && ye2 === re.superClass && G && (G === re.id || G === re.typeParameters)) return l(G, A), true;
        for (let Ce of ["implements", "extends", "mixins"]) if (re[Ce] && ye2 === re[Ce][0]) return G && (G === re.id || G === re.typeParameters || G === re.superClass) ? l(G, A) : p(re, A, Ce), true;
      }
    }
    return false;
  }
  var ee = /* @__PURE__ */ new Set(["ClassMethod", "ClassProperty", "PropertyDefinition", "TSAbstractPropertyDefinition", "TSAbstractMethodDefinition", "TSDeclareMethod", "MethodDefinition", "ClassAccessorProperty", "AccessorProperty", "TSAbstractAccessorProperty"]);
  function ce(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, text: ye2 } = De;
    return re && G && n(ye2, A, o) === "(" && (re.type === "Property" || re.type === "TSDeclareMethod" || re.type === "TSAbstractMethodDefinition") && G.type === "Identifier" && re.key === G && n(ye2, G, o) !== ":" || (G == null ? void 0 : G.type) === "Decorator" && ee.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
  }
  var W = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ClassMethod", "MethodDefinition", "ObjectMethod"]);
  function K(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, text: ye2 } = De;
    return n(ye2, A, o) !== "(" ? false : G && W.has(re == null ? void 0 : re.type) ? (l(G, A), true) : false;
  }
  function de(De) {
    let { comment: A, enclosingNode: G, text: re } = De;
    if ((G == null ? void 0 : G.type) !== "ArrowFunctionExpression") return false;
    let ye2 = d(re, A, o);
    return ye2 !== false && re.slice(ye2, ye2 + 2) === "=>" ? (p(G, A), true) : false;
  }
  function ue(De) {
    let { comment: A, enclosingNode: G, text: re } = De;
    return n(re, A, o) !== ")" ? false : G && (le2(G) && g(G).length === 0 || F(G) && N(G).length === 0) ? (p(G, A), true) : ((G == null ? void 0 : G.type) === "MethodDefinition" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && g(G.value).length === 0 ? (p(G.value, A), true) : false;
  }
  function Fe(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2, text: Ce } = De;
    if ((G == null ? void 0 : G.type) === "FunctionTypeParam" && (re == null ? void 0 : re.type) === "FunctionTypeAnnotation" && (ye2 == null ? void 0 : ye2.type) !== "FunctionTypeParam" || ((G == null ? void 0 : G.type) === "Identifier" || (G == null ? void 0 : G.type) === "AssignmentPattern") && re && le2(re) && n(Ce, A, o) === ")") return l(G, A), true;
    if ((re == null ? void 0 : re.type) === "FunctionDeclaration" && (ye2 == null ? void 0 : ye2.type) === "BlockStatement") {
      let Be = (() => {
        let ve = g(re);
        if (ve.length > 0) return a(Ce, o(t(ve)));
        let ze = a(Ce, o(re.id));
        return ze !== false && a(Ce, ze + 1);
      })();
      if (C(A) > Be) return k(ye2, A), true;
    }
    return false;
  }
  function z(De) {
    let { comment: A, enclosingNode: G } = De;
    return (G == null ? void 0 : G.type) === "LabeledStatement" ? (i(G, A), true) : false;
  }
  function U(De) {
    let { comment: A, enclosingNode: G } = De;
    return ((G == null ? void 0 : G.type) === "ContinueStatement" || (G == null ? void 0 : G.type) === "BreakStatement") && !G.label ? (l(G, A), true) : false;
  }
  function Z(De) {
    let { comment: A, precedingNode: G, enclosingNode: re } = De;
    return x(re) && G && re.callee === G && re.arguments.length > 0 ? (i(re.arguments[0], A), true) : false;
  }
  function se(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De;
    return (re == null ? void 0 : re.type) === "UnionTypeAnnotation" || (re == null ? void 0 : re.type) === "TSUnionType" ? (c(A) && (ye2.prettierIgnore = true, A.unignore = true), G ? (l(G, A), true) : false) : (((ye2 == null ? void 0 : ye2.type) === "UnionTypeAnnotation" || (ye2 == null ? void 0 : ye2.type) === "TSUnionType") && c(A) && (ye2.types[0].prettierIgnore = true, A.unignore = true), false);
  }
  function fe(De) {
    let { comment: A, enclosingNode: G } = De;
    return P(G) ? (i(G, A), true) : false;
  }
  function ge(De) {
    let { comment: A, enclosingNode: G, followingNode: re, ast: ye2, isLastComment: Ce } = De;
    return ye2 && ye2.body && ye2.body.length === 0 ? (Ce ? p(ye2, A) : i(ye2, A), true) : (G == null ? void 0 : G.type) === "Program" && (G == null ? void 0 : G.body.length) === 0 && !y(G.directives) ? (Ce ? p(G, A) : i(G, A), true) : (re == null ? void 0 : re.type) === "Program" && (re == null ? void 0 : re.body.length) === 0 && (G == null ? void 0 : G.type) === "ModuleExpression" ? (p(re, A), true) : false;
  }
  function he(De) {
    let { comment: A, enclosingNode: G } = De;
    return (G == null ? void 0 : G.type) === "ForInStatement" || (G == null ? void 0 : G.type) === "ForOfStatement" ? (i(G, A), true) : false;
  }
  function we(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, text: ye2 } = De;
    if ((re == null ? void 0 : re.type) === "ImportSpecifier" || (re == null ? void 0 : re.type) === "ExportSpecifier") return i(re, A), true;
    let Ce = (G == null ? void 0 : G.type) === "ImportSpecifier" && (re == null ? void 0 : re.type) === "ImportDeclaration", Be = (G == null ? void 0 : G.type) === "ExportSpecifier" && (re == null ? void 0 : re.type) === "ExportNamedDeclaration";
    return (Ce || Be) && s(ye2, o(A)) ? (l(G, A), true) : false;
  }
  function ke(De) {
    let { comment: A, enclosingNode: G } = De;
    return (G == null ? void 0 : G.type) === "AssignmentPattern" ? (i(G, A), true) : false;
  }
  var Re = /* @__PURE__ */ new Set(["VariableDeclarator", "AssignmentExpression", "TypeAlias", "TSTypeAliasDeclaration"]), Ne = /* @__PURE__ */ new Set(["ObjectExpression", "ArrayExpression", "TemplateLiteral", "TaggedTemplateExpression", "ObjectTypeAnnotation", "TSTypeLiteral"]);
  function Pe2(De) {
    let { comment: A, enclosingNode: G, followingNode: re } = De;
    return Re.has(G == null ? void 0 : G.type) && re && (Ne.has(re.type) || h(A)) ? (i(re, A), true) : false;
  }
  function oe2(De) {
    let { comment: A, enclosingNode: G, followingNode: re, text: ye2 } = De;
    return !re && ((G == null ? void 0 : G.type) === "TSMethodSignature" || (G == null ? void 0 : G.type) === "TSDeclareFunction" || (G == null ? void 0 : G.type) === "TSAbstractMethodDefinition") && n(ye2, A, o) === ";" ? (l(G, A), true) : false;
  }
  function H(De) {
    let { comment: A, enclosingNode: G, followingNode: re } = De;
    if (c(A) && (G == null ? void 0 : G.type) === "TSMappedType" && (re == null ? void 0 : re.type) === "TSTypeParameter" && re.constraint) return G.prettierIgnore = true, A.unignore = true, true;
  }
  function pe(De) {
    let { comment: A, precedingNode: G, enclosingNode: re, followingNode: ye2 } = De;
    return (re == null ? void 0 : re.type) !== "TSMappedType" ? false : (ye2 == null ? void 0 : ye2.type) === "TSTypeParameter" && ye2.name ? (i(ye2.name, A), true) : (G == null ? void 0 : G.type) === "TSTypeParameter" && G.constraint ? (l(G.constraint, A), true) : false;
  }
  function X(De) {
    let { comment: A, enclosingNode: G, followingNode: re } = De;
    return !G || G.type !== "SwitchCase" || G.test || !re || re !== G.consequent[0] ? false : (re.type === "BlockStatement" && $2(A) ? k(re, A) : p(G, A), true);
  }
  function le2(De) {
    return De.type === "ArrowFunctionExpression" || De.type === "FunctionExpression" || De.type === "FunctionDeclaration" || De.type === "ObjectMethod" || De.type === "ClassMethod" || De.type === "TSDeclareFunction" || De.type === "TSCallSignatureDeclaration" || De.type === "TSConstructSignatureDeclaration" || De.type === "TSMethodSignature" || De.type === "TSConstructorType" || De.type === "TSFunctionType" || De.type === "TSDeclareMethod";
  }
  function Ae(De, A) {
    if ((A.parser === "typescript" || A.parser === "flow" || A.parser === "acorn" || A.parser === "espree" || A.parser === "meriyah" || A.parser === "__babel_estree") && De.type === "MethodDefinition" && De.value && De.value.type === "FunctionExpression" && g(De.value).length === 0 && !De.value.returnType && !y(De.value.typeParameters) && De.value.body) return [...De.decorators || [], De.key, De.value.body];
  }
  function Ee(De) {
    let A = De.getValue(), G = De.getParentNode(), re = (ye2) => _(D(ye2, T.Leading)) || _(D(ye2, T.Trailing));
    return (A && (f(A) || E2(A) || x(G) && re(A)) || G && (G.type === "JSXSpreadAttribute" || G.type === "JSXSpreadChild" || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType" || (G.type === "ClassDeclaration" || G.type === "ClassExpression") && G.superClass === A)) && (!w(De) || G.type === "UnionTypeAnnotation" || G.type === "TSUnionType");
  }
  r.exports = { handleOwnLineComment: S, handleEndOfLineComment: b, handleRemainingComment: B, getCommentChildNodes: Ae, willPrintOwnComments: Ee };
} });
var Ot = te({ "src/language-js/needs-parens.js"(e, r) {
  "use strict";
  ne();
  var t = lt(), s = Jn(), { getFunctionParameters: a, getLeftSidePathName: n, hasFlowShorthandAnnotationComment: u, hasNakedLeftSide: i, hasNode: l, isBitwiseOperator: p, startsWithNoLookaheadToken: d, shouldFlatten: y, getPrecedence: g, isCallExpression: c, isMemberExpression: f, isObjectProperty: E2, isTSTypeExpression: _ } = Ke();
  function w(D, T) {
    let m = D.getParentNode();
    if (!m) return false;
    let C = D.getName(), o = D.getNode();
    if (T.__isInHtmlInterpolation && !T.bracketSpacing && I(o) && P(D)) return true;
    if (F(o)) return false;
    if (T.parser !== "flow" && u(D.getValue())) return true;
    if (o.type === "Identifier") {
      if (o.extra && o.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name) || C === "left" && (o.name === "async" && !m.await || o.name === "let") && m.type === "ForOfStatement") return true;
      if (o.name === "let") {
        var h;
        let S = (h = D.findAncestor((b) => b.type === "ForOfStatement")) === null || h === void 0 ? void 0 : h.left;
        if (S && d(S, (b) => b === o)) return true;
      }
      if (C === "object" && o.name === "let" && m.type === "MemberExpression" && m.computed && !m.optional) {
        let S = D.findAncestor((B) => B.type === "ExpressionStatement" || B.type === "ForStatement" || B.type === "ForInStatement"), b = S ? S.type === "ExpressionStatement" ? S.expression : S.type === "ForStatement" ? S.init : S.left : void 0;
        if (b && d(b, (B) => B === o)) return true;
      }
      return false;
    }
    if (o.type === "ObjectExpression" || o.type === "FunctionExpression" || o.type === "ClassExpression" || o.type === "DoExpression") {
      var v;
      let S = (v = D.findAncestor((b) => b.type === "ExpressionStatement")) === null || v === void 0 ? void 0 : v.expression;
      if (S && d(S, (b) => b === o)) return true;
    }
    switch (m.type) {
      case "ParenthesizedExpression":
        return false;
      case "ClassDeclaration":
      case "ClassExpression": {
        if (C === "superClass" && (o.type === "ArrowFunctionExpression" || o.type === "AssignmentExpression" || o.type === "AwaitExpression" || o.type === "BinaryExpression" || o.type === "ConditionalExpression" || o.type === "LogicalExpression" || o.type === "NewExpression" || o.type === "ObjectExpression" || o.type === "SequenceExpression" || o.type === "TaggedTemplateExpression" || o.type === "UnaryExpression" || o.type === "UpdateExpression" || o.type === "YieldExpression" || o.type === "TSNonNullExpression")) return true;
        break;
      }
      case "ExportDefaultDeclaration":
        return $2(D, T) || o.type === "SequenceExpression";
      case "Decorator": {
        if (C === "expression") {
          if (f(o) && o.computed) return true;
          let S = false, b = false, B = o;
          for (; B; ) switch (B.type) {
            case "MemberExpression":
              b = true, B = B.object;
              break;
            case "CallExpression":
              if (b || S) return T.parser !== "typescript";
              S = true, B = B.callee;
              break;
            case "Identifier":
              return false;
            case "TaggedTemplateExpression":
              return T.parser !== "typescript";
            default:
              return true;
          }
          return true;
        }
        break;
      }
      case "ArrowFunctionExpression": {
        if (C === "body" && o.type !== "SequenceExpression" && d(o, (S) => S.type === "ObjectExpression")) return true;
        break;
      }
    }
    switch (o.type) {
      case "UpdateExpression":
        if (m.type === "UnaryExpression") return o.prefix && (o.operator === "++" && m.operator === "+" || o.operator === "--" && m.operator === "-");
      case "UnaryExpression":
        switch (m.type) {
          case "UnaryExpression":
            return o.operator === m.operator && (o.operator === "+" || o.operator === "-");
          case "BindExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return C === "object";
          case "TaggedTemplateExpression":
            return true;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "BinaryExpression":
            return C === "left" && m.operator === "**";
          case "TSNonNullExpression":
            return true;
          default:
            return false;
        }
      case "BinaryExpression": {
        if (m.type === "UpdateExpression" || o.operator === "in" && N(D)) return true;
        if (o.operator === "|>" && o.extra && o.extra.parenthesized) {
          let S = D.getParentNode(1);
          if (S.type === "BinaryExpression" && S.operator === "|>") return true;
        }
      }
      case "TSTypeAssertion":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "LogicalExpression":
        switch (m.type) {
          case "TSSatisfiesExpression":
          case "TSAsExpression":
            return !_(o);
          case "ConditionalExpression":
            return _(o);
          case "CallExpression":
          case "NewExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "ClassExpression":
          case "ClassDeclaration":
            return C === "superClass";
          case "TSTypeAssertion":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "JSXSpreadAttribute":
          case "SpreadElement":
          case "SpreadProperty":
          case "BindExpression":
          case "AwaitExpression":
          case "TSNonNullExpression":
          case "UpdateExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return C === "object";
          case "AssignmentExpression":
          case "AssignmentPattern":
            return C === "left" && (o.type === "TSTypeAssertion" || _(o));
          case "LogicalExpression":
            if (o.type === "LogicalExpression") return m.operator !== o.operator;
          case "BinaryExpression": {
            let { operator: S, type: b } = o;
            if (!S && b !== "TSTypeAssertion") return true;
            let B = g(S), k = m.operator, M = g(k);
            return M > B || C === "right" && M === B || M === B && !y(k, S) ? true : M < B && S === "%" ? k === "+" || k === "-" : !!p(k);
          }
          default:
            return false;
        }
      case "SequenceExpression":
        switch (m.type) {
          case "ReturnStatement":
            return false;
          case "ForStatement":
            return false;
          case "ExpressionStatement":
            return C !== "expression";
          case "ArrowFunctionExpression":
            return C !== "body";
          default:
            return true;
        }
      case "YieldExpression":
        if (m.type === "UnaryExpression" || m.type === "AwaitExpression" || _(m) || m.type === "TSNonNullExpression") return true;
      case "AwaitExpression":
        switch (m.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "BindExpression":
            return true;
          case "MemberExpression":
          case "OptionalMemberExpression":
            return C === "object";
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "ConditionalExpression":
            return C === "test";
          case "BinaryExpression":
            return !(!o.argument && m.operator === "|>");
          default:
            return false;
        }
      case "TSConditionalType":
      case "TSFunctionType":
      case "TSConstructorType":
        if (C === "extendsType" && m.type === "TSConditionalType") {
          if (o.type === "TSConditionalType") return true;
          let { typeAnnotation: S } = o.returnType || o.typeAnnotation;
          if (S.type === "TSTypePredicate" && S.typeAnnotation && (S = S.typeAnnotation.typeAnnotation), S.type === "TSInferType" && S.typeParameter.constraint) return true;
        }
        if (C === "checkType" && m.type === "TSConditionalType") return true;
      case "TSUnionType":
      case "TSIntersectionType":
        if ((m.type === "TSUnionType" || m.type === "TSIntersectionType") && m.types.length > 1 && (!o.types || o.types.length > 1)) return true;
      case "TSInferType":
        if (o.type === "TSInferType" && m.type === "TSRestType") return false;
      case "TSTypeOperator":
        return m.type === "TSArrayType" || m.type === "TSOptionalType" || m.type === "TSRestType" || C === "objectType" && m.type === "TSIndexedAccessType" || m.type === "TSTypeOperator" || m.type === "TSTypeAnnotation" && D.getParentNode(1).type.startsWith("TSJSDoc");
      case "TSTypeQuery":
        return C === "objectType" && m.type === "TSIndexedAccessType" || C === "elementType" && m.type === "TSArrayType";
      case "TypeofTypeAnnotation":
        return C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType") || C === "elementType" && m.type === "ArrayTypeAnnotation";
      case "ArrayTypeAnnotation":
        return m.type === "NullableTypeAnnotation";
      case "IntersectionTypeAnnotation":
      case "UnionTypeAnnotation":
        return m.type === "ArrayTypeAnnotation" || m.type === "NullableTypeAnnotation" || m.type === "IntersectionTypeAnnotation" || m.type === "UnionTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
      case "NullableTypeAnnotation":
        return m.type === "ArrayTypeAnnotation" || C === "objectType" && (m.type === "IndexedAccessType" || m.type === "OptionalIndexedAccessType");
      case "FunctionTypeAnnotation": {
        let S = m.type === "NullableTypeAnnotation" ? D.getParentNode(1) : m;
        return S.type === "UnionTypeAnnotation" || S.type === "IntersectionTypeAnnotation" || S.type === "ArrayTypeAnnotation" || C === "objectType" && (S.type === "IndexedAccessType" || S.type === "OptionalIndexedAccessType") || S.type === "NullableTypeAnnotation" || m.type === "FunctionTypeParam" && m.name === null && a(o).some((b) => b.typeAnnotation && b.typeAnnotation.type === "NullableTypeAnnotation");
      }
      case "OptionalIndexedAccessType":
        return C === "objectType" && m.type === "IndexedAccessType";
      case "StringLiteral":
      case "NumericLiteral":
      case "Literal":
        if (typeof o.value == "string" && m.type === "ExpressionStatement" && !m.directive) {
          let S = D.getParentNode(1);
          return S.type === "Program" || S.type === "BlockStatement";
        }
        return C === "object" && m.type === "MemberExpression" && typeof o.value == "number";
      case "AssignmentExpression": {
        let S = D.getParentNode(1);
        return C === "body" && m.type === "ArrowFunctionExpression" ? true : C === "key" && (m.type === "ClassProperty" || m.type === "PropertyDefinition") && m.computed || (C === "init" || C === "update") && m.type === "ForStatement" ? false : m.type === "ExpressionStatement" ? o.left.type === "ObjectPattern" : !(C === "key" && m.type === "TSPropertySignature" || m.type === "AssignmentExpression" || m.type === "SequenceExpression" && S && S.type === "ForStatement" && (S.init === m || S.update === m) || C === "value" && m.type === "Property" && S && S.type === "ObjectPattern" && S.properties.includes(m) || m.type === "NGChainedExpression");
      }
      case "ConditionalExpression":
        switch (m.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "BinaryExpression":
          case "LogicalExpression":
          case "NGPipeExpression":
          case "ExportDefaultDeclaration":
          case "AwaitExpression":
          case "JSXSpreadAttribute":
          case "TSTypeAssertion":
          case "TypeCastExpression":
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
            return true;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "ConditionalExpression":
            return C === "test";
          case "MemberExpression":
          case "OptionalMemberExpression":
            return C === "object";
          default:
            return false;
        }
      case "FunctionExpression":
        switch (m.type) {
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "TaggedTemplateExpression":
            return true;
          default:
            return false;
        }
      case "ArrowFunctionExpression":
        switch (m.type) {
          case "BinaryExpression":
            return m.operator !== "|>" || o.extra && o.extra.parenthesized;
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return C === "callee";
          case "MemberExpression":
          case "OptionalMemberExpression":
            return C === "object";
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "BindExpression":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "AwaitExpression":
          case "TSTypeAssertion":
            return true;
          case "ConditionalExpression":
            return C === "test";
          default:
            return false;
        }
      case "ClassExpression":
        if (s(o.decorators)) return true;
        switch (m.type) {
          case "NewExpression":
            return C === "callee";
          default:
            return false;
        }
      case "OptionalMemberExpression":
      case "OptionalCallExpression": {
        let S = D.getParentNode(1);
        if (C === "object" && m.type === "MemberExpression" || C === "callee" && (m.type === "CallExpression" || m.type === "NewExpression") || m.type === "TSNonNullExpression" && S.type === "MemberExpression" && S.object === m) return true;
      }
      case "CallExpression":
      case "MemberExpression":
      case "TaggedTemplateExpression":
      case "TSNonNullExpression":
        if (C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression")) {
          let S = o;
          for (; S; ) switch (S.type) {
            case "CallExpression":
            case "OptionalCallExpression":
              return true;
            case "MemberExpression":
            case "OptionalMemberExpression":
            case "BindExpression":
              S = S.object;
              break;
            case "TaggedTemplateExpression":
              S = S.tag;
              break;
            case "TSNonNullExpression":
              S = S.expression;
              break;
            default:
              return false;
          }
        }
        return false;
      case "BindExpression":
        return C === "callee" && (m.type === "BindExpression" || m.type === "NewExpression") || C === "object" && f(m);
      case "NGPipeExpression":
        return !(m.type === "NGRoot" || m.type === "NGMicrosyntaxExpression" || m.type === "ObjectProperty" && !(o.extra && o.extra.parenthesized) || m.type === "ArrayExpression" || c(m) && m.arguments[C] === o || C === "right" && m.type === "NGPipeExpression" || C === "property" && m.type === "MemberExpression" || m.type === "AssignmentExpression");
      case "JSXFragment":
      case "JSXElement":
        return C === "callee" || C === "left" && m.type === "BinaryExpression" && m.operator === "<" || m.type !== "ArrayExpression" && m.type !== "ArrowFunctionExpression" && m.type !== "AssignmentExpression" && m.type !== "AssignmentPattern" && m.type !== "BinaryExpression" && m.type !== "NewExpression" && m.type !== "ConditionalExpression" && m.type !== "ExpressionStatement" && m.type !== "JsExpressionRoot" && m.type !== "JSXAttribute" && m.type !== "JSXElement" && m.type !== "JSXExpressionContainer" && m.type !== "JSXFragment" && m.type !== "LogicalExpression" && !c(m) && !E2(m) && m.type !== "ReturnStatement" && m.type !== "ThrowStatement" && m.type !== "TypeCastExpression" && m.type !== "VariableDeclarator" && m.type !== "YieldExpression";
      case "TypeAnnotation":
        return C === "returnType" && m.type === "ArrowFunctionExpression" && x(o);
    }
    return false;
  }
  function F(D) {
    return D.type === "BlockStatement" || D.type === "BreakStatement" || D.type === "ClassBody" || D.type === "ClassDeclaration" || D.type === "ClassMethod" || D.type === "ClassProperty" || D.type === "PropertyDefinition" || D.type === "ClassPrivateProperty" || D.type === "ContinueStatement" || D.type === "DebuggerStatement" || D.type === "DeclareClass" || D.type === "DeclareExportAllDeclaration" || D.type === "DeclareExportDeclaration" || D.type === "DeclareFunction" || D.type === "DeclareInterface" || D.type === "DeclareModule" || D.type === "DeclareModuleExports" || D.type === "DeclareVariable" || D.type === "DoWhileStatement" || D.type === "EnumDeclaration" || D.type === "ExportAllDeclaration" || D.type === "ExportDefaultDeclaration" || D.type === "ExportNamedDeclaration" || D.type === "ExpressionStatement" || D.type === "ForInStatement" || D.type === "ForOfStatement" || D.type === "ForStatement" || D.type === "FunctionDeclaration" || D.type === "IfStatement" || D.type === "ImportDeclaration" || D.type === "InterfaceDeclaration" || D.type === "LabeledStatement" || D.type === "MethodDefinition" || D.type === "ReturnStatement" || D.type === "SwitchStatement" || D.type === "ThrowStatement" || D.type === "TryStatement" || D.type === "TSDeclareFunction" || D.type === "TSEnumDeclaration" || D.type === "TSImportEqualsDeclaration" || D.type === "TSInterfaceDeclaration" || D.type === "TSModuleDeclaration" || D.type === "TSNamespaceExportDeclaration" || D.type === "TypeAlias" || D.type === "VariableDeclaration" || D.type === "WhileStatement" || D.type === "WithStatement";
  }
  function N(D) {
    let T = 0, m = D.getValue();
    for (; m; ) {
      let C = D.getParentNode(T++);
      if (C && C.type === "ForStatement" && C.init === m) return true;
      m = C;
    }
    return false;
  }
  function x(D) {
    return l(D, (T) => T.type === "ObjectTypeAnnotation" && l(T, (m) => m.type === "FunctionTypeAnnotation" || void 0) || void 0);
  }
  function I(D) {
    switch (D.type) {
      case "ObjectExpression":
        return true;
      default:
        return false;
    }
  }
  function P(D) {
    let T = D.getValue(), m = D.getParentNode(), C = D.getName();
    switch (m.type) {
      case "NGPipeExpression":
        if (typeof C == "number" && m.arguments[C] === T && m.arguments.length - 1 === C) return D.callParent(P);
        break;
      case "ObjectProperty":
        if (C === "value") {
          let o = D.getParentNode(1);
          return t(o.properties) === m;
        }
        break;
      case "BinaryExpression":
      case "LogicalExpression":
        if (C === "right") return D.callParent(P);
        break;
      case "ConditionalExpression":
        if (C === "alternate") return D.callParent(P);
        break;
      case "UnaryExpression":
        if (m.prefix) return D.callParent(P);
        break;
    }
    return false;
  }
  function $2(D, T) {
    let m = D.getValue(), C = D.getParentNode();
    return m.type === "FunctionExpression" || m.type === "ClassExpression" ? C.type === "ExportDefaultDeclaration" || !w(D, T) : !i(m) || C.type !== "ExportDefaultDeclaration" && w(D, T) ? false : D.call((o) => $2(o, T), ...n(D, m));
  }
  r.exports = w;
} });
var Do = te({ "src/language-js/print-preprocess.js"(e, r) {
  "use strict";
  ne();
  function t(s, a) {
    switch (a.parser) {
      case "json":
      case "json5":
      case "json-stringify":
      case "__js_expression":
      case "__vue_expression":
      case "__vue_ts_expression":
        return Object.assign(Object.assign({}, s), {}, { type: a.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot", node: s, comments: [], rootMarker: a.rootMarker });
      default:
        return s;
    }
  }
  r.exports = t;
} });
var rd = te({ "src/language-js/print/html-binding.js"(e, r) {
  "use strict";
  ne();
  var { builders: { join: t, line: s, group: a, softline: n, indent: u } } = qe();
  function i(p, d, y) {
    let g = p.getValue();
    if (d.__onHtmlBindingRoot && p.getName() === null && d.__onHtmlBindingRoot(g, d), g.type === "File") {
      if (d.__isVueForBindingLeft) return p.call((c) => {
        let f = t([",", s], c.map(y, "params")), { params: E2 } = c.getValue();
        return E2.length === 1 ? f : ["(", u([n, a(f)]), n, ")"];
      }, "program", "body", 0);
      if (d.__isVueBindings) return p.call((c) => t([",", s], c.map(y, "params")), "program", "body", 0);
    }
  }
  function l(p) {
    switch (p.type) {
      case "MemberExpression":
        switch (p.property.type) {
          case "Identifier":
          case "NumericLiteral":
          case "StringLiteral":
            return l(p.object);
        }
        return false;
      case "Identifier":
        return true;
      default:
        return false;
    }
  }
  r.exports = { isVueEventBindingExpression: l, printHtmlBinding: i };
} });
var Zn = te({ "src/language-js/print/binaryish.js"(e, r) {
  "use strict";
  ne();
  var { printComments: t } = et(), { getLast: s } = Ue(), { builders: { join: a, line: n, softline: u, group: i, indent: l, align: p, indentIfBreak: d }, utils: { cleanDoc: y, getDocParts: g, isConcat: c } } = qe(), { hasLeadingOwnLineComment: f, isBinaryish: E2, isJsxNode: _, shouldFlatten: w, hasComment: F, CommentCheckFlags: N, isCallExpression: x, isMemberExpression: I, isObjectProperty: P, isEnabledHackPipeline: $2 } = Ke(), D = 0;
  function T(o, h, v) {
    let S = o.getValue(), b = o.getParentNode(), B = o.getParentNode(1), k = S !== b.body && (b.type === "IfStatement" || b.type === "WhileStatement" || b.type === "SwitchStatement" || b.type === "DoWhileStatement"), M = $2(h) && S.operator === "|>", R = m(o, v, h, false, k);
    if (k) return R;
    if (M) return i(R);
    if (x(b) && b.callee === S || b.type === "UnaryExpression" || I(b) && !b.computed) return i([l([u, ...R]), u]);
    let q = b.type === "ReturnStatement" || b.type === "ThrowStatement" || b.type === "JSXExpressionContainer" && B.type === "JSXAttribute" || S.operator !== "|" && b.type === "JsExpressionRoot" || S.type !== "NGPipeExpression" && (b.type === "NGRoot" && h.parser === "__ng_binding" || b.type === "NGMicrosyntaxExpression" && B.type === "NGMicrosyntax" && B.body.length === 1) || S === b.body && b.type === "ArrowFunctionExpression" || S !== b.body && b.type === "ForStatement" || b.type === "ConditionalExpression" && B.type !== "ReturnStatement" && B.type !== "ThrowStatement" && !x(B) || b.type === "TemplateLiteral", J2 = b.type === "AssignmentExpression" || b.type === "VariableDeclarator" || b.type === "ClassProperty" || b.type === "PropertyDefinition" || b.type === "TSAbstractPropertyDefinition" || b.type === "ClassPrivateProperty" || P(b), L = E2(S.left) && w(S.operator, S.left.operator);
    if (q || C(S) && !L || !C(S) && J2) return i(R);
    if (R.length === 0) return "";
    let Q2 = _(S.right), V = R.findIndex((W) => typeof W != "string" && !Array.isArray(W) && W.type === "group"), j = R.slice(0, V === -1 ? 1 : V + 1), Y = R.slice(j.length, Q2 ? -1 : void 0), ie = Symbol("logicalChain-" + ++D), ee = i([...j, l(Y)], { id: ie });
    if (!Q2) return ee;
    let ce = s(R);
    return i([ee, d(ce, { groupId: ie })]);
  }
  function m(o, h, v, S, b) {
    let B = o.getValue();
    if (!E2(B)) return [i(h())];
    let k = [];
    w(B.operator, B.left.operator) ? k = o.call((Y) => m(Y, h, v, true, b), "left") : k.push(i(h("left")));
    let M = C(B), R = (B.operator === "|>" || B.type === "NGPipeExpression" || B.operator === "|" && v.parser === "__vue_expression") && !f(v.originalText, B.right), q = B.type === "NGPipeExpression" ? "|" : B.operator, J2 = B.type === "NGPipeExpression" && B.arguments.length > 0 ? i(l([n, ": ", a([n, ": "], o.map(h, "arguments").map((Y) => p(2, i(Y))))])) : "", L;
    if (M) L = [q, " ", h("right"), J2];
    else {
      let ie = $2(v) && q === "|>" ? o.call((ee) => m(ee, h, v, true, b), "right") : h("right");
      L = [R ? n : "", q, R ? " " : n, ie, J2];
    }
    let Q2 = o.getParentNode(), V = F(B.left, N.Trailing | N.Line), j = V || !(b && B.type === "LogicalExpression") && Q2.type !== B.type && B.left.type !== B.type && B.right.type !== B.type;
    if (k.push(R ? "" : " ", j ? i(L, { shouldBreak: V }) : L), S && F(B)) {
      let Y = y(t(o, k, v));
      return c(Y) || Y.type === "fill" ? g(Y) : [Y];
    }
    return k;
  }
  function C(o) {
    return o.type !== "LogicalExpression" ? false : !!(o.right.type === "ObjectExpression" && o.right.properties.length > 0 || o.right.type === "ArrayExpression" && o.right.elements.length > 0 || _(o.right));
  }
  r.exports = { printBinaryishExpression: T, shouldInlineLogicalExpression: C };
} });
var nd = te({ "src/language-js/print/angular.js"(e, r) {
  "use strict";
  ne();
  var { builders: { join: t, line: s, group: a } } = qe(), { hasNode: n, hasComment: u, getComments: i } = Ke(), { printBinaryishExpression: l } = Zn();
  function p(g, c, f) {
    let E2 = g.getValue();
    if (E2.type.startsWith("NG")) switch (E2.type) {
      case "NGRoot":
        return [f("node"), u(E2.node) ? " //" + i(E2.node)[0].value.trimEnd() : ""];
      case "NGPipeExpression":
        return l(g, c, f);
      case "NGChainedExpression":
        return a(t([";", s], g.map((_) => y(_) ? f() : ["(", f(), ")"], "expressions")));
      case "NGEmptyExpression":
        return "";
      case "NGQuotedExpression":
        return [E2.prefix, ": ", E2.value.trim()];
      case "NGMicrosyntax":
        return g.map((_, w) => [w === 0 ? "" : d(_.getValue(), w, E2) ? " " : [";", s], f()], "body");
      case "NGMicrosyntaxKey":
        return /^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(E2.name) ? E2.name : JSON.stringify(E2.name);
      case "NGMicrosyntaxExpression":
        return [f("expression"), E2.alias === null ? "" : [" as ", f("alias")]];
      case "NGMicrosyntaxKeyedExpression": {
        let _ = g.getName(), w = g.getParentNode(), F = d(E2, _, w) || (_ === 1 && (E2.key.name === "then" || E2.key.name === "else") || _ === 2 && E2.key.name === "else" && w.body[_ - 1].type === "NGMicrosyntaxKeyedExpression" && w.body[_ - 1].key.name === "then") && w.body[0].type === "NGMicrosyntaxExpression";
        return [f("key"), F ? " " : ": ", f("expression")];
      }
      case "NGMicrosyntaxLet":
        return ["let ", f("key"), E2.value === null ? "" : [" = ", f("value")]];
      case "NGMicrosyntaxAs":
        return [f("key"), " as ", f("alias")];
      default:
        throw new Error(`Unknown Angular node type: ${JSON.stringify(E2.type)}.`);
    }
  }
  function d(g, c, f) {
    return g.type === "NGMicrosyntaxKeyedExpression" && g.key.name === "of" && c === 1 && f.body[0].type === "NGMicrosyntaxLet" && f.body[0].value === null;
  }
  function y(g) {
    return n(g.getValue(), (c) => {
      switch (c.type) {
        case void 0:
          return false;
        case "CallExpression":
        case "OptionalCallExpression":
        case "AssignmentExpression":
          return true;
      }
    });
  }
  r.exports = { printAngular: p };
} });
var ud = te({ "src/language-js/print/jsx.js"(e, r) {
  "use strict";
  ne();
  var { printComments: t, printDanglingComments: s, printCommentsSeparately: a } = et(), { builders: { line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: d, fill: y, ifBreak: g, lineSuffixBoundary: c, join: f }, utils: { willBreak: E2 } } = qe(), { getLast: _, getPreferredQuote: w } = Ue(), { isJsxNode: F, rawText: N, isCallExpression: x, isStringLiteral: I, isBinaryish: P, hasComment: $2, CommentCheckFlags: D, hasNodeIgnoreComment: T } = Ke(), m = Ot(), { willPrintOwnComments: C } = fo(), o = (U) => U === "" || U === n || U === u || U === i;
  function h(U, Z, se) {
    let fe = U.getValue();
    if (fe.type === "JSXElement" && de(fe)) return [se("openingElement"), se("closingElement")];
    let ge = fe.type === "JSXElement" ? se("openingElement") : se("openingFragment"), he = fe.type === "JSXElement" ? se("closingElement") : se("closingFragment");
    if (fe.children.length === 1 && fe.children[0].type === "JSXExpressionContainer" && (fe.children[0].expression.type === "TemplateLiteral" || fe.children[0].expression.type === "TaggedTemplateExpression")) return [ge, ...U.map(se, "children"), he];
    fe.children = fe.children.map((A) => Fe(A) ? { type: "JSXText", value: " ", raw: " " } : A);
    let we = fe.children.some(F), ke = fe.children.filter((A) => A.type === "JSXExpressionContainer").length > 1, Re = fe.type === "JSXElement" && fe.openingElement.attributes.length > 1, Ne = E2(ge) || we || Re || ke, Pe2 = U.getParentNode().rootMarker === "mdx", oe2 = Z.singleQuote ? "{' '}" : '{" "}', H = Pe2 ? " " : g([oe2, i], " "), pe = fe.openingElement && fe.openingElement.name && fe.openingElement.name.name === "fbt", X = v(U, Z, se, H, pe), le2 = fe.children.some((A) => ue(A));
    for (let A = X.length - 2; A >= 0; A--) {
      let G = X[A] === "" && X[A + 1] === "", re = X[A] === u && X[A + 1] === "" && X[A + 2] === u, ye2 = (X[A] === i || X[A] === u) && X[A + 1] === "" && X[A + 2] === H, Ce = X[A] === H && X[A + 1] === "" && (X[A + 2] === i || X[A + 2] === u), Be = X[A] === H && X[A + 1] === "" && X[A + 2] === H, ve = X[A] === i && X[A + 1] === "" && X[A + 2] === u || X[A] === u && X[A + 1] === "" && X[A + 2] === i;
      re && le2 || G || ye2 || Be || ve ? X.splice(A, 2) : Ce && X.splice(A + 1, 2);
    }
    for (; X.length > 0 && o(_(X)); ) X.pop();
    for (; X.length > 1 && o(X[0]) && o(X[1]); ) X.shift(), X.shift();
    let Ae = [];
    for (let [A, G] of X.entries()) {
      if (G === H) {
        if (A === 1 && X[A - 1] === "") {
          if (X.length === 2) {
            Ae.push(oe2);
            continue;
          }
          Ae.push([oe2, u]);
          continue;
        } else if (A === X.length - 1) {
          Ae.push(oe2);
          continue;
        } else if (X[A - 1] === "" && X[A - 2] === u) {
          Ae.push(oe2);
          continue;
        }
      }
      Ae.push(G), E2(G) && (Ne = true);
    }
    let Ee = le2 ? y(Ae) : l(Ae, { shouldBreak: true });
    if (Pe2) return Ee;
    let De = l([ge, p([u, Ee]), u, he]);
    return Ne ? De : d([l([ge, ...X, he]), De]);
  }
  function v(U, Z, se, fe, ge) {
    let he = [];
    return U.each((we, ke, Re) => {
      let Ne = we.getValue();
      if (Ne.type === "JSXText") {
        let Pe2 = N(Ne);
        if (ue(Ne)) {
          let oe2 = Pe2.split(ce);
          if (oe2[0] === "") {
            if (he.push(""), oe2.shift(), /\n/.test(oe2[0])) {
              let pe = Re[ke + 1];
              he.push(b(ge, oe2[1], Ne, pe));
            } else he.push(fe);
            oe2.shift();
          }
          let H;
          if (_(oe2) === "" && (oe2.pop(), H = oe2.pop()), oe2.length === 0) return;
          for (let [pe, X] of oe2.entries()) pe % 2 === 1 ? he.push(n) : he.push(X);
          if (H !== void 0) if (/\n/.test(H)) {
            let pe = Re[ke + 1];
            he.push(b(ge, _(he), Ne, pe));
          } else he.push(fe);
          else {
            let pe = Re[ke + 1];
            he.push(S(ge, _(he), Ne, pe));
          }
        } else /\n/.test(Pe2) ? Pe2.match(/\n/g).length > 1 && he.push("", u) : he.push("", fe);
      } else {
        let Pe2 = se();
        he.push(Pe2);
        let oe2 = Re[ke + 1];
        if (oe2 && ue(oe2)) {
          let pe = K(N(oe2)).split(ce)[0];
          he.push(S(ge, pe, Ne, oe2));
        } else he.push(u);
      }
    }, "children"), he;
  }
  function S(U, Z, se, fe) {
    return U ? "" : se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? Z.length === 1 ? i : u : i;
  }
  function b(U, Z, se, fe) {
    return U ? u : Z.length === 1 ? se.type === "JSXElement" && !se.closingElement || fe && fe.type === "JSXElement" && !fe.closingElement ? u : i : u;
  }
  function B(U, Z, se) {
    let fe = U.getParentNode();
    if (!fe || { ArrayExpression: true, JSXAttribute: true, JSXElement: true, JSXExpressionContainer: true, JSXFragment: true, ExpressionStatement: true, CallExpression: true, OptionalCallExpression: true, ConditionalExpression: true, JsExpressionRoot: true }[fe.type]) return Z;
    let he = U.match(void 0, (ke) => ke.type === "ArrowFunctionExpression", x, (ke) => ke.type === "JSXExpressionContainer"), we = m(U, se);
    return l([we ? "" : g("("), p([i, Z]), i, we ? "" : g(")")], { shouldBreak: he });
  }
  function k(U, Z, se) {
    let fe = U.getValue(), ge = [];
    if (ge.push(se("name")), fe.value) {
      let he;
      if (I(fe.value)) {
        let ke = N(fe.value).slice(1, -1).replace(/&apos;/g, "'").replace(/&quot;/g, '"'), { escaped: Re, quote: Ne, regex: Pe2 } = w(ke, Z.jsxSingleQuote ? "'" : '"');
        ke = ke.replace(Pe2, Re);
        let { leading: oe2, trailing: H } = U.call(() => a(U, Z), "value");
        he = [oe2, Ne, ke, Ne, H];
      } else he = se("value");
      ge.push("=", he);
    }
    return ge;
  }
  function M(U, Z, se) {
    let fe = U.getValue(), ge = (he, we) => he.type === "JSXEmptyExpression" || !$2(he) && (he.type === "ArrayExpression" || he.type === "ObjectExpression" || he.type === "ArrowFunctionExpression" || he.type === "AwaitExpression" && (ge(he.argument, he) || he.argument.type === "JSXElement") || x(he) || he.type === "FunctionExpression" || he.type === "TemplateLiteral" || he.type === "TaggedTemplateExpression" || he.type === "DoExpression" || F(we) && (he.type === "ConditionalExpression" || P(he)));
    return ge(fe.expression, U.getParentNode(0)) ? l(["{", se("expression"), c, "}"]) : l(["{", p([i, se("expression")]), i, c, "}"]);
  }
  function R(U, Z, se) {
    let fe = U.getValue(), ge = fe.name && $2(fe.name) || fe.typeParameters && $2(fe.typeParameters);
    if (fe.selfClosing && fe.attributes.length === 0 && !ge) return ["<", se("name"), se("typeParameters"), " />"];
    if (fe.attributes && fe.attributes.length === 1 && fe.attributes[0].value && I(fe.attributes[0].value) && !fe.attributes[0].value.value.includes(`
`) && !ge && !$2(fe.attributes[0])) return l(["<", se("name"), se("typeParameters"), " ", ...U.map(se, "attributes"), fe.selfClosing ? " />" : ">"]);
    let he = fe.attributes && fe.attributes.some((ke) => ke.value && I(ke.value) && ke.value.value.includes(`
`)), we = Z.singleAttributePerLine && fe.attributes.length > 1 ? u : n;
    return l(["<", se("name"), se("typeParameters"), p(U.map(() => [we, se()], "attributes")), ...q(fe, Z, ge)], { shouldBreak: he });
  }
  function q(U, Z, se) {
    return U.selfClosing ? [n, "/>"] : J2(U, Z, se) ? [">"] : [i, ">"];
  }
  function J2(U, Z, se) {
    let fe = U.attributes.length > 0 && $2(_(U.attributes), D.Trailing);
    return U.attributes.length === 0 && !se || (Z.bracketSameLine || Z.jsxBracketSameLine) && (!se || U.attributes.length > 0) && !fe;
  }
  function L(U, Z, se) {
    let fe = U.getValue(), ge = [];
    ge.push("</");
    let he = se("name");
    return $2(fe.name, D.Leading | D.Line) ? ge.push(p([u, he]), u) : $2(fe.name, D.Leading | D.Block) ? ge.push(" ", he) : ge.push(he), ge.push(">"), ge;
  }
  function Q2(U, Z) {
    let se = U.getValue(), fe = $2(se), ge = $2(se, D.Line), he = se.type === "JSXOpeningFragment";
    return [he ? "<" : "</", p([ge ? u : fe && !he ? " " : "", s(U, Z, true)]), ge ? u : "", ">"];
  }
  function V(U, Z, se) {
    let fe = t(U, h(U, Z, se), Z);
    return B(U, fe, Z);
  }
  function j(U, Z) {
    let se = U.getValue(), fe = $2(se, D.Line);
    return [s(U, Z, !fe), fe ? u : ""];
  }
  function Y(U, Z, se) {
    let fe = U.getValue();
    return ["{", U.call((ge) => {
      let he = ["...", se()], we = ge.getValue();
      return !$2(we) || !C(ge) ? he : [p([i, t(ge, he, Z)]), i];
    }, fe.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"];
  }
  function ie(U, Z, se) {
    let fe = U.getValue();
    if (fe.type.startsWith("JSX")) switch (fe.type) {
      case "JSXAttribute":
        return k(U, Z, se);
      case "JSXIdentifier":
        return String(fe.name);
      case "JSXNamespacedName":
        return f(":", [se("namespace"), se("name")]);
      case "JSXMemberExpression":
        return f(".", [se("object"), se("property")]);
      case "JSXSpreadAttribute":
        return Y(U, Z, se);
      case "JSXSpreadChild":
        return Y(U, Z, se);
      case "JSXExpressionContainer":
        return M(U, Z, se);
      case "JSXFragment":
      case "JSXElement":
        return V(U, Z, se);
      case "JSXOpeningElement":
        return R(U, Z, se);
      case "JSXClosingElement":
        return L(U, Z, se);
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        return Q2(U, Z);
      case "JSXEmptyExpression":
        return j(U, Z);
      case "JSXText":
        throw new Error("JSXText should be handled by JSXElement");
      default:
        throw new Error(`Unknown JSX node type: ${JSON.stringify(fe.type)}.`);
    }
  }
  var ee = ` 
\r	`, ce = new RegExp("([" + ee + "]+)"), W = new RegExp("[^" + ee + "]"), K = (U) => U.replace(new RegExp("(?:^" + ce.source + "|" + ce.source + "$)"), "");
  function de(U) {
    if (U.children.length === 0) return true;
    if (U.children.length > 1) return false;
    let Z = U.children[0];
    return Z.type === "JSXText" && !ue(Z);
  }
  function ue(U) {
    return U.type === "JSXText" && (W.test(N(U)) || !/\n/.test(N(U)));
  }
  function Fe(U) {
    return U.type === "JSXExpressionContainer" && I(U.expression) && U.expression.value === " " && !$2(U.expression);
  }
  function z(U) {
    let Z = U.getValue(), se = U.getParentNode();
    if (!se || !Z || !F(Z) || !F(se)) return false;
    let fe = se.children.indexOf(Z), ge = null;
    for (let he = fe; he > 0; he--) {
      let we = se.children[he - 1];
      if (!(we.type === "JSXText" && !ue(we))) {
        ge = we;
        break;
      }
    }
    return ge && ge.type === "JSXExpressionContainer" && ge.expression.type === "JSXEmptyExpression" && T(ge.expression);
  }
  r.exports = { hasJsxIgnoreComment: z, printJsx: ie };
} });
var ct = te({ "src/language-js/print/misc.js"(e, r) {
  "use strict";
  ne();
  var { isNonEmptyArray: t } = Ue(), { builders: { indent: s, join: a, line: n } } = qe(), { isFlowAnnotationComment: u } = Ke();
  function i(_) {
    let w = _.getValue();
    return !w.optional || w.type === "Identifier" && w === _.getParentNode().key ? "" : w.type === "OptionalCallExpression" || w.type === "OptionalMemberExpression" && w.computed ? "?." : "?";
  }
  function l(_) {
    return _.getValue().definite || _.match(void 0, (w, F) => F === "id" && w.type === "VariableDeclarator" && w.definite) ? "!" : "";
  }
  function p(_, w, F) {
    let N = _.getValue();
    return N.typeArguments ? F("typeArguments") : N.typeParameters ? F("typeParameters") : "";
  }
  function d(_, w, F) {
    let N = _.getValue();
    if (!N.typeAnnotation) return "";
    let x = _.getParentNode(), I = x.type === "DeclareFunction" && x.id === N;
    return u(w.originalText, N.typeAnnotation) ? [" /*: ", F("typeAnnotation"), " */"] : [I ? "" : ": ", F("typeAnnotation")];
  }
  function y(_, w, F) {
    return ["::", F("callee")];
  }
  function g(_, w, F) {
    let N = _.getValue();
    return t(N.modifiers) ? [a(" ", _.map(F, "modifiers")), " "] : "";
  }
  function c(_, w, F) {
    return _.type === "EmptyStatement" ? ";" : _.type === "BlockStatement" || F ? [" ", w] : s([n, w]);
  }
  function f(_, w, F) {
    return ["...", F("argument"), d(_, w, F)];
  }
  function E2(_, w) {
    let F = _.slice(1, -1);
    if (F.includes('"') || F.includes("'")) return _;
    let N = w.singleQuote ? "'" : '"';
    return N + F + N;
  }
  r.exports = { printOptionalToken: i, printDefiniteToken: l, printFunctionTypeParameters: p, printBindExpressionCallee: y, printTypeScriptModifiers: g, printTypeAnnotation: d, printRestSpread: f, adjustClause: c, printDirective: E2 };
} });
var Qt = te({ "src/language-js/print/array.js"(e, r) {
  "use strict";
  ne();
  var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, hardline: n, group: u, indent: i, ifBreak: l, fill: p } } = qe(), { getLast: d, hasNewline: y } = Ue(), { shouldPrintComma: g, hasComment: c, CommentCheckFlags: f, isNextLineEmpty: E2, isNumericLiteral: _, isSignedNumericLiteral: w } = Ke(), { locStart: F } = ut(), { printOptionalToken: N, printTypeAnnotation: x } = ct();
  function I(T, m, C) {
    let o = T.getValue(), h = [], v = o.type === "TupleExpression" ? "#[" : "[", S = "]";
    if (o.elements.length === 0) c(o, f.Dangling) ? h.push(u([v, t(T, m), a, S])) : h.push(v, S);
    else {
      let b = d(o.elements), B = !(b && b.type === "RestElement"), k = b === null, M = Symbol("array"), R = !m.__inJestEach && o.elements.length > 1 && o.elements.every((L, Q2, V) => {
        let j = L && L.type;
        if (j !== "ArrayExpression" && j !== "ObjectExpression") return false;
        let Y = V[Q2 + 1];
        if (Y && j !== Y.type) return false;
        let ie = j === "ArrayExpression" ? "elements" : "properties";
        return L[ie] && L[ie].length > 1;
      }), q = P(o, m), J2 = B ? k ? "," : g(m) ? q ? l(",", "", { groupId: M }) : l(",") : "" : "";
      h.push(u([v, i([a, q ? D(T, m, C, J2) : [$2(T, m, "elements", C), J2], t(T, m, true)]), a, S], { shouldBreak: R, id: M }));
    }
    return h.push(N(T), x(T, m, C)), h;
  }
  function P(T, m) {
    return T.elements.length > 1 && T.elements.every((C) => C && (_(C) || w(C) && !c(C.argument)) && !c(C, f.Trailing | f.Line, (o) => !y(m.originalText, F(o), { backwards: true })));
  }
  function $2(T, m, C, o) {
    let h = [], v = [];
    return T.each((S) => {
      h.push(v, u(o())), v = [",", s], S.getValue() && E2(S.getValue(), m) && v.push(a);
    }, C), h;
  }
  function D(T, m, C, o) {
    let h = [];
    return T.each((v, S, b) => {
      let B = S === b.length - 1;
      h.push([C(), B ? o : ","]), B || h.push(E2(v.getValue(), m) ? [n, n] : c(b[S + 1], f.Leading | f.Line) ? n : s);
    }, "elements"), p(h);
  }
  r.exports = { printArray: I, printArrayItems: $2, isConciselyPrintedArray: P };
} });
var mo = te({ "src/language-js/print/call-arguments.js"(e, r) {
  "use strict";
  ne();
  var { printDanglingComments: t } = et(), { getLast: s, getPenultimate: a } = Ue(), { getFunctionParameters: n, hasComment: u, CommentCheckFlags: i, isFunctionCompositionArgs: l, isJsxNode: p, isLongCurriedCallExpression: d, shouldPrintComma: y, getCallArguments: g, iterateCallArgumentsPath: c, isNextLineEmpty: f, isCallExpression: E2, isStringLiteral: _, isObjectProperty: w, isTSTypeExpression: F } = Ke(), { builders: { line: N, hardline: x, softline: I, group: P, indent: $2, conditionalGroup: D, ifBreak: T, breakParent: m }, utils: { willBreak: C } } = qe(), { ArgExpansionBailout: o } = Kt(), { isConciselyPrintedArray: h } = Qt();
  function v(q, J2, L) {
    let Q2 = q.getValue(), V = Q2.type === "ImportExpression", j = g(Q2);
    if (j.length === 0) return ["(", t(q, J2, true), ")"];
    if (k(j)) return ["(", L(["arguments", 0]), ", ", L(["arguments", 1]), ")"];
    let Y = false, ie = false, ee = j.length - 1, ce = [];
    c(q, (z, U) => {
      let Z = z.getNode(), se = [L()];
      U === ee || (f(Z, J2) ? (U === 0 && (ie = true), Y = true, se.push(",", x, x)) : se.push(",", N)), ce.push(se);
    });
    let W = !(V || Q2.callee && Q2.callee.type === "Import") && y(J2, "all") ? "," : "";
    function K() {
      return P(["(", $2([N, ...ce]), W, N, ")"], { shouldBreak: true });
    }
    if (Y || q.getParentNode().type !== "Decorator" && l(j)) return K();
    let de = B(j), ue = b(j, J2);
    if (de || ue) {
      if (de ? ce.slice(1).some(C) : ce.slice(0, -1).some(C)) return K();
      let z = [];
      try {
        q.try(() => {
          c(q, (U, Z) => {
            de && Z === 0 && (z = [[L([], { expandFirstArg: true }), ce.length > 1 ? "," : "", ie ? x : N, ie ? x : ""], ...ce.slice(1)]), ue && Z === ee && (z = [...ce.slice(0, -1), L([], { expandLastArg: true })]);
          });
        });
      } catch (U) {
        if (U instanceof o) return K();
        throw U;
      }
      return [ce.some(C) ? m : "", D([["(", ...z, ")"], de ? ["(", P(z[0], { shouldBreak: true }), ...z.slice(1), ")"] : ["(", ...ce.slice(0, -1), P(s(z), { shouldBreak: true }), ")"], K()])];
    }
    let Fe = ["(", $2([I, ...ce]), T(W), I, ")"];
    return d(q) ? Fe : P(Fe, { shouldBreak: ce.some(C) || Y });
  }
  function S(q) {
    let J2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    return q.type === "ObjectExpression" && (q.properties.length > 0 || u(q)) || q.type === "ArrayExpression" && (q.elements.length > 0 || u(q)) || q.type === "TSTypeAssertion" && S(q.expression) || F(q) && S(q.expression) || q.type === "FunctionExpression" || q.type === "ArrowFunctionExpression" && (!q.returnType || !q.returnType.typeAnnotation || q.returnType.typeAnnotation.type !== "TSTypeReference" || M(q.body)) && (q.body.type === "BlockStatement" || q.body.type === "ArrowFunctionExpression" && S(q.body, true) || q.body.type === "ObjectExpression" || q.body.type === "ArrayExpression" || !J2 && (E2(q.body) || q.body.type === "ConditionalExpression") || p(q.body)) || q.type === "DoExpression" || q.type === "ModuleExpression";
  }
  function b(q, J2) {
    let L = s(q), Q2 = a(q);
    return !u(L, i.Leading) && !u(L, i.Trailing) && S(L) && (!Q2 || Q2.type !== L.type) && (q.length !== 2 || Q2.type !== "ArrowFunctionExpression" || L.type !== "ArrayExpression") && !(q.length > 1 && L.type === "ArrayExpression" && h(L, J2));
  }
  function B(q) {
    if (q.length !== 2) return false;
    let [J2, L] = q;
    return J2.type === "ModuleExpression" && R(L) ? true : !u(J2) && (J2.type === "FunctionExpression" || J2.type === "ArrowFunctionExpression" && J2.body.type === "BlockStatement") && L.type !== "FunctionExpression" && L.type !== "ArrowFunctionExpression" && L.type !== "ConditionalExpression" && !S(L);
  }
  function k(q) {
    return q.length === 2 && q[0].type === "ArrowFunctionExpression" && n(q[0]).length === 0 && q[0].body.type === "BlockStatement" && q[1].type === "ArrayExpression" && !q.some((J2) => u(J2));
  }
  function M(q) {
    return q.type === "BlockStatement" && (q.body.some((J2) => J2.type !== "EmptyStatement") || u(q, i.Dangling));
  }
  function R(q) {
    return q.type === "ObjectExpression" && q.properties.length === 1 && w(q.properties[0]) && q.properties[0].key.type === "Identifier" && q.properties[0].key.name === "type" && _(q.properties[0].value) && q.properties[0].value.value === "module";
  }
  r.exports = v;
} });
var go = te({ "src/language-js/print/member.js"(e, r) {
  "use strict";
  ne();
  var { builders: { softline: t, group: s, indent: a, label: n } } = qe(), { isNumericLiteral: u, isMemberExpression: i, isCallExpression: l } = Ke(), { printOptionalToken: p } = ct();
  function d(g, c, f) {
    let E2 = g.getValue(), _ = g.getParentNode(), w, F = 0;
    do
      w = g.getParentNode(F), F++;
    while (w && (i(w) || w.type === "TSNonNullExpression"));
    let N = f("object"), x = y(g, c, f), I = w && (w.type === "NewExpression" || w.type === "BindExpression" || w.type === "AssignmentExpression" && w.left.type !== "Identifier") || E2.computed || E2.object.type === "Identifier" && E2.property.type === "Identifier" && !i(_) || (_.type === "AssignmentExpression" || _.type === "VariableDeclarator") && (l(E2.object) && E2.object.arguments.length > 0 || E2.object.type === "TSNonNullExpression" && l(E2.object.expression) && E2.object.expression.arguments.length > 0 || N.label === "member-chain");
    return n(N.label === "member-chain" ? "member-chain" : "member", [N, I ? x : s(a([t, x]))]);
  }
  function y(g, c, f) {
    let E2 = f("property"), _ = g.getValue(), w = p(g);
    return _.computed ? !_.property || u(_.property) ? [w, "[", E2, "]"] : s([w, "[", a([t, E2]), t, "]"]) : [w, ".", E2];
  }
  r.exports = { printMemberExpression: d, printMemberLookup: y };
} });
var sd = te({ "src/language-js/print/member-chain.js"(e, r) {
  "use strict";
  ne();
  var { printComments: t } = et(), { getLast: s, isNextLineEmptyAfterIndex: a, getNextNonSpaceNonCommentCharacterIndex: n } = Ue(), u = Ot(), { isCallExpression: i, isMemberExpression: l, isFunctionOrArrowExpression: p, isLongCurriedCallExpression: d, isMemberish: y, isNumericLiteral: g, isSimpleCallArgument: c, hasComment: f, CommentCheckFlags: E2, isNextLineEmpty: _ } = Ke(), { locEnd: w } = ut(), { builders: { join: F, hardline: N, group: x, indent: I, conditionalGroup: P, breakParent: $2, label: D }, utils: { willBreak: T } } = qe(), m = mo(), { printMemberLookup: C } = go(), { printOptionalToken: o, printFunctionTypeParameters: h, printBindExpressionCallee: v } = ct();
  function S(b, B, k) {
    let M = b.getParentNode(), R = !M || M.type === "ExpressionStatement", q = [];
    function J2(Ne) {
      let { originalText: Pe2 } = B, oe2 = n(Pe2, Ne, w);
      return Pe2.charAt(oe2) === ")" ? oe2 !== false && a(Pe2, oe2 + 1) : _(Ne, B);
    }
    function L(Ne) {
      let Pe2 = Ne.getValue();
      i(Pe2) && (y(Pe2.callee) || i(Pe2.callee)) ? (q.unshift({ node: Pe2, printed: [t(Ne, [o(Ne), h(Ne, B, k), m(Ne, B, k)], B), J2(Pe2) ? N : ""] }), Ne.call((oe2) => L(oe2), "callee")) : y(Pe2) ? (q.unshift({ node: Pe2, needsParens: u(Ne, B), printed: t(Ne, l(Pe2) ? C(Ne, B, k) : v(Ne, B, k), B) }), Ne.call((oe2) => L(oe2), "object")) : Pe2.type === "TSNonNullExpression" ? (q.unshift({ node: Pe2, printed: t(Ne, "!", B) }), Ne.call((oe2) => L(oe2), "expression")) : q.unshift({ node: Pe2, printed: k() });
    }
    let Q2 = b.getValue();
    q.unshift({ node: Q2, printed: [o(b), h(b, B, k), m(b, B, k)] }), Q2.callee && b.call((Ne) => L(Ne), "callee");
    let V = [], j = [q[0]], Y = 1;
    for (; Y < q.length && (q[Y].node.type === "TSNonNullExpression" || i(q[Y].node) || l(q[Y].node) && q[Y].node.computed && g(q[Y].node.property)); ++Y) j.push(q[Y]);
    if (!i(q[0].node)) for (; Y + 1 < q.length && (y(q[Y].node) && y(q[Y + 1].node)); ++Y) j.push(q[Y]);
    V.push(j), j = [];
    let ie = false;
    for (; Y < q.length; ++Y) {
      if (ie && y(q[Y].node)) {
        if (q[Y].node.computed && g(q[Y].node.property)) {
          j.push(q[Y]);
          continue;
        }
        V.push(j), j = [], ie = false;
      }
      (i(q[Y].node) || q[Y].node.type === "ImportExpression") && (ie = true), j.push(q[Y]), f(q[Y].node, E2.Trailing) && (V.push(j), j = [], ie = false);
    }
    j.length > 0 && V.push(j);
    function ee(Ne) {
      return /^[A-Z]|^[$_]+$/.test(Ne);
    }
    function ce(Ne) {
      return Ne.length <= B.tabWidth;
    }
    function W(Ne) {
      let Pe2 = Ne[1].length > 0 && Ne[1][0].node.computed;
      if (Ne[0].length === 1) {
        let H = Ne[0][0].node;
        return H.type === "ThisExpression" || H.type === "Identifier" && (ee(H.name) || R && ce(H.name) || Pe2);
      }
      let oe2 = s(Ne[0]).node;
      return l(oe2) && oe2.property.type === "Identifier" && (ee(oe2.property.name) || Pe2);
    }
    let K = V.length >= 2 && !f(V[1][0].node) && W(V);
    function de(Ne) {
      let Pe2 = Ne.map((oe2) => oe2.printed);
      return Ne.length > 0 && s(Ne).needsParens ? ["(", ...Pe2, ")"] : Pe2;
    }
    function ue(Ne) {
      return Ne.length === 0 ? "" : I(x([N, F(N, Ne.map(de))]));
    }
    let Fe = V.map(de), z = Fe, U = K ? 3 : 2, Z = V.flat(), se = Z.slice(1, -1).some((Ne) => f(Ne.node, E2.Leading)) || Z.slice(0, -1).some((Ne) => f(Ne.node, E2.Trailing)) || V[U] && f(V[U][0].node, E2.Leading);
    if (V.length <= U && !se) return d(b) ? z : x(z);
    let fe = s(V[K ? 1 : 0]).node, ge = !i(fe) && J2(fe), he = [de(V[0]), K ? V.slice(1, 2).map(de) : "", ge ? N : "", ue(V.slice(K ? 2 : 1))], we = q.map((Ne) => {
      let { node: Pe2 } = Ne;
      return Pe2;
    }).filter(i);
    function ke() {
      let Ne = s(s(V)).node, Pe2 = s(Fe);
      return i(Ne) && T(Pe2) && we.slice(0, -1).some((oe2) => oe2.arguments.some(p));
    }
    let Re;
    return se || we.length > 2 && we.some((Ne) => !Ne.arguments.every((Pe2) => c(Pe2, 0))) || Fe.slice(0, -1).some(T) || ke() ? Re = x(he) : Re = [T(z) || ge ? $2 : "", P([z, he])], D("member-chain", Re);
  }
  r.exports = S;
} });
var yo = te({ "src/language-js/print/call-expression.js"(e, r) {
  "use strict";
  ne();
  var { builders: { join: t, group: s } } = qe(), a = Ot(), { getCallArguments: n, hasFlowAnnotationComment: u, isCallExpression: i, isMemberish: l, isStringLiteral: p, isTemplateOnItsOwnLine: d, isTestCall: y, iterateCallArgumentsPath: g } = Ke(), c = sd(), f = mo(), { printOptionalToken: E2, printFunctionTypeParameters: _ } = ct();
  function w(N, x, I) {
    let P = N.getValue(), $2 = N.getParentNode(), D = P.type === "NewExpression", T = P.type === "ImportExpression", m = E2(N), C = n(P);
    if (C.length > 0 && (!T && !D && F(P, $2) || C.length === 1 && d(C[0], x.originalText) || !D && y(P, $2))) {
      let v = [];
      return g(N, () => {
        v.push(I());
      }), [D ? "new " : "", I("callee"), m, _(N, x, I), "(", t(", ", v), ")"];
    }
    let o = (x.parser === "babel" || x.parser === "babel-flow") && P.callee && P.callee.type === "Identifier" && u(P.callee.trailingComments);
    if (o && (P.callee.trailingComments[0].printed = true), !T && !D && l(P.callee) && !N.call((v) => a(v, x), "callee")) return c(N, x, I);
    let h = [D ? "new " : "", T ? "import" : I("callee"), m, o ? `/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */` : "", _(N, x, I), f(N, x, I)];
    return T || i(P.callee) ? s(h) : h;
  }
  function F(N, x) {
    if (N.callee.type !== "Identifier") return false;
    if (N.callee.name === "require") return true;
    if (N.callee.name === "define") {
      let I = n(N);
      return x.type === "ExpressionStatement" && (I.length === 1 || I.length === 2 && I[0].type === "ArrayExpression" || I.length === 3 && p(I[0]) && I[1].type === "ArrayExpression");
    }
    return false;
  }
  r.exports = { printCallExpression: w };
} });
var Zt = te({ "src/language-js/print/assignment.js"(e, r) {
  "use strict";
  ne();
  var { isNonEmptyArray: t, getStringWidth: s } = Ue(), { builders: { line: a, group: n, indent: u, indentIfBreak: i, lineSuffixBoundary: l }, utils: { cleanDoc: p, willBreak: d, canBreak: y } } = qe(), { hasLeadingOwnLineComment: g, isBinaryish: c, isStringLiteral: f, isLiteral: E2, isNumericLiteral: _, isCallExpression: w, isMemberExpression: F, getCallArguments: N, rawText: x, hasComment: I, isSignedNumericLiteral: P, isObjectProperty: $2 } = Ke(), { shouldInlineLogicalExpression: D } = Zn(), { printCallExpression: T } = yo();
  function m(W, K, de, ue, Fe, z) {
    let U = h(W, K, de, ue, z), Z = de(z, { assignmentLayout: U });
    switch (U) {
      case "break-after-operator":
        return n([n(ue), Fe, n(u([a, Z]))]);
      case "never-break-after-operator":
        return n([n(ue), Fe, " ", Z]);
      case "fluid": {
        let se = Symbol("assignment");
        return n([n(ue), Fe, n(u(a), { id: se }), l, i(Z, { groupId: se })]);
      }
      case "break-lhs":
        return n([ue, Fe, " ", n(Z)]);
      case "chain":
        return [n(ue), Fe, a, Z];
      case "chain-tail":
        return [n(ue), Fe, u([a, Z])];
      case "chain-tail-arrow-chain":
        return [n(ue), Fe, Z];
      case "only-left":
        return ue;
    }
  }
  function C(W, K, de) {
    let ue = W.getValue();
    return m(W, K, de, de("left"), [" ", ue.operator], "right");
  }
  function o(W, K, de) {
    return m(W, K, de, de("id"), " =", "init");
  }
  function h(W, K, de, ue, Fe) {
    let z = W.getValue(), U = z[Fe];
    if (!U) return "only-left";
    let Z = !b(U);
    if (W.match(b, B, (he) => !Z || he.type !== "ExpressionStatement" && he.type !== "VariableDeclaration")) return Z ? U.type === "ArrowFunctionExpression" && U.body.type === "ArrowFunctionExpression" ? "chain-tail-arrow-chain" : "chain-tail" : "chain";
    if (!Z && b(U.right) || g(K.originalText, U)) return "break-after-operator";
    if (U.type === "CallExpression" && U.callee.name === "require" || K.parser === "json5" || K.parser === "json") return "never-break-after-operator";
    if (S(z) || k(z) || q(z) || J2(z) && y(ue)) return "break-lhs";
    let ge = ie(z, ue, K);
    return W.call(() => v(W, K, de, ge), Fe) ? "break-after-operator" : ge || U.type === "TemplateLiteral" || U.type === "TaggedTemplateExpression" || U.type === "BooleanLiteral" || _(U) || U.type === "ClassExpression" ? "never-break-after-operator" : "fluid";
  }
  function v(W, K, de, ue) {
    let Fe = W.getValue();
    if (c(Fe) && !D(Fe)) return true;
    switch (Fe.type) {
      case "StringLiteralTypeAnnotation":
      case "SequenceExpression":
        return true;
      case "ConditionalExpression": {
        let { test: Z } = Fe;
        return c(Z) && !D(Z);
      }
      case "ClassExpression":
        return t(Fe.decorators);
    }
    if (ue) return false;
    let z = Fe, U = [];
    for (; ; ) if (z.type === "UnaryExpression") z = z.argument, U.push("argument");
    else if (z.type === "TSNonNullExpression") z = z.expression, U.push("expression");
    else break;
    return !!(f(z) || W.call(() => V(W, K, de), ...U));
  }
  function S(W) {
    if (B(W)) {
      let K = W.left || W.id;
      return K.type === "ObjectPattern" && K.properties.length > 2 && K.properties.some((de) => $2(de) && (!de.shorthand || de.value && de.value.type === "AssignmentPattern"));
    }
    return false;
  }
  function b(W) {
    return W.type === "AssignmentExpression";
  }
  function B(W) {
    return b(W) || W.type === "VariableDeclarator";
  }
  function k(W) {
    let K = M(W);
    if (t(K)) {
      let de = W.type === "TSTypeAliasDeclaration" ? "constraint" : "bound";
      if (K.length > 1 && K.some((ue) => ue[de] || ue.default)) return true;
    }
    return false;
  }
  function M(W) {
    return R(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
  }
  function R(W) {
    return W.type === "TSTypeAliasDeclaration" || W.type === "TypeAlias";
  }
  function q(W) {
    if (W.type !== "VariableDeclarator") return false;
    let { typeAnnotation: K } = W.id;
    if (!K || !K.typeAnnotation) return false;
    let de = L(K.typeAnnotation);
    return t(de) && de.length > 1 && de.some((ue) => t(L(ue)) || ue.type === "TSConditionalType");
  }
  function J2(W) {
    return W.type === "VariableDeclarator" && W.init && W.init.type === "ArrowFunctionExpression";
  }
  function L(W) {
    return Q2(W) && W.typeParameters && W.typeParameters.params ? W.typeParameters.params : null;
  }
  function Q2(W) {
    return W.type === "TSTypeReference" || W.type === "GenericTypeAnnotation";
  }
  function V(W, K, de) {
    let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, Fe = W.getValue(), z = () => V(W, K, de, true);
    if (Fe.type === "TSNonNullExpression") return W.call(z, "expression");
    if (w(Fe)) {
      if (T(W, K, de).label === "member-chain") return false;
      let Z = N(Fe);
      return !(Z.length === 0 || Z.length === 1 && Y(Z[0], K)) || ee(Fe, de) ? false : W.call(z, "callee");
    }
    return F(Fe) ? W.call(z, "object") : ue && (Fe.type === "Identifier" || Fe.type === "ThisExpression");
  }
  var j = 0.25;
  function Y(W, K) {
    let { printWidth: de } = K;
    if (I(W)) return false;
    let ue = de * j;
    if (W.type === "ThisExpression" || W.type === "Identifier" && W.name.length <= ue || P(W) && !I(W.argument)) return true;
    let Fe = W.type === "Literal" && "regex" in W && W.regex.pattern || W.type === "RegExpLiteral" && W.pattern;
    return Fe ? Fe.length <= ue : f(W) ? x(W).length <= ue : W.type === "TemplateLiteral" ? W.expressions.length === 0 && W.quasis[0].value.raw.length <= ue && !W.quasis[0].value.raw.includes(`
`) : E2(W);
  }
  function ie(W, K, de) {
    if (!$2(W)) return false;
    K = p(K);
    let ue = 3;
    return typeof K == "string" && s(K) < de.tabWidth + ue;
  }
  function ee(W, K) {
    let de = ce(W);
    if (t(de)) {
      if (de.length > 1) return true;
      if (de.length === 1) {
        let Fe = de[0];
        if (Fe.type === "TSUnionType" || Fe.type === "UnionTypeAnnotation" || Fe.type === "TSIntersectionType" || Fe.type === "IntersectionTypeAnnotation" || Fe.type === "TSTypeLiteral" || Fe.type === "ObjectTypeAnnotation") return true;
      }
      let ue = W.typeParameters ? "typeParameters" : "typeArguments";
      if (d(K(ue))) return true;
    }
    return false;
  }
  function ce(W) {
    return W.typeParameters && W.typeParameters.params || W.typeArguments && W.typeArguments.params;
  }
  r.exports = { printVariableDeclarator: o, printAssignmentExpression: C, printAssignment: m, isArrowFunctionVariableDeclarator: J2 };
} });
var Ir = te({ "src/language-js/print/function-parameters.js"(e, r) {
  "use strict";
  ne();
  var { getNextNonSpaceNonCommentCharacter: t } = Ue(), { printDanglingComments: s } = et(), { builders: { line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p }, utils: { removeLines: d, willBreak: y } } = qe(), { getFunctionParameters: g, iterateFunctionParametersPath: c, isSimpleType: f, isTestCall: E2, isTypeAnnotationAFunction: _, isObjectType: w, isObjectTypePropertyAFunction: F, hasRestParameter: N, shouldPrintComma: x, hasComment: I, isNextLineEmpty: P } = Ke(), { locEnd: $2 } = ut(), { ArgExpansionBailout: D } = Kt(), { printFunctionTypeParameters: T } = ct();
  function m(v, S, b, B, k) {
    let M = v.getValue(), R = g(M), q = k ? T(v, b, S) : "";
    if (R.length === 0) return [q, "(", s(v, b, true, (ie) => t(b.originalText, ie, $2) === ")"), ")"];
    let J2 = v.getParentNode(), L = E2(J2), Q2 = C(M), V = [];
    if (c(v, (ie, ee) => {
      let ce = ee === R.length - 1;
      ce && M.rest && V.push("..."), V.push(S()), !ce && (V.push(","), L || Q2 ? V.push(" ") : P(R[ee], b) ? V.push(n, n) : V.push(a));
    }), B) {
      if (y(q) || y(V)) throw new D();
      return i([d(q), "(", d(V), ")"]);
    }
    let j = R.every((ie) => !ie.decorators);
    return Q2 && j ? [q, "(", ...V, ")"] : L ? [q, "(", ...V, ")"] : (F(J2) || _(J2) || J2.type === "TypeAlias" || J2.type === "UnionTypeAnnotation" || J2.type === "TSUnionType" || J2.type === "IntersectionTypeAnnotation" || J2.type === "FunctionTypeAnnotation" && J2.returnType === M) && R.length === 1 && R[0].name === null && M.this !== R[0] && R[0].typeAnnotation && M.typeParameters === null && f(R[0].typeAnnotation) && !M.rest ? b.arrowParens === "always" ? ["(", ...V, ")"] : V : [q, "(", l([u, ...V]), p(!N(M) && x(b, "all") ? "," : ""), u, ")"];
  }
  function C(v) {
    if (!v) return false;
    let S = g(v);
    if (S.length !== 1) return false;
    let [b] = S;
    return !I(b) && (b.type === "ObjectPattern" || b.type === "ArrayPattern" || b.type === "Identifier" && b.typeAnnotation && (b.typeAnnotation.type === "TypeAnnotation" || b.typeAnnotation.type === "TSTypeAnnotation") && w(b.typeAnnotation.typeAnnotation) || b.type === "FunctionTypeParam" && w(b.typeAnnotation) || b.type === "AssignmentPattern" && (b.left.type === "ObjectPattern" || b.left.type === "ArrayPattern") && (b.right.type === "Identifier" || b.right.type === "ObjectExpression" && b.right.properties.length === 0 || b.right.type === "ArrayExpression" && b.right.elements.length === 0));
  }
  function o(v) {
    let S;
    return v.returnType ? (S = v.returnType, S.typeAnnotation && (S = S.typeAnnotation)) : v.typeAnnotation && (S = v.typeAnnotation), S;
  }
  function h(v, S) {
    let b = o(v);
    if (!b) return false;
    let B = v.typeParameters && v.typeParameters.params;
    if (B) {
      if (B.length > 1) return false;
      if (B.length === 1) {
        let k = B[0];
        if (k.constraint || k.default) return false;
      }
    }
    return g(v).length === 1 && (w(b) || y(S));
  }
  r.exports = { printFunctionParameters: m, shouldHugFunctionParameters: C, shouldGroupFunctionParameters: h };
} });
var kr = te({ "src/language-js/print/type-annotation.js"(e, r) {
  "use strict";
  ne();
  var { printComments: t, printDanglingComments: s } = et(), { isNonEmptyArray: a } = Ue(), { builders: { group: n, join: u, line: i, softline: l, indent: p, align: d, ifBreak: y } } = qe(), g = Ot(), { locStart: c } = ut(), { isSimpleType: f, isObjectType: E2, hasLeadingOwnLineComment: _, isObjectTypePropertyAFunction: w, shouldPrintComma: F } = Ke(), { printAssignment: N } = Zt(), { printFunctionParameters: x, shouldGroupFunctionParameters: I } = Ir(), { printArrayItems: P } = Qt();
  function $2(b) {
    if (f(b) || E2(b)) return true;
    if (b.type === "UnionTypeAnnotation" || b.type === "TSUnionType") {
      let B = b.types.filter((M) => M.type === "VoidTypeAnnotation" || M.type === "TSVoidKeyword" || M.type === "NullLiteralTypeAnnotation" || M.type === "TSNullKeyword").length, k = b.types.some((M) => M.type === "ObjectTypeAnnotation" || M.type === "TSTypeLiteral" || M.type === "GenericTypeAnnotation" || M.type === "TSTypeReference");
      if (b.types.length - 1 === B && k) return true;
    }
    return false;
  }
  function D(b, B, k) {
    let M = B.semi ? ";" : "", R = b.getValue(), q = [];
    return q.push("opaque type ", k("id"), k("typeParameters")), R.supertype && q.push(": ", k("supertype")), R.impltype && q.push(" = ", k("impltype")), q.push(M), q;
  }
  function T(b, B, k) {
    let M = B.semi ? ";" : "", R = b.getValue(), q = [];
    R.declare && q.push("declare "), q.push("type ", k("id"), k("typeParameters"));
    let J2 = R.type === "TSTypeAliasDeclaration" ? "typeAnnotation" : "right";
    return [N(b, B, k, q, " =", J2), M];
  }
  function m(b, B, k) {
    let M = b.getValue(), R = b.map(k, "types"), q = [], J2 = false;
    for (let L = 0; L < R.length; ++L) L === 0 ? q.push(R[L]) : E2(M.types[L - 1]) && E2(M.types[L]) ? q.push([" & ", J2 ? p(R[L]) : R[L]]) : !E2(M.types[L - 1]) && !E2(M.types[L]) ? q.push(p([" &", i, R[L]])) : (L > 1 && (J2 = true), q.push(" & ", L > 1 ? p(R[L]) : R[L]));
    return n(q);
  }
  function C(b, B, k) {
    let M = b.getValue(), R = b.getParentNode(), q = R.type !== "TypeParameterInstantiation" && R.type !== "TSTypeParameterInstantiation" && R.type !== "GenericTypeAnnotation" && R.type !== "TSTypeReference" && R.type !== "TSTypeAssertion" && R.type !== "TupleTypeAnnotation" && R.type !== "TSTupleType" && !(R.type === "FunctionTypeParam" && !R.name && b.getParentNode(1).this !== R) && !((R.type === "TypeAlias" || R.type === "VariableDeclarator" || R.type === "TSTypeAliasDeclaration") && _(B.originalText, M)), J2 = $2(M), L = b.map((j) => {
      let Y = k();
      return J2 || (Y = d(2, Y)), t(j, Y, B);
    }, "types");
    if (J2) return u(" | ", L);
    let Q2 = q && !_(B.originalText, M), V = [y([Q2 ? i : "", "| "]), u([i, "| "], L)];
    return g(b, B) ? n([p(V), l]) : R.type === "TupleTypeAnnotation" && R.types.length > 1 || R.type === "TSTupleType" && R.elementTypes.length > 1 ? n([p([y(["(", l]), V]), l, y(")")]) : n(q ? p(V) : V);
  }
  function o(b, B, k) {
    let M = b.getValue(), R = [], q = b.getParentNode(0), J2 = b.getParentNode(1), L = b.getParentNode(2), Q2 = M.type === "TSFunctionType" || !((q.type === "ObjectTypeProperty" || q.type === "ObjectTypeInternalSlot") && !q.variance && !q.optional && c(q) === c(M) || q.type === "ObjectTypeCallProperty" || L && L.type === "DeclareFunction"), V = Q2 && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation"), j = V && Q2 && (q.type === "TypeAnnotation" || q.type === "TSTypeAnnotation") && J2.type === "ArrowFunctionExpression";
    w(q) && (Q2 = true, V = true), j && R.push("(");
    let Y = x(b, k, B, false, true), ie = M.returnType || M.predicate || M.typeAnnotation ? [Q2 ? " => " : ": ", k("returnType"), k("predicate"), k("typeAnnotation")] : "", ee = I(M, ie);
    return R.push(ee ? n(Y) : Y), ie && R.push(ie), j && R.push(")"), n(R);
  }
  function h(b, B, k) {
    let M = b.getValue(), R = M.type === "TSTupleType" ? "elementTypes" : "types", q = M[R], J2 = a(q), L = J2 ? l : "";
    return n(["[", p([L, P(b, B, R, k)]), y(J2 && F(B, "all") ? "," : ""), s(b, B, true), L, "]"]);
  }
  function v(b, B, k) {
    let M = b.getValue(), R = M.type === "OptionalIndexedAccessType" && M.optional ? "?.[" : "[";
    return [k("objectType"), R, k("indexType"), "]"];
  }
  function S(b, B, k) {
    let M = b.getValue();
    return [M.postfix ? "" : k, B("typeAnnotation"), M.postfix ? k : ""];
  }
  r.exports = { printOpaqueType: D, printTypeAlias: T, printIntersectionType: m, printUnionType: C, printFunctionType: o, printTupleType: h, printIndexedAccessType: v, shouldHugType: $2, printJSDocType: S };
} });
var Lr = te({ "src/language-js/print/type-parameters.js"(e, r) {
  "use strict";
  ne();
  var { printDanglingComments: t } = et(), { builders: { join: s, line: a, hardline: n, softline: u, group: i, indent: l, ifBreak: p } } = qe(), { isTestCall: d, hasComment: y, CommentCheckFlags: g, isTSXFile: c, shouldPrintComma: f, getFunctionParameters: E2, isObjectType: _, getTypeScriptMappedTypeModifier: w } = Ke(), { createGroupIdMapper: F } = Ue(), { shouldHugType: N } = kr(), { isArrowFunctionVariableDeclarator: x } = Zt(), I = F("typeParameters");
  function P(T, m, C, o) {
    let h = T.getValue();
    if (!h[o]) return "";
    if (!Array.isArray(h[o])) return C(o);
    let v = T.getNode(2), S = v && d(v), b = T.match((M) => !(M[o].length === 1 && _(M[o][0])), void 0, (M, R) => R === "typeAnnotation", (M) => M.type === "Identifier", x);
    if (h[o].length === 0 || !b && (S || h[o].length === 1 && (h[o][0].type === "NullableTypeAnnotation" || N(h[o][0])))) return ["<", s(", ", T.map(C, o)), $2(T, m), ">"];
    let k = h.type === "TSTypeParameterInstantiation" ? "" : E2(h).length === 1 && c(m) && !h[o][0].constraint && T.getParentNode().type === "ArrowFunctionExpression" ? "," : f(m, "all") ? p(",") : "";
    return i(["<", l([u, s([",", a], T.map(C, o))]), k, u, ">"], { id: I(h) });
  }
  function $2(T, m) {
    let C = T.getValue();
    if (!y(C, g.Dangling)) return "";
    let o = !y(C, g.Line), h = t(T, m, o);
    return o ? h : [h, n];
  }
  function D(T, m, C) {
    let o = T.getValue(), h = [o.type === "TSTypeParameter" && o.const ? "const " : ""], v = T.getParentNode();
    return v.type === "TSMappedType" ? (v.readonly && h.push(w(v.readonly, "readonly"), " "), h.push("[", C("name")), o.constraint && h.push(" in ", C("constraint")), v.nameType && h.push(" as ", T.callParent(() => C("nameType"))), h.push("]"), h) : (o.variance && h.push(C("variance")), o.in && h.push("in "), o.out && h.push("out "), h.push(C("name")), o.bound && h.push(": ", C("bound")), o.constraint && h.push(" extends ", C("constraint")), o.default && h.push(" = ", C("default")), h);
  }
  r.exports = { printTypeParameter: D, printTypeParameters: P, getTypeParametersGroupId: I };
} });
var er = te({ "src/language-js/print/property.js"(e, r) {
  "use strict";
  ne();
  var { printComments: t } = et(), { printString: s, printNumber: a } = Ue(), { isNumericLiteral: n, isSimpleNumber: u, isStringLiteral: i, isStringPropSafeToUnquote: l, rawText: p } = Ke(), { printAssignment: d } = Zt(), y = /* @__PURE__ */ new WeakMap();
  function g(f, E2, _) {
    let w = f.getNode();
    if (w.computed) return ["[", _("key"), "]"];
    let F = f.getParentNode(), { key: N } = w;
    if (E2.quoteProps === "consistent" && !y.has(F)) {
      let x = (F.properties || F.body || F.members).some((I) => !I.computed && I.key && i(I.key) && !l(I, E2));
      y.set(F, x);
    }
    if ((N.type === "Identifier" || n(N) && u(a(p(N))) && String(N.value) === a(p(N)) && !(E2.parser === "typescript" || E2.parser === "babel-ts")) && (E2.parser === "json" || E2.quoteProps === "consistent" && y.get(F))) {
      let x = s(JSON.stringify(N.type === "Identifier" ? N.name : N.value.toString()), E2);
      return f.call((I) => t(I, x, E2), "key");
    }
    return l(w, E2) && (E2.quoteProps === "as-needed" || E2.quoteProps === "consistent" && !y.get(F)) ? f.call((x) => t(x, /^\d/.test(N.value) ? a(N.value) : N.value, E2), "key") : _("key");
  }
  function c(f, E2, _) {
    return f.getValue().shorthand ? _("value") : d(f, E2, _, g(f, E2, _), ":", "value");
  }
  r.exports = { printProperty: c, printPropertyKey: g };
} });
var Or = te({ "src/language-js/print/function.js"(e, r) {
  "use strict";
  ne();
  var t = Yt(), { printDanglingComments: s, printCommentsSeparately: a } = et(), n = lt(), { getNextNonSpaceNonCommentCharacterIndex: u } = Ue(), { builders: { line: i, softline: l, group: p, indent: d, ifBreak: y, hardline: g, join: c, indentIfBreak: f }, utils: { removeLines: E2, willBreak: _ } } = qe(), { ArgExpansionBailout: w } = Kt(), { getFunctionParameters: F, hasLeadingOwnLineComment: N, isFlowAnnotationComment: x, isJsxNode: I, isTemplateOnItsOwnLine: P, shouldPrintComma: $2, startsWithNoLookaheadToken: D, isBinaryish: T, isLineComment: m, hasComment: C, getComments: o, CommentCheckFlags: h, isCallLikeExpression: v, isCallExpression: S, getCallArguments: b, hasNakedLeftSide: B, getLeftSide: k } = Ke(), { locEnd: M } = ut(), { printFunctionParameters: R, shouldGroupFunctionParameters: q } = Ir(), { printPropertyKey: J2 } = er(), { printFunctionTypeParameters: L } = ct();
  function Q2(U, Z, se, fe) {
    let ge = U.getValue(), he = false;
    if ((ge.type === "FunctionDeclaration" || ge.type === "FunctionExpression") && fe && fe.expandLastArg) {
      let Pe2 = U.getParentNode();
      S(Pe2) && b(Pe2).length > 1 && (he = true);
    }
    let we = [];
    ge.type === "TSDeclareFunction" && ge.declare && we.push("declare "), ge.async && we.push("async "), ge.generator ? we.push("function* ") : we.push("function "), ge.id && we.push(Z("id"));
    let ke = R(U, Z, se, he), Re = K(U, Z, se), Ne = q(ge, Re);
    return we.push(L(U, se, Z), p([Ne ? p(ke) : ke, Re]), ge.body ? " " : "", Z("body")), se.semi && (ge.declare || !ge.body) && we.push(";"), we;
  }
  function V(U, Z, se) {
    let fe = U.getNode(), { kind: ge } = fe, he = fe.value || fe, we = [];
    return !ge || ge === "init" || ge === "method" || ge === "constructor" ? he.async && we.push("async ") : (t.ok(ge === "get" || ge === "set"), we.push(ge, " ")), he.generator && we.push("*"), we.push(J2(U, Z, se), fe.optional || fe.key.optional ? "?" : ""), fe === he ? we.push(j(U, Z, se)) : he.type === "FunctionExpression" ? we.push(U.call((ke) => j(ke, Z, se), "value")) : we.push(se("value")), we;
  }
  function j(U, Z, se) {
    let fe = U.getNode(), ge = R(U, se, Z), he = K(U, se, Z), we = q(fe, he), ke = [L(U, Z, se), p([we ? p(ge) : ge, he])];
    return fe.body ? ke.push(" ", se("body")) : ke.push(Z.semi ? ";" : ""), ke;
  }
  function Y(U, Z, se, fe) {
    let ge = U.getValue(), he = [];
    if (ge.async && he.push("async "), W(U, Z)) he.push(se(["params", 0]));
    else {
      let ke = fe && (fe.expandLastArg || fe.expandFirstArg), Re = K(U, se, Z);
      if (ke) {
        if (_(Re)) throw new w();
        Re = p(E2(Re));
      }
      he.push(p([R(U, se, Z, ke, true), Re]));
    }
    let we = s(U, Z, true, (ke) => {
      let Re = u(Z.originalText, ke, M);
      return Re !== false && Z.originalText.slice(Re, Re + 2) === "=>";
    });
    return we && he.push(" ", we), he;
  }
  function ie(U, Z, se, fe, ge, he) {
    let we = U.getName(), ke = U.getParentNode(), Re = v(ke) && we === "callee", Ne = Boolean(Z && Z.assignmentLayout), Pe2 = he.body.type !== "BlockStatement" && he.body.type !== "ObjectExpression" && he.body.type !== "SequenceExpression", oe2 = Re && Pe2 || Z && Z.assignmentLayout === "chain-tail-arrow-chain", H = Symbol("arrow-chain");
    return he.body.type === "SequenceExpression" && (ge = p(["(", d([l, ge]), l, ")"])), p([p(d([Re || Ne ? l : "", p(c([" =>", i], se), { shouldBreak: fe })]), { id: H, shouldBreak: oe2 }), " =>", f(Pe2 ? d([i, ge]) : [" ", ge], { groupId: H }), Re ? y(l, "", { groupId: H }) : ""]);
  }
  function ee(U, Z, se, fe) {
    let ge = U.getValue(), he = [], we = [], ke = false;
    if (function H() {
      let pe = Y(U, Z, se, fe);
      if (he.length === 0) he.push(pe);
      else {
        let { leading: X, trailing: le2 } = a(U, Z);
        he.push([X, pe]), we.unshift(le2);
      }
      ke = ke || ge.returnType && F(ge).length > 0 || ge.typeParameters || F(ge).some((X) => X.type !== "Identifier"), ge.body.type !== "ArrowFunctionExpression" || fe && fe.expandLastArg ? we.unshift(se("body", fe)) : (ge = ge.body, U.call(H, "body"));
    }(), he.length > 1) return ie(U, fe, he, ke, we, ge);
    let Re = he;
    if (Re.push(" =>"), !N(Z.originalText, ge.body) && (ge.body.type === "ArrayExpression" || ge.body.type === "ObjectExpression" || ge.body.type === "BlockStatement" || I(ge.body) || P(ge.body, Z.originalText) || ge.body.type === "ArrowFunctionExpression" || ge.body.type === "DoExpression")) return p([...Re, " ", we]);
    if (ge.body.type === "SequenceExpression") return p([...Re, p([" (", d([l, we]), l, ")"])]);
    let Ne = (fe && fe.expandLastArg || U.getParentNode().type === "JSXExpressionContainer") && !C(ge), Pe2 = fe && fe.expandLastArg && $2(Z, "all"), oe2 = ge.body.type === "ConditionalExpression" && !D(ge.body, (H) => H.type === "ObjectExpression");
    return p([...Re, p([d([i, oe2 ? y("", "(") : "", we, oe2 ? y("", ")") : ""]), Ne ? [y(Pe2 ? "," : ""), l] : ""])]);
  }
  function ce(U) {
    let Z = F(U);
    return Z.length === 1 && !U.typeParameters && !C(U, h.Dangling) && Z[0].type === "Identifier" && !Z[0].typeAnnotation && !C(Z[0]) && !Z[0].optional && !U.predicate && !U.returnType;
  }
  function W(U, Z) {
    if (Z.arrowParens === "always") return false;
    if (Z.arrowParens === "avoid") {
      let se = U.getValue();
      return ce(se);
    }
    return false;
  }
  function K(U, Z, se) {
    let fe = U.getValue(), ge = Z("returnType");
    if (fe.returnType && x(se.originalText, fe.returnType)) return [" /*: ", ge, " */"];
    let he = [ge];
    return fe.returnType && fe.returnType.typeAnnotation && he.unshift(": "), fe.predicate && he.push(fe.returnType ? " " : ": ", Z("predicate")), he;
  }
  function de(U, Z, se) {
    let fe = U.getValue(), ge = Z.semi ? ";" : "", he = [];
    fe.argument && (z(Z, fe.argument) ? he.push([" (", d([g, se("argument")]), g, ")"]) : T(fe.argument) || fe.argument.type === "SequenceExpression" ? he.push(p([y(" (", " "), d([l, se("argument")]), l, y(")")])) : he.push(" ", se("argument")));
    let we = o(fe), ke = n(we), Re = ke && m(ke);
    return Re && he.push(ge), C(fe, h.Dangling) && he.push(" ", s(U, Z, true)), Re || he.push(ge), he;
  }
  function ue(U, Z, se) {
    return ["return", de(U, Z, se)];
  }
  function Fe(U, Z, se) {
    return ["throw", de(U, Z, se)];
  }
  function z(U, Z) {
    if (N(U.originalText, Z)) return true;
    if (B(Z)) {
      let se = Z, fe;
      for (; fe = k(se); ) if (se = fe, N(U.originalText, se)) return true;
    }
    return false;
  }
  r.exports = { printFunction: Q2, printArrowFunction: ee, printMethod: V, printReturnStatement: ue, printThrowStatement: Fe, printMethodInternal: j, shouldPrintParamsWithoutParens: W };
} });
var eu = te({ "src/language-js/print/decorators.js"(e, r) {
  "use strict";
  ne();
  var { isNonEmptyArray: t, hasNewline: s } = Ue(), { builders: { line: a, hardline: n, join: u, breakParent: i, group: l } } = qe(), { locStart: p, locEnd: d } = ut(), { getParentExportDeclaration: y } = Ke();
  function g(w, F, N) {
    let x = w.getValue();
    return l([u(a, w.map(N, "decorators")), E2(x, F) ? n : a]);
  }
  function c(w, F, N) {
    return [u(n, w.map(N, "declaration", "decorators")), n];
  }
  function f(w, F, N) {
    let x = w.getValue(), { decorators: I } = x;
    if (!t(I) || _(w.getParentNode())) return;
    let P = x.type === "ClassExpression" || x.type === "ClassDeclaration" || E2(x, F);
    return [y(w) ? n : P ? i : "", u(a, w.map(N, "decorators")), a];
  }
  function E2(w, F) {
    return w.decorators.some((N) => s(F.originalText, d(N)));
  }
  function _(w) {
    if (w.type !== "ExportDefaultDeclaration" && w.type !== "ExportNamedDeclaration" && w.type !== "DeclareExportDeclaration") return false;
    let F = w.declaration && w.declaration.decorators;
    return t(F) && p(w) === p(F[0]);
  }
  r.exports = { printDecorators: f, printClassMemberDecorators: g, printDecoratorsBeforeExport: c, hasDecoratorsBeforeExport: _ };
} });
var tr = te({ "src/language-js/print/class.js"(e, r) {
  "use strict";
  ne();
  var { isNonEmptyArray: t, createGroupIdMapper: s } = Ue(), { printComments: a, printDanglingComments: n } = et(), { builders: { join: u, line: i, hardline: l, softline: p, group: d, indent: y, ifBreak: g } } = qe(), { hasComment: c, CommentCheckFlags: f } = Ke(), { getTypeParametersGroupId: E2 } = Lr(), { printMethod: _ } = Or(), { printOptionalToken: w, printTypeAnnotation: F, printDefiniteToken: N } = ct(), { printPropertyKey: x } = er(), { printAssignment: I } = Zt(), { printClassMemberDecorators: P } = eu();
  function $2(b, B, k) {
    let M = b.getValue(), R = [];
    M.declare && R.push("declare "), M.abstract && R.push("abstract "), R.push("class");
    let q = M.id && c(M.id, f.Trailing) || M.typeParameters && c(M.typeParameters, f.Trailing) || M.superClass && c(M.superClass) || t(M.extends) || t(M.mixins) || t(M.implements), J2 = [], L = [];
    if (M.id && J2.push(" ", k("id")), J2.push(k("typeParameters")), M.superClass) {
      let Q2 = [h(b, B, k), k("superTypeParameters")], V = b.call((j) => ["extends ", a(j, Q2, B)], "superClass");
      q ? L.push(i, d(V)) : L.push(" ", V);
    } else L.push(o(b, B, k, "extends"));
    if (L.push(o(b, B, k, "mixins"), o(b, B, k, "implements")), q) {
      let Q2;
      C(M) ? Q2 = [...J2, y(L)] : Q2 = y([...J2, L]), R.push(d(Q2, { id: D(M) }));
    } else R.push(...J2, ...L);
    return R.push(" ", k("body")), R;
  }
  var D = s("heritageGroup");
  function T(b) {
    return g(l, "", { groupId: D(b) });
  }
  function m(b) {
    return ["superClass", "extends", "mixins", "implements"].filter((B) => Boolean(b[B])).length > 1;
  }
  function C(b) {
    return b.typeParameters && !c(b.typeParameters, f.Trailing | f.Line) && !m(b);
  }
  function o(b, B, k, M) {
    let R = b.getValue();
    if (!t(R[M])) return "";
    let q = n(b, B, true, (J2) => {
      let { marker: L } = J2;
      return L === M;
    });
    return [C(R) ? g(" ", i, { groupId: E2(R.typeParameters) }) : i, q, q && l, M, d(y([i, u([",", i], b.map(k, M))]))];
  }
  function h(b, B, k) {
    let M = k("superClass");
    return b.getParentNode().type === "AssignmentExpression" ? d(g(["(", y([p, M]), p, ")"], M)) : M;
  }
  function v(b, B, k) {
    let M = b.getValue(), R = [];
    return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.readonly && R.push("readonly "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractMethodDefinition" || M.abstract) && R.push("abstract "), M.override && R.push("override "), R.push(_(b, B, k)), R;
  }
  function S(b, B, k) {
    let M = b.getValue(), R = [], q = B.semi ? ";" : "";
    return t(M.decorators) && R.push(P(b, B, k)), M.accessibility && R.push(M.accessibility + " "), M.declare && R.push("declare "), M.static && R.push("static "), (M.type === "TSAbstractPropertyDefinition" || M.type === "TSAbstractAccessorProperty" || M.abstract) && R.push("abstract "), M.override && R.push("override "), M.readonly && R.push("readonly "), M.variance && R.push(k("variance")), (M.type === "ClassAccessorProperty" || M.type === "AccessorProperty" || M.type === "TSAbstractAccessorProperty") && R.push("accessor "), R.push(x(b, B, k), w(b), N(b), F(b, B, k)), [I(b, B, k, R, " =", "value"), q];
  }
  r.exports = { printClass: $2, printClassMethod: v, printClassProperty: S, printHardlineAfterHeritage: T };
} });
var ho = te({ "src/language-js/print/interface.js"(e, r) {
  "use strict";
  ne();
  var { isNonEmptyArray: t } = Ue(), { builders: { join: s, line: a, group: n, indent: u, ifBreak: i } } = qe(), { hasComment: l, identity: p, CommentCheckFlags: d } = Ke(), { getTypeParametersGroupId: y } = Lr(), { printTypeScriptModifiers: g } = ct();
  function c(f, E2, _) {
    let w = f.getValue(), F = [];
    w.declare && F.push("declare "), w.type === "TSInterfaceDeclaration" && F.push(w.abstract ? "abstract " : "", g(f, E2, _)), F.push("interface");
    let N = [], x = [];
    w.type !== "InterfaceTypeAnnotation" && N.push(" ", _("id"), _("typeParameters"));
    let I = w.typeParameters && !l(w.typeParameters, d.Trailing | d.Line);
    return t(w.extends) && x.push(I ? i(" ", a, { groupId: y(w.typeParameters) }) : a, "extends ", (w.extends.length === 1 ? p : u)(s([",", a], f.map(_, "extends")))), w.id && l(w.id, d.Trailing) || t(w.extends) ? I ? F.push(n([...N, u(x)])) : F.push(n(u([...N, ...x]))) : F.push(...N, ...x), F.push(" ", _("body")), n(F);
  }
  r.exports = { printInterface: c };
} });
var vo = te({ "src/language-js/print/module.js"(e, r) {
  "use strict";
  ne();
  var { isNonEmptyArray: t } = Ue(), { builders: { softline: s, group: a, indent: n, join: u, line: i, ifBreak: l, hardline: p } } = qe(), { printDanglingComments: d } = et(), { hasComment: y, CommentCheckFlags: g, shouldPrintComma: c, needsHardlineAfterDanglingComment: f, isStringLiteral: E2, rawText: _ } = Ke(), { locStart: w, hasSameLoc: F } = ut(), { hasDecoratorsBeforeExport: N, printDecoratorsBeforeExport: x } = eu();
  function I(S, b, B) {
    let k = S.getValue(), M = b.semi ? ";" : "", R = [], { importKind: q } = k;
    return R.push("import"), q && q !== "value" && R.push(" ", q), R.push(m(S, b, B), T(S, b, B), o(S, b, B), M), R;
  }
  function P(S, b, B) {
    let k = S.getValue(), M = [];
    N(k) && M.push(x(S, b, B));
    let { type: R, exportKind: q, declaration: J2 } = k;
    return M.push("export"), (k.default || R === "ExportDefaultDeclaration") && M.push(" default"), y(k, g.Dangling) && (M.push(" ", d(S, b, true)), f(k) && M.push(p)), J2 ? M.push(" ", B("declaration")) : M.push(q === "type" ? " type" : "", m(S, b, B), T(S, b, B), o(S, b, B)), D(k, b) && M.push(";"), M;
  }
  function $2(S, b, B) {
    let k = S.getValue(), M = b.semi ? ";" : "", R = [], { exportKind: q, exported: J2 } = k;
    return R.push("export"), q === "type" && R.push(" type"), R.push(" *"), J2 && R.push(" as ", B("exported")), R.push(T(S, b, B), o(S, b, B), M), R;
  }
  function D(S, b) {
    if (!b.semi) return false;
    let { type: B, declaration: k } = S, M = S.default || B === "ExportDefaultDeclaration";
    if (!k) return true;
    let { type: R } = k;
    return !!(M && R !== "ClassDeclaration" && R !== "FunctionDeclaration" && R !== "TSInterfaceDeclaration" && R !== "DeclareClass" && R !== "DeclareFunction" && R !== "TSDeclareFunction" && R !== "EnumDeclaration");
  }
  function T(S, b, B) {
    let k = S.getValue();
    if (!k.source) return "";
    let M = [];
    return C(k, b) || M.push(" from"), M.push(" ", B("source")), M;
  }
  function m(S, b, B) {
    let k = S.getValue();
    if (C(k, b)) return "";
    let M = [" "];
    if (t(k.specifiers)) {
      let R = [], q = [];
      S.each(() => {
        let J2 = S.getValue().type;
        if (J2 === "ExportNamespaceSpecifier" || J2 === "ExportDefaultSpecifier" || J2 === "ImportNamespaceSpecifier" || J2 === "ImportDefaultSpecifier") R.push(B());
        else if (J2 === "ExportSpecifier" || J2 === "ImportSpecifier") q.push(B());
        else throw new Error(`Unknown specifier type ${JSON.stringify(J2)}`);
      }, "specifiers"), M.push(u(", ", R)), q.length > 0 && (R.length > 0 && M.push(", "), q.length > 1 || R.length > 0 || k.specifiers.some((L) => y(L)) ? M.push(a(["{", n([b.bracketSpacing ? i : s, u([",", i], q)]), l(c(b) ? "," : ""), b.bracketSpacing ? i : s, "}"])) : M.push(["{", b.bracketSpacing ? " " : "", ...q, b.bracketSpacing ? " " : "", "}"]));
    } else M.push("{}");
    return M;
  }
  function C(S, b) {
    let { type: B, importKind: k, source: M, specifiers: R } = S;
    return B !== "ImportDeclaration" || t(R) || k === "type" ? false : !/{\s*}/.test(b.originalText.slice(w(S), w(M)));
  }
  function o(S, b, B) {
    let k = S.getNode();
    return t(k.assertions) ? [" assert {", b.bracketSpacing ? " " : "", u(", ", S.map(B, "assertions")), b.bracketSpacing ? " " : "", "}"] : "";
  }
  function h(S, b, B) {
    let k = S.getNode(), { type: M } = k, R = [], q = M === "ImportSpecifier" ? k.importKind : k.exportKind;
    q && q !== "value" && R.push(q, " ");
    let J2 = M.startsWith("Import"), L = J2 ? "imported" : "local", Q2 = J2 ? "local" : "exported", V = k[L], j = k[Q2], Y = "", ie = "";
    return M === "ExportNamespaceSpecifier" || M === "ImportNamespaceSpecifier" ? Y = "*" : V && (Y = B(L)), j && !v(k) && (ie = B(Q2)), R.push(Y, Y && ie ? " as " : "", ie), R;
  }
  function v(S) {
    if (S.type !== "ImportSpecifier" && S.type !== "ExportSpecifier") return false;
    let { local: b, [S.type === "ImportSpecifier" ? "imported" : "exported"]: B } = S;
    if (b.type !== B.type || !F(b, B)) return false;
    if (E2(b)) return b.value === B.value && _(b) === _(B);
    switch (b.type) {
      case "Identifier":
        return b.name === B.name;
      default:
        return false;
    }
  }
  r.exports = { printImportDeclaration: I, printExportDeclaration: P, printExportAllDeclaration: $2, printModuleSpecifier: h };
} });
var tu = te({ "src/language-js/print/object.js"(e, r) {
  "use strict";
  ne();
  var { printDanglingComments: t } = et(), { builders: { line: s, softline: a, group: n, indent: u, ifBreak: i, hardline: l } } = qe(), { getLast: p, hasNewlineInRange: d, hasNewline: y, isNonEmptyArray: g } = Ue(), { shouldPrintComma: c, hasComment: f, getComments: E2, CommentCheckFlags: _, isNextLineEmpty: w } = Ke(), { locStart: F, locEnd: N } = ut(), { printOptionalToken: x, printTypeAnnotation: I } = ct(), { shouldHugFunctionParameters: P } = Ir(), { shouldHugType: $2 } = kr(), { printHardlineAfterHeritage: D } = tr();
  function T(m, C, o) {
    let h = C.semi ? ";" : "", v = m.getValue(), S;
    v.type === "TSTypeLiteral" ? S = "members" : v.type === "TSInterfaceBody" ? S = "body" : S = "properties";
    let b = v.type === "ObjectTypeAnnotation", B = [S];
    b && B.push("indexers", "callProperties", "internalSlots");
    let k = B.map((W) => v[W][0]).sort((W, K) => F(W) - F(K))[0], M = m.getParentNode(0), R = b && M && (M.type === "InterfaceDeclaration" || M.type === "DeclareInterface" || M.type === "DeclareClass") && m.getName() === "body", q = v.type === "TSInterfaceBody" || R || v.type === "ObjectPattern" && M.type !== "FunctionDeclaration" && M.type !== "FunctionExpression" && M.type !== "ArrowFunctionExpression" && M.type !== "ObjectMethod" && M.type !== "ClassMethod" && M.type !== "ClassPrivateMethod" && M.type !== "AssignmentPattern" && M.type !== "CatchClause" && v.properties.some((W) => W.value && (W.value.type === "ObjectPattern" || W.value.type === "ArrayPattern")) || v.type !== "ObjectPattern" && k && d(C.originalText, F(v), F(k)), J2 = R ? ";" : v.type === "TSInterfaceBody" || v.type === "TSTypeLiteral" ? i(h, ";") : ",", L = v.type === "RecordExpression" ? "#{" : v.exact ? "{|" : "{", Q2 = v.exact ? "|}" : "}", V = [];
    for (let W of B) m.each((K) => {
      let de = K.getValue();
      V.push({ node: de, printed: o(), loc: F(de) });
    }, W);
    B.length > 1 && V.sort((W, K) => W.loc - K.loc);
    let j = [], Y = V.map((W) => {
      let K = [...j, n(W.printed)];
      return j = [J2, s], (W.node.type === "TSPropertySignature" || W.node.type === "TSMethodSignature" || W.node.type === "TSConstructSignatureDeclaration") && f(W.node, _.PrettierIgnore) && j.shift(), w(W.node, C) && j.push(l), K;
    });
    if (v.inexact) {
      let W;
      if (f(v, _.Dangling)) {
        let K = f(v, _.Line);
        W = [t(m, C, true), K || y(C.originalText, N(p(E2(v)))) ? l : s, "..."];
      } else W = ["..."];
      Y.push([...j, ...W]);
    }
    let ie = p(v[S]), ee = !(v.inexact || ie && ie.type === "RestElement" || ie && (ie.type === "TSPropertySignature" || ie.type === "TSCallSignatureDeclaration" || ie.type === "TSMethodSignature" || ie.type === "TSConstructSignatureDeclaration") && f(ie, _.PrettierIgnore)), ce;
    if (Y.length === 0) {
      if (!f(v, _.Dangling)) return [L, Q2, I(m, C, o)];
      ce = n([L, t(m, C), a, Q2, x(m), I(m, C, o)]);
    } else ce = [R && g(v.properties) ? D(M) : "", L, u([C.bracketSpacing ? s : a, ...Y]), i(ee && (J2 !== "," || c(C)) ? J2 : ""), C.bracketSpacing ? s : a, Q2, x(m), I(m, C, o)];
    return m.match((W) => W.type === "ObjectPattern" && !W.decorators, (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || m.match($2, (W, K) => K === "typeAnnotation", (W, K) => K === "typeAnnotation", (W, K, de) => P(W) && (K === "params" || K === "parameters" || K === "this" || K === "rest") && de === 0) || !q && m.match((W) => W.type === "ObjectPattern", (W) => W.type === "AssignmentExpression" || W.type === "VariableDeclarator") ? ce : n(ce, { shouldBreak: q });
  }
  r.exports = { printObject: T };
} });
var id = te({ "src/language-js/print/flow.js"(e, r) {
  "use strict";
  ne();
  var t = Yt(), { printDanglingComments: s } = et(), { printString: a, printNumber: n } = Ue(), { builders: { hardline: u, softline: i, group: l, indent: p } } = qe(), { getParentExportDeclaration: d, isFunctionNotation: y, isGetterOrSetter: g, rawText: c, shouldPrintComma: f } = Ke(), { locStart: E2, locEnd: _ } = ut(), { replaceTextEndOfLine: w } = Xt(), { printClass: F } = tr(), { printOpaqueType: N, printTypeAlias: x, printIntersectionType: I, printUnionType: P, printFunctionType: $2, printTupleType: D, printIndexedAccessType: T } = kr(), { printInterface: m } = ho(), { printTypeParameter: C, printTypeParameters: o } = Lr(), { printExportDeclaration: h, printExportAllDeclaration: v } = vo(), { printArrayItems: S } = Qt(), { printObject: b } = tu(), { printPropertyKey: B } = er(), { printOptionalToken: k, printTypeAnnotation: M, printRestSpread: R } = ct();
  function q(L, Q2, V) {
    let j = L.getValue(), Y = Q2.semi ? ";" : "", ie = [];
    switch (j.type) {
      case "DeclareClass":
        return J2(L, F(L, Q2, V));
      case "DeclareFunction":
        return J2(L, ["function ", V("id"), j.predicate ? " " : "", V("predicate"), Y]);
      case "DeclareModule":
        return J2(L, ["module ", V("id"), " ", V("body")]);
      case "DeclareModuleExports":
        return J2(L, ["module.exports", ": ", V("typeAnnotation"), Y]);
      case "DeclareVariable":
        return J2(L, ["var ", V("id"), Y]);
      case "DeclareOpaqueType":
        return J2(L, N(L, Q2, V));
      case "DeclareInterface":
        return J2(L, m(L, Q2, V));
      case "DeclareTypeAlias":
        return J2(L, x(L, Q2, V));
      case "DeclareExportDeclaration":
        return J2(L, h(L, Q2, V));
      case "DeclareExportAllDeclaration":
        return J2(L, v(L, Q2, V));
      case "OpaqueType":
        return N(L, Q2, V);
      case "TypeAlias":
        return x(L, Q2, V);
      case "IntersectionTypeAnnotation":
        return I(L, Q2, V);
      case "UnionTypeAnnotation":
        return P(L, Q2, V);
      case "FunctionTypeAnnotation":
        return $2(L, Q2, V);
      case "TupleTypeAnnotation":
        return D(L, Q2, V);
      case "GenericTypeAnnotation":
        return [V("id"), o(L, Q2, V, "typeParameters")];
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        return T(L, Q2, V);
      case "TypeAnnotation":
        return V("typeAnnotation");
      case "TypeParameter":
        return C(L, Q2, V);
      case "TypeofTypeAnnotation":
        return ["typeof ", V("argument")];
      case "ExistsTypeAnnotation":
        return "*";
      case "EmptyTypeAnnotation":
        return "empty";
      case "MixedTypeAnnotation":
        return "mixed";
      case "ArrayTypeAnnotation":
        return [V("elementType"), "[]"];
      case "BooleanLiteralTypeAnnotation":
        return String(j.value);
      case "EnumDeclaration":
        return ["enum ", V("id"), " ", V("body")];
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody": {
        if (j.type === "EnumSymbolBody" || j.explicitType) {
          let ee = null;
          switch (j.type) {
            case "EnumBooleanBody":
              ee = "boolean";
              break;
            case "EnumNumberBody":
              ee = "number";
              break;
            case "EnumStringBody":
              ee = "string";
              break;
            case "EnumSymbolBody":
              ee = "symbol";
              break;
          }
          ie.push("of ", ee, " ");
        }
        if (j.members.length === 0 && !j.hasUnknownMembers) ie.push(l(["{", s(L, Q2), i, "}"]));
        else {
          let ee = j.members.length > 0 ? [u, S(L, Q2, "members", V), j.hasUnknownMembers || f(Q2) ? "," : ""] : [];
          ie.push(l(["{", p([...ee, ...j.hasUnknownMembers ? [u, "..."] : []]), s(L, Q2, true), u, "}"]));
        }
        return ie;
      }
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
        return [V("id"), " = ", typeof j.init == "object" ? V("init") : String(j.init)];
      case "EnumDefaultedMember":
        return V("id");
      case "FunctionTypeParam": {
        let ee = j.name ? V("name") : L.getParentNode().this === j ? "this" : "";
        return [ee, k(L), ee ? ": " : "", V("typeAnnotation")];
      }
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
        return m(L, Q2, V);
      case "ClassImplements":
      case "InterfaceExtends":
        return [V("id"), V("typeParameters")];
      case "NullableTypeAnnotation":
        return ["?", V("typeAnnotation")];
      case "Variance": {
        let { kind: ee } = j;
        return t.ok(ee === "plus" || ee === "minus"), ee === "plus" ? "+" : "-";
      }
      case "ObjectTypeCallProperty":
        return j.static && ie.push("static "), ie.push(V("value")), ie;
      case "ObjectTypeIndexer":
        return [j.static ? "static " : "", j.variance ? V("variance") : "", "[", V("id"), j.id ? ": " : "", V("key"), "]: ", V("value")];
      case "ObjectTypeProperty": {
        let ee = "";
        return j.proto ? ee = "proto " : j.static && (ee = "static "), [ee, g(j) ? j.kind + " " : "", j.variance ? V("variance") : "", B(L, Q2, V), k(L), y(j) ? "" : ": ", V("value")];
      }
      case "ObjectTypeAnnotation":
        return b(L, Q2, V);
      case "ObjectTypeInternalSlot":
        return [j.static ? "static " : "", "[[", V("id"), "]]", k(L), j.method ? "" : ": ", V("value")];
      case "ObjectTypeSpreadProperty":
        return R(L, Q2, V);
      case "QualifiedTypeofIdentifier":
      case "QualifiedTypeIdentifier":
        return [V("qualification"), ".", V("id")];
      case "StringLiteralTypeAnnotation":
        return w(a(c(j), Q2));
      case "NumberLiteralTypeAnnotation":
        t.strictEqual(typeof j.value, "number");
      case "BigIntLiteralTypeAnnotation":
        return j.extra ? n(j.extra.raw) : n(j.raw);
      case "TypeCastExpression":
        return ["(", V("expression"), M(L, Q2, V), ")"];
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation": {
        let ee = o(L, Q2, V, "params");
        if (Q2.parser === "flow") {
          let ce = E2(j), W = _(j), K = Q2.originalText.lastIndexOf("/*", ce), de = Q2.originalText.indexOf("*/", W);
          if (K !== -1 && de !== -1) {
            let ue = Q2.originalText.slice(K + 2, de).trim();
            if (ue.startsWith("::") && !ue.includes("/*") && !ue.includes("*/")) return ["/*:: ", ee, " */"];
          }
        }
        return ee;
      }
      case "InferredPredicate":
        return "%checks";
      case "DeclaredPredicate":
        return ["%checks(", V("value"), ")"];
      case "AnyTypeAnnotation":
        return "any";
      case "BooleanTypeAnnotation":
        return "boolean";
      case "BigIntTypeAnnotation":
        return "bigint";
      case "NullLiteralTypeAnnotation":
        return "null";
      case "NumberTypeAnnotation":
        return "number";
      case "SymbolTypeAnnotation":
        return "symbol";
      case "StringTypeAnnotation":
        return "string";
      case "VoidTypeAnnotation":
        return "void";
      case "ThisTypeAnnotation":
        return "this";
      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      case "MemberTypeAnnotation":
      case "Type":
        throw new Error("unprintable type: " + JSON.stringify(j.type));
    }
  }
  function J2(L, Q2) {
    let V = d(L);
    return V ? (t.strictEqual(V.type, "DeclareExportDeclaration"), Q2) : ["declare ", Q2];
  }
  r.exports = { printFlow: q };
} });
var ad = te({ "src/language-js/utils/is-ts-keyword-type.js"(e, r) {
  "use strict";
  ne();
  function t(s) {
    let { type: a } = s;
    return a.startsWith("TS") && a.endsWith("Keyword");
  }
  r.exports = t;
} });
var Co = te({ "src/language-js/print/ternary.js"(e, r) {
  "use strict";
  ne();
  var { hasNewlineInRange: t } = Ue(), { isJsxNode: s, getComments: a, isCallExpression: n, isMemberExpression: u, isTSTypeExpression: i } = Ke(), { locStart: l, locEnd: p } = ut(), d = _t(), { builders: { line: y, softline: g, group: c, indent: f, align: E2, ifBreak: _, dedent: w, breakParent: F } } = qe();
  function N(D) {
    let T = [D];
    for (let m = 0; m < T.length; m++) {
      let C = T[m];
      for (let o of ["test", "consequent", "alternate"]) {
        let h = C[o];
        if (s(h)) return true;
        h.type === "ConditionalExpression" && T.push(h);
      }
    }
    return false;
  }
  function x(D, T, m) {
    let C = D.getValue(), o = C.type === "ConditionalExpression", h = o ? "alternate" : "falseType", v = D.getParentNode(), S = o ? m("test") : [m("checkType"), " ", "extends", " ", m("extendsType")];
    return v.type === C.type && v[h] === C ? E2(2, S) : S;
  }
  var I = /* @__PURE__ */ new Map([["AssignmentExpression", "right"], ["VariableDeclarator", "init"], ["ReturnStatement", "argument"], ["ThrowStatement", "argument"], ["UnaryExpression", "argument"], ["YieldExpression", "argument"]]);
  function P(D) {
    let T = D.getValue();
    if (T.type !== "ConditionalExpression") return false;
    let m, C = T;
    for (let o = 0; !m; o++) {
      let h = D.getParentNode(o);
      if (n(h) && h.callee === C || u(h) && h.object === C || h.type === "TSNonNullExpression" && h.expression === C) {
        C = h;
        continue;
      }
      h.type === "NewExpression" && h.callee === C || i(h) && h.expression === C ? (m = D.getParentNode(o + 1), C = h) : m = h;
    }
    return C === T ? false : m[I.get(m.type)] === C;
  }
  function $2(D, T, m) {
    let C = D.getValue(), o = C.type === "ConditionalExpression", h = o ? "consequent" : "trueType", v = o ? "alternate" : "falseType", S = o ? ["test"] : ["checkType", "extendsType"], b = C[h], B = C[v], k = [], M = false, R = D.getParentNode(), q = R.type === C.type && S.some((ue) => R[ue] === C), J2 = R.type === C.type && !q, L, Q2, V = 0;
    do
      Q2 = L || C, L = D.getParentNode(V), V++;
    while (L && L.type === C.type && S.every((ue) => L[ue] !== Q2));
    let j = L || R, Y = Q2;
    if (o && (s(C[S[0]]) || s(b) || s(B) || N(Y))) {
      M = true, J2 = true;
      let ue = (z) => [_("("), f([g, z]), g, _(")")], Fe = (z) => z.type === "NullLiteral" || z.type === "Literal" && z.value === null || z.type === "Identifier" && z.name === "undefined";
      k.push(" ? ", Fe(b) ? m(h) : ue(m(h)), " : ", B.type === C.type || Fe(B) ? m(v) : ue(m(v)));
    } else {
      let ue = [y, "? ", b.type === C.type ? _("", "(") : "", E2(2, m(h)), b.type === C.type ? _("", ")") : "", y, ": ", B.type === C.type ? m(v) : E2(2, m(v))];
      k.push(R.type !== C.type || R[v] === C || q ? ue : T.useTabs ? w(f(ue)) : E2(Math.max(0, T.tabWidth - 2), ue));
    }
    let ee = [...S.map((ue) => a(C[ue])), a(b), a(B)].flat().some((ue) => d(ue) && t(T.originalText, l(ue), p(ue))), ce = (ue) => R === j ? c(ue, { shouldBreak: ee }) : ee ? [ue, F] : ue, W = !M && (u(R) || R.type === "NGPipeExpression" && R.left === C) && !R.computed, K = P(D), de = ce([x(D, T, m), J2 ? k : f(k), o && W && !K ? g : ""]);
    return q || K ? c([f([g, de]), g]) : de;
  }
  r.exports = { printTernary: $2 };
} });
var Eo = te({ "src/language-js/print/statement.js"(e, r) {
  "use strict";
  ne();
  var { builders: { hardline: t } } = qe(), s = Ot(), { getLeftSidePathName: a, hasNakedLeftSide: n, isJsxNode: u, isTheOnlyJsxElementInMarkdown: i, hasComment: l, CommentCheckFlags: p, isNextLineEmpty: d } = Ke(), { shouldPrintParamsWithoutParens: y } = Or();
  function g(x, I, P, $2) {
    let D = x.getValue(), T = [], m = D.type === "ClassBody", C = c(D[$2]);
    return x.each((o, h, v) => {
      let S = o.getValue();
      if (S.type === "EmptyStatement") return;
      let b = P();
      !I.semi && !m && !i(I, o) && f(o, I) ? l(S, p.Leading) ? T.push(P([], { needsSemi: true })) : T.push(";", b) : T.push(b), !I.semi && m && F(S) && N(S, v[h + 1]) && T.push(";"), S !== C && (T.push(t), d(S, I) && T.push(t));
    }, $2), T;
  }
  function c(x) {
    for (let I = x.length - 1; I >= 0; I--) {
      let P = x[I];
      if (P.type !== "EmptyStatement") return P;
    }
  }
  function f(x, I) {
    return x.getNode().type !== "ExpressionStatement" ? false : x.call(($2) => E2($2, I), "expression");
  }
  function E2(x, I) {
    let P = x.getValue();
    switch (P.type) {
      case "ParenthesizedExpression":
      case "TypeCastExpression":
      case "ArrayExpression":
      case "ArrayPattern":
      case "TemplateLiteral":
      case "TemplateElement":
      case "RegExpLiteral":
        return true;
      case "ArrowFunctionExpression": {
        if (!y(x, I)) return true;
        break;
      }
      case "UnaryExpression": {
        let { prefix: $2, operator: D } = P;
        if ($2 && (D === "+" || D === "-")) return true;
        break;
      }
      case "BindExpression": {
        if (!P.object) return true;
        break;
      }
      case "Literal": {
        if (P.regex) return true;
        break;
      }
      default:
        if (u(P)) return true;
    }
    return s(x, I) ? true : n(P) ? x.call(($2) => E2($2, I), ...a(x, P)) : false;
  }
  function _(x, I, P) {
    return g(x, I, P, "body");
  }
  function w(x, I, P) {
    return g(x, I, P, "consequent");
  }
  var F = (x) => {
    let { type: I } = x;
    return I === "ClassProperty" || I === "PropertyDefinition" || I === "ClassPrivateProperty" || I === "ClassAccessorProperty" || I === "AccessorProperty" || I === "TSAbstractPropertyDefinition" || I === "TSAbstractAccessorProperty";
  };
  function N(x, I) {
    let { type: P, name: $2 } = x.key;
    if (!x.computed && P === "Identifier" && ($2 === "static" || $2 === "get" || $2 === "set" || $2 === "accessor") && !x.value && !x.typeAnnotation) return true;
    if (!I || I.static || I.accessibility) return false;
    if (!I.computed) {
      let D = I.key && I.key.name;
      if (D === "in" || D === "instanceof") return true;
    }
    if (F(I) && I.variance && !I.static && !I.declare) return true;
    switch (I.type) {
      case "ClassProperty":
      case "PropertyDefinition":
      case "TSAbstractPropertyDefinition":
        return I.computed;
      case "MethodDefinition":
      case "TSAbstractMethodDefinition":
      case "ClassMethod":
      case "ClassPrivateMethod": {
        if ((I.value ? I.value.async : I.async) || I.kind === "get" || I.kind === "set") return false;
        let T = I.value ? I.value.generator : I.generator;
        return !!(I.computed || T);
      }
      case "TSIndexSignature":
        return true;
    }
    return false;
  }
  r.exports = { printBody: _, printSwitchCaseConsequent: w };
} });
var Fo = te({ "src/language-js/print/block.js"(e, r) {
  "use strict";
  ne();
  var { printDanglingComments: t } = et(), { isNonEmptyArray: s } = Ue(), { builders: { hardline: a, indent: n } } = qe(), { hasComment: u, CommentCheckFlags: i, isNextLineEmpty: l } = Ke(), { printHardlineAfterHeritage: p } = tr(), { printBody: d } = Eo();
  function y(c, f, E2) {
    let _ = c.getValue(), w = [];
    if (_.type === "StaticBlock" && w.push("static "), _.type === "ClassBody" && s(_.body)) {
      let N = c.getParentNode();
      w.push(p(N));
    }
    w.push("{");
    let F = g(c, f, E2);
    if (F) w.push(n([a, F]), a);
    else {
      let N = c.getParentNode(), x = c.getParentNode(1);
      N.type === "ArrowFunctionExpression" || N.type === "FunctionExpression" || N.type === "FunctionDeclaration" || N.type === "ObjectMethod" || N.type === "ClassMethod" || N.type === "ClassPrivateMethod" || N.type === "ForStatement" || N.type === "WhileStatement" || N.type === "DoWhileStatement" || N.type === "DoExpression" || N.type === "CatchClause" && !x.finalizer || N.type === "TSModuleDeclaration" || N.type === "TSDeclareFunction" || _.type === "StaticBlock" || _.type === "ClassBody" || w.push(a);
    }
    return w.push("}"), w;
  }
  function g(c, f, E2) {
    let _ = c.getValue(), w = s(_.directives), F = _.body.some((I) => I.type !== "EmptyStatement"), N = u(_, i.Dangling);
    if (!w && !F && !N) return "";
    let x = [];
    if (w && c.each((I, P, $2) => {
      x.push(E2()), (P < $2.length - 1 || F || N) && (x.push(a), l(I.getValue(), f) && x.push(a));
    }, "directives"), F && x.push(d(c, f, E2)), N && x.push(t(c, f, true)), _.type === "Program") {
      let I = c.getParentNode();
      (!I || I.type !== "ModuleExpression") && x.push(a);
    }
    return x;
  }
  r.exports = { printBlock: y, printBlockBody: g };
} });
var od = te({ "src/language-js/print/typescript.js"(e, r) {
  "use strict";
  ne();
  var { printDanglingComments: t } = et(), { hasNewlineInRange: s } = Ue(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p, conditionalGroup: d, ifBreak: y } } = qe(), { isStringLiteral: g, getTypeScriptMappedTypeModifier: c, shouldPrintComma: f, isCallExpression: E2, isMemberExpression: _ } = Ke(), w = ad(), { locStart: F, locEnd: N } = ut(), { printOptionalToken: x, printTypeScriptModifiers: I } = ct(), { printTernary: P } = Co(), { printFunctionParameters: $2, shouldGroupFunctionParameters: D } = Ir(), { printTemplateLiteral: T } = Lt(), { printArrayItems: m } = Qt(), { printObject: C } = tu(), { printClassProperty: o, printClassMethod: h } = tr(), { printTypeParameter: v, printTypeParameters: S } = Lr(), { printPropertyKey: b } = er(), { printFunction: B, printMethodInternal: k } = Or(), { printInterface: M } = ho(), { printBlock: R } = Fo(), { printTypeAlias: q, printIntersectionType: J2, printUnionType: L, printFunctionType: Q2, printTupleType: V, printIndexedAccessType: j, printJSDocType: Y } = kr();
  function ie(ee, ce, W) {
    let K = ee.getValue();
    if (!K.type.startsWith("TS")) return;
    if (w(K)) return K.type.slice(2, -7).toLowerCase();
    let de = ce.semi ? ";" : "", ue = [];
    switch (K.type) {
      case "TSThisType":
        return "this";
      case "TSTypeAssertion": {
        let Fe = !(K.expression.type === "ArrayExpression" || K.expression.type === "ObjectExpression"), z = l(["<", p([i, W("typeAnnotation")]), i, ">"]), U = [y("("), p([i, W("expression")]), i, y(")")];
        return Fe ? d([[z, W("expression")], [z, l(U, { shouldBreak: true })], [z, W("expression")]]) : l([z, W("expression")]);
      }
      case "TSDeclareFunction":
        return B(ee, W, ce);
      case "TSExportAssignment":
        return ["export = ", W("expression"), de];
      case "TSModuleBlock":
        return R(ee, ce, W);
      case "TSInterfaceBody":
      case "TSTypeLiteral":
        return C(ee, ce, W);
      case "TSTypeAliasDeclaration":
        return q(ee, ce, W);
      case "TSQualifiedName":
        return a(".", [W("left"), W("right")]);
      case "TSAbstractMethodDefinition":
      case "TSDeclareMethod":
        return h(ee, ce, W);
      case "TSAbstractAccessorProperty":
      case "TSAbstractPropertyDefinition":
        return o(ee, ce, W);
      case "TSInterfaceHeritage":
      case "TSExpressionWithTypeArguments":
        return ue.push(W("expression")), K.typeParameters && ue.push(W("typeParameters")), ue;
      case "TSTemplateLiteralType":
        return T(ee, W, ce);
      case "TSNamedTupleMember":
        return [W("label"), K.optional ? "?" : "", ": ", W("elementType")];
      case "TSRestType":
        return ["...", W("typeAnnotation")];
      case "TSOptionalType":
        return [W("typeAnnotation"), "?"];
      case "TSInterfaceDeclaration":
        return M(ee, ce, W);
      case "TSClassImplements":
        return [W("expression"), W("typeParameters")];
      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return S(ee, ce, W, "params");
      case "TSTypeParameter":
        return v(ee, ce, W);
      case "TSSatisfiesExpression":
      case "TSAsExpression": {
        let Fe = K.type === "TSAsExpression" ? "as" : "satisfies";
        ue.push(W("expression"), ` ${Fe} `, W("typeAnnotation"));
        let z = ee.getParentNode();
        return E2(z) && z.callee === K || _(z) && z.object === K ? l([p([i, ...ue]), i]) : ue;
      }
      case "TSArrayType":
        return [W("elementType"), "[]"];
      case "TSPropertySignature":
        return K.readonly && ue.push("readonly "), ue.push(b(ee, ce, W), x(ee)), K.typeAnnotation && ue.push(": ", W("typeAnnotation")), K.initializer && ue.push(" = ", W("initializer")), ue;
      case "TSParameterProperty":
        return K.accessibility && ue.push(K.accessibility + " "), K.export && ue.push("export "), K.static && ue.push("static "), K.override && ue.push("override "), K.readonly && ue.push("readonly "), ue.push(W("parameter")), ue;
      case "TSTypeQuery":
        return ["typeof ", W("exprName"), W("typeParameters")];
      case "TSIndexSignature": {
        let Fe = ee.getParentNode(), z = K.parameters.length > 1 ? y(f(ce) ? "," : "") : "", U = l([p([i, a([", ", i], ee.map(W, "parameters"))]), z, i]);
        return [K.export ? "export " : "", K.accessibility ? [K.accessibility, " "] : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.declare ? "declare " : "", "[", K.parameters ? U : "", K.typeAnnotation ? "]: " : "]", K.typeAnnotation ? W("typeAnnotation") : "", Fe.type === "ClassBody" ? de : ""];
      }
      case "TSTypePredicate":
        return [K.asserts ? "asserts " : "", W("parameterName"), K.typeAnnotation ? [" is ", W("typeAnnotation")] : ""];
      case "TSNonNullExpression":
        return [W("expression"), "!"];
      case "TSImportType":
        return [K.isTypeOf ? "typeof " : "", "import(", W(K.parameter ? "parameter" : "argument"), ")", K.qualifier ? [".", W("qualifier")] : "", S(ee, ce, W, "typeParameters")];
      case "TSLiteralType":
        return W("literal");
      case "TSIndexedAccessType":
        return j(ee, ce, W);
      case "TSConstructSignatureDeclaration":
      case "TSCallSignatureDeclaration":
      case "TSConstructorType": {
        if (K.type === "TSConstructorType" && K.abstract && ue.push("abstract "), K.type !== "TSCallSignatureDeclaration" && ue.push("new "), ue.push(l($2(ee, W, ce, false, true))), K.returnType || K.typeAnnotation) {
          let Fe = K.type === "TSConstructorType";
          ue.push(Fe ? " => " : ": ", W("returnType"), W("typeAnnotation"));
        }
        return ue;
      }
      case "TSTypeOperator":
        return [K.operator, " ", W("typeAnnotation")];
      case "TSMappedType": {
        let Fe = s(ce.originalText, F(K), N(K));
        return l(["{", p([ce.bracketSpacing ? n : i, W("typeParameter"), K.optional ? c(K.optional, "?") : "", K.typeAnnotation ? ": " : "", W("typeAnnotation"), y(de)]), t(ee, ce, true), ce.bracketSpacing ? n : i, "}"], { shouldBreak: Fe });
      }
      case "TSMethodSignature": {
        let Fe = K.kind && K.kind !== "method" ? `${K.kind} ` : "";
        ue.push(K.accessibility ? [K.accessibility, " "] : "", Fe, K.export ? "export " : "", K.static ? "static " : "", K.readonly ? "readonly " : "", K.abstract ? "abstract " : "", K.declare ? "declare " : "", K.computed ? "[" : "", W("key"), K.computed ? "]" : "", x(ee));
        let z = $2(ee, W, ce, false, true), U = K.returnType ? "returnType" : "typeAnnotation", Z = K[U], se = Z ? W(U) : "", fe = D(K, se);
        return ue.push(fe ? l(z) : z), Z && ue.push(": ", l(se)), l(ue);
      }
      case "TSNamespaceExportDeclaration":
        return ue.push("export as namespace ", W("id")), ce.semi && ue.push(";"), l(ue);
      case "TSEnumDeclaration":
        return K.declare && ue.push("declare "), K.modifiers && ue.push(I(ee, ce, W)), K.const && ue.push("const "), ue.push("enum ", W("id"), " "), K.members.length === 0 ? ue.push(l(["{", t(ee, ce), i, "}"])) : ue.push(l(["{", p([u, m(ee, ce, "members", W), f(ce, "es5") ? "," : ""]), t(ee, ce, true), u, "}"])), ue;
      case "TSEnumMember":
        return K.computed ? ue.push("[", W("id"), "]") : ue.push(W("id")), K.initializer && ue.push(" = ", W("initializer")), ue;
      case "TSImportEqualsDeclaration":
        return K.isExport && ue.push("export "), ue.push("import "), K.importKind && K.importKind !== "value" && ue.push(K.importKind, " "), ue.push(W("id"), " = ", W("moduleReference")), ce.semi && ue.push(";"), l(ue);
      case "TSExternalModuleReference":
        return ["require(", W("expression"), ")"];
      case "TSModuleDeclaration": {
        let Fe = ee.getParentNode(), z = g(K.id), U = Fe.type === "TSModuleDeclaration", Z = K.body && K.body.type === "TSModuleDeclaration";
        if (U) ue.push(".");
        else {
          K.declare && ue.push("declare "), ue.push(I(ee, ce, W));
          let se = ce.originalText.slice(F(K), F(K.id));
          K.id.type === "Identifier" && K.id.name === "global" && !/namespace|module/.test(se) || ue.push(z || /(?:^|\s)module(?:\s|$)/.test(se) ? "module " : "namespace ");
        }
        return ue.push(W("id")), Z ? ue.push(W("body")) : K.body ? ue.push(" ", l(W("body"))) : ue.push(de), ue;
      }
      case "TSConditionalType":
        return P(ee, ce, W);
      case "TSInferType":
        return ["infer", " ", W("typeParameter")];
      case "TSIntersectionType":
        return J2(ee, ce, W);
      case "TSUnionType":
        return L(ee, ce, W);
      case "TSFunctionType":
        return Q2(ee, ce, W);
      case "TSTupleType":
        return V(ee, ce, W);
      case "TSTypeReference":
        return [W("typeName"), S(ee, ce, W, "typeParameters")];
      case "TSTypeAnnotation":
        return W("typeAnnotation");
      case "TSEmptyBodyFunctionExpression":
        return k(ee, ce, W);
      case "TSJSDocAllType":
        return "*";
      case "TSJSDocUnknownType":
        return "?";
      case "TSJSDocNullableType":
        return Y(ee, W, "?");
      case "TSJSDocNonNullableType":
        return Y(ee, W, "!");
      case "TSInstantiationExpression":
        return [W("expression"), W("typeParameters")];
      default:
        throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`);
    }
  }
  r.exports = { printTypescript: ie };
} });
var ld = te({ "src/language-js/print/comment.js"(e, r) {
  "use strict";
  ne();
  var { hasNewline: t } = Ue(), { builders: { join: s, hardline: a }, utils: { replaceTextEndOfLine: n } } = qe(), { isLineComment: u } = Ke(), { locStart: i, locEnd: l } = ut(), p = _t();
  function d(c, f) {
    let E2 = c.getValue();
    if (u(E2)) return f.originalText.slice(i(E2), l(E2)).trimEnd();
    if (p(E2)) {
      if (y(E2)) {
        let F = g(E2);
        return E2.trailing && !t(f.originalText, i(E2), { backwards: true }) ? [a, F] : F;
      }
      let _ = l(E2), w = f.originalText.slice(_ - 3, _) === "*-/";
      return ["/*", n(E2.value), w ? "*-/" : "*/"];
    }
    throw new Error("Not a comment: " + JSON.stringify(E2));
  }
  function y(c) {
    let f = `*${c.value}*`.split(`
`);
    return f.length > 1 && f.every((E2) => E2.trim()[0] === "*");
  }
  function g(c) {
    let f = c.value.split(`
`);
    return ["/*", s(a, f.map((E2, _) => _ === 0 ? E2.trimEnd() : " " + (_ < f.length - 1 ? E2.trim() : E2.trimStart()))), "*/"];
  }
  r.exports = { printComment: d };
} });
var cd = te({ "src/language-js/print/literal.js"(e, r) {
  "use strict";
  ne();
  var { printString: t, printNumber: s } = Ue(), { replaceTextEndOfLine: a } = Xt(), { printDirective: n } = ct();
  function u(d, y) {
    let g = d.getNode();
    switch (g.type) {
      case "RegExpLiteral":
        return p(g);
      case "BigIntLiteral":
        return l(g.bigint || g.extra.raw);
      case "NumericLiteral":
        return s(g.extra.raw);
      case "StringLiteral":
        return a(t(g.extra.raw, y));
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return String(g.value);
      case "DecimalLiteral":
        return s(g.value) + "m";
      case "Literal": {
        if (g.regex) return p(g.regex);
        if (g.bigint) return l(g.raw);
        if (g.decimal) return s(g.decimal) + "m";
        let { value: c } = g;
        return typeof c == "number" ? s(g.raw) : typeof c == "string" ? i(d) ? n(g.raw, y) : a(t(g.raw, y)) : String(c);
      }
    }
  }
  function i(d) {
    if (d.getName() !== "expression") return;
    let y = d.getParentNode();
    return y.type === "ExpressionStatement" && y.directive;
  }
  function l(d) {
    return d.toLowerCase();
  }
  function p(d) {
    let { pattern: y, flags: g } = d;
    return g = [...g].sort().join(""), `/${y}/${g}`;
  }
  r.exports = { printLiteral: u };
} });
var pd = te({ "src/language-js/printer-estree.js"(e, r) {
  "use strict";
  ne();
  var { printDanglingComments: t } = et(), { hasNewline: s } = Ue(), { builders: { join: a, line: n, hardline: u, softline: i, group: l, indent: p }, utils: { replaceTextEndOfLine: d } } = qe(), y = Um(), g = Jm(), { insertPragma: c } = po(), f = fo(), E2 = Ot(), _ = Do(), { hasFlowShorthandAnnotationComment: w, hasComment: F, CommentCheckFlags: N, isTheOnlyJsxElementInMarkdown: x, isLineComment: I, isNextLineEmpty: P, needsHardlineAfterDanglingComment: $2, hasIgnoreComment: D, isCallExpression: T, isMemberExpression: m, markerForIfWithoutBlockAndSameLineComment: C } = Ke(), { locStart: o, locEnd: h } = ut(), v = _t(), { printHtmlBinding: S, isVueEventBindingExpression: b } = rd(), { printAngular: B } = nd(), { printJsx: k, hasJsxIgnoreComment: M } = ud(), { printFlow: R } = id(), { printTypescript: q } = od(), { printOptionalToken: J2, printBindExpressionCallee: L, printTypeAnnotation: Q2, adjustClause: V, printRestSpread: j, printDefiniteToken: Y, printDirective: ie } = ct(), { printImportDeclaration: ee, printExportDeclaration: ce, printExportAllDeclaration: W, printModuleSpecifier: K } = vo(), { printTernary: de } = Co(), { printTemplateLiteral: ue } = Lt(), { printArray: Fe } = Qt(), { printObject: z } = tu(), { printClass: U, printClassMethod: Z, printClassProperty: se } = tr(), { printProperty: fe } = er(), { printFunction: ge, printArrowFunction: he, printMethod: we, printReturnStatement: ke, printThrowStatement: Re } = Or(), { printCallExpression: Ne } = yo(), { printVariableDeclarator: Pe2, printAssignmentExpression: oe2 } = Zt(), { printBinaryishExpression: H } = Zn(), { printSwitchCaseConsequent: pe } = Eo(), { printMemberExpression: X } = go(), { printBlock: le2, printBlockBody: Ae } = Fo(), { printComment: Ee } = ld(), { printLiteral: De } = cd(), { printDecorators: A } = eu();
  function G(Ce, Be, ve, ze) {
    let xe2 = re(Ce, Be, ve, ze);
    if (!xe2) return "";
    let Ye = Ce.getValue(), { type: Se } = Ye;
    if (Se === "ClassMethod" || Se === "ClassPrivateMethod" || Se === "ClassProperty" || Se === "ClassAccessorProperty" || Se === "AccessorProperty" || Se === "TSAbstractAccessorProperty" || Se === "PropertyDefinition" || Se === "TSAbstractPropertyDefinition" || Se === "ClassPrivateProperty" || Se === "MethodDefinition" || Se === "TSAbstractMethodDefinition" || Se === "TSDeclareMethod") return xe2;
    let Ie = [xe2], Oe = A(Ce, Be, ve), Je = Ye.type === "ClassExpression" && Oe;
    if (Oe && (Ie = [...Oe, xe2], !Je)) return l(Ie);
    if (!E2(Ce, Be)) return ze && ze.needsSemi && Ie.unshift(";"), Ie.length === 1 && Ie[0] === xe2 ? xe2 : Ie;
    if (Je && (Ie = [p([n, ...Ie])]), Ie.unshift("("), ze && ze.needsSemi && Ie.unshift(";"), w(Ye)) {
      let [je] = Ye.trailingComments;
      Ie.push(" /*", je.value.trimStart(), "*/"), je.printed = true;
    }
    return Je && Ie.push(n), Ie.push(")"), Ie;
  }
  function re(Ce, Be, ve, ze) {
    let xe2 = Ce.getValue(), Ye = Be.semi ? ";" : "";
    if (!xe2) return "";
    if (typeof xe2 == "string") return xe2;
    for (let Ie of [De, S, B, k, R, q]) {
      let Oe = Ie(Ce, Be, ve);
      if (typeof Oe < "u") return Oe;
    }
    let Se = [];
    switch (xe2.type) {
      case "JsExpressionRoot":
        return ve("node");
      case "JsonRoot":
        return [ve("node"), u];
      case "File":
        return xe2.program && xe2.program.interpreter && Se.push(ve(["program", "interpreter"])), Se.push(ve("program")), Se;
      case "Program":
        return Ae(Ce, Be, ve);
      case "EmptyStatement":
        return "";
      case "ExpressionStatement": {
        if (Be.parser === "__vue_event_binding" || Be.parser === "__vue_ts_event_binding") {
          let Oe = Ce.getParentNode();
          if (Oe.type === "Program" && Oe.body.length === 1 && Oe.body[0] === xe2) return [ve("expression"), b(xe2.expression) ? ";" : ""];
        }
        let Ie = t(Ce, Be, true, (Oe) => {
          let { marker: Je } = Oe;
          return Je === C;
        });
        return [ve("expression"), x(Be, Ce) ? "" : Ye, Ie ? [" ", Ie] : ""];
      }
      case "ParenthesizedExpression":
        return !F(xe2.expression) && (xe2.expression.type === "ObjectExpression" || xe2.expression.type === "ArrayExpression") ? ["(", ve("expression"), ")"] : l(["(", p([i, ve("expression")]), i, ")"]);
      case "AssignmentExpression":
        return oe2(Ce, Be, ve);
      case "VariableDeclarator":
        return Pe2(Ce, Be, ve);
      case "BinaryExpression":
      case "LogicalExpression":
        return H(Ce, Be, ve);
      case "AssignmentPattern":
        return [ve("left"), " = ", ve("right")];
      case "OptionalMemberExpression":
      case "MemberExpression":
        return X(Ce, Be, ve);
      case "MetaProperty":
        return [ve("meta"), ".", ve("property")];
      case "BindExpression":
        return xe2.object && Se.push(ve("object")), Se.push(l(p([i, L(Ce, Be, ve)]))), Se;
      case "Identifier":
        return [xe2.name, J2(Ce), Y(Ce), Q2(Ce, Be, ve)];
      case "V8IntrinsicIdentifier":
        return ["%", xe2.name];
      case "SpreadElement":
      case "SpreadElementPattern":
      case "SpreadProperty":
      case "SpreadPropertyPattern":
      case "RestElement":
        return j(Ce, Be, ve);
      case "FunctionDeclaration":
      case "FunctionExpression":
        return ge(Ce, ve, Be, ze);
      case "ArrowFunctionExpression":
        return he(Ce, Be, ve, ze);
      case "YieldExpression":
        return Se.push("yield"), xe2.delegate && Se.push("*"), xe2.argument && Se.push(" ", ve("argument")), Se;
      case "AwaitExpression": {
        if (Se.push("await"), xe2.argument) {
          Se.push(" ", ve("argument"));
          let Ie = Ce.getParentNode();
          if (T(Ie) && Ie.callee === xe2 || m(Ie) && Ie.object === xe2) {
            Se = [p([i, ...Se]), i];
            let Oe = Ce.findAncestor((Je) => Je.type === "AwaitExpression" || Je.type === "BlockStatement");
            if (!Oe || Oe.type !== "AwaitExpression") return l(Se);
          }
        }
        return Se;
      }
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        return ce(Ce, Be, ve);
      case "ExportAllDeclaration":
        return W(Ce, Be, ve);
      case "ImportDeclaration":
        return ee(Ce, Be, ve);
      case "ImportSpecifier":
      case "ExportSpecifier":
      case "ImportNamespaceSpecifier":
      case "ExportNamespaceSpecifier":
      case "ImportDefaultSpecifier":
      case "ExportDefaultSpecifier":
        return K(Ce, Be, ve);
      case "ImportAttribute":
        return [ve("key"), ": ", ve("value")];
      case "Import":
        return "import";
      case "BlockStatement":
      case "StaticBlock":
      case "ClassBody":
        return le2(Ce, Be, ve);
      case "ThrowStatement":
        return Re(Ce, Be, ve);
      case "ReturnStatement":
        return ke(Ce, Be, ve);
      case "NewExpression":
      case "ImportExpression":
      case "OptionalCallExpression":
      case "CallExpression":
        return Ne(Ce, Be, ve);
      case "ObjectExpression":
      case "ObjectPattern":
      case "RecordExpression":
        return z(Ce, Be, ve);
      case "ObjectProperty":
      case "Property":
        return xe2.method || xe2.kind === "get" || xe2.kind === "set" ? we(Ce, Be, ve) : fe(Ce, Be, ve);
      case "ObjectMethod":
        return we(Ce, Be, ve);
      case "Decorator":
        return ["@", ve("expression")];
      case "ArrayExpression":
      case "ArrayPattern":
      case "TupleExpression":
        return Fe(Ce, Be, ve);
      case "SequenceExpression": {
        let Ie = Ce.getParentNode(0);
        if (Ie.type === "ExpressionStatement" || Ie.type === "ForStatement") {
          let Oe = [];
          return Ce.each((Je, be2) => {
            be2 === 0 ? Oe.push(ve()) : Oe.push(",", p([n, ve()]));
          }, "expressions"), l(Oe);
        }
        return l(a([",", n], Ce.map(ve, "expressions")));
      }
      case "ThisExpression":
        return "this";
      case "Super":
        return "super";
      case "Directive":
        return [ve("value"), Ye];
      case "DirectiveLiteral":
        return ie(xe2.extra.raw, Be);
      case "UnaryExpression":
        return Se.push(xe2.operator), /[a-z]$/.test(xe2.operator) && Se.push(" "), F(xe2.argument) ? Se.push(l(["(", p([i, ve("argument")]), i, ")"])) : Se.push(ve("argument")), Se;
      case "UpdateExpression":
        return Se.push(ve("argument"), xe2.operator), xe2.prefix && Se.reverse(), Se;
      case "ConditionalExpression":
        return de(Ce, Be, ve);
      case "VariableDeclaration": {
        let Ie = Ce.map(ve, "declarations"), Oe = Ce.getParentNode(), Je = Oe.type === "ForStatement" || Oe.type === "ForInStatement" || Oe.type === "ForOfStatement", be2 = xe2.declarations.some((Me2) => Me2.init), je;
        return Ie.length === 1 && !F(xe2.declarations[0]) ? je = Ie[0] : Ie.length > 0 && (je = p(Ie[0])), Se = [xe2.declare ? "declare " : "", xe2.kind, je ? [" ", je] : "", p(Ie.slice(1).map((Me2) => [",", be2 && !Je ? u : n, Me2]))], Je && Oe.body !== xe2 || Se.push(Ye), l(Se);
      }
      case "WithStatement":
        return l(["with (", ve("object"), ")", V(xe2.body, ve("body"))]);
      case "IfStatement": {
        let Ie = V(xe2.consequent, ve("consequent")), Oe = l(["if (", l([p([i, ve("test")]), i]), ")", Ie]);
        if (Se.push(Oe), xe2.alternate) {
          let Je = F(xe2.consequent, N.Trailing | N.Line) || $2(xe2), be2 = xe2.consequent.type === "BlockStatement" && !Je;
          Se.push(be2 ? " " : u), F(xe2, N.Dangling) && Se.push(t(Ce, Be, true), Je ? u : " "), Se.push("else", l(V(xe2.alternate, ve("alternate"), xe2.alternate.type === "IfStatement")));
        }
        return Se;
      }
      case "ForStatement": {
        let Ie = V(xe2.body, ve("body")), Oe = t(Ce, Be, true), Je = Oe ? [Oe, i] : "";
        return !xe2.init && !xe2.test && !xe2.update ? [Je, l(["for (;;)", Ie])] : [Je, l(["for (", l([p([i, ve("init"), ";", n, ve("test"), ";", n, ve("update")]), i]), ")", Ie])];
      }
      case "WhileStatement":
        return l(["while (", l([p([i, ve("test")]), i]), ")", V(xe2.body, ve("body"))]);
      case "ForInStatement":
        return l(["for (", ve("left"), " in ", ve("right"), ")", V(xe2.body, ve("body"))]);
      case "ForOfStatement":
        return l(["for", xe2.await ? " await" : "", " (", ve("left"), " of ", ve("right"), ")", V(xe2.body, ve("body"))]);
      case "DoWhileStatement": {
        let Ie = V(xe2.body, ve("body"));
        return Se = [l(["do", Ie])], xe2.body.type === "BlockStatement" ? Se.push(" ") : Se.push(u), Se.push("while (", l([p([i, ve("test")]), i]), ")", Ye), Se;
      }
      case "DoExpression":
        return [xe2.async ? "async " : "", "do ", ve("body")];
      case "BreakStatement":
        return Se.push("break"), xe2.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
      case "ContinueStatement":
        return Se.push("continue"), xe2.label && Se.push(" ", ve("label")), Se.push(Ye), Se;
      case "LabeledStatement":
        return xe2.body.type === "EmptyStatement" ? [ve("label"), ":;"] : [ve("label"), ": ", ve("body")];
      case "TryStatement":
        return ["try ", ve("block"), xe2.handler ? [" ", ve("handler")] : "", xe2.finalizer ? [" finally ", ve("finalizer")] : ""];
      case "CatchClause":
        if (xe2.param) {
          let Ie = F(xe2.param, (Je) => !v(Je) || Je.leading && s(Be.originalText, h(Je)) || Je.trailing && s(Be.originalText, o(Je), { backwards: true })), Oe = ve("param");
          return ["catch ", Ie ? ["(", p([i, Oe]), i, ") "] : ["(", Oe, ") "], ve("body")];
        }
        return ["catch ", ve("body")];
      case "SwitchStatement":
        return [l(["switch (", p([i, ve("discriminant")]), i, ")"]), " {", xe2.cases.length > 0 ? p([u, a(u, Ce.map((Ie, Oe, Je) => {
          let be2 = Ie.getValue();
          return [ve(), Oe !== Je.length - 1 && P(be2, Be) ? u : ""];
        }, "cases"))]) : "", u, "}"];
      case "SwitchCase": {
        xe2.test ? Se.push("case ", ve("test"), ":") : Se.push("default:"), F(xe2, N.Dangling) && Se.push(" ", t(Ce, Be, true));
        let Ie = xe2.consequent.filter((Oe) => Oe.type !== "EmptyStatement");
        if (Ie.length > 0) {
          let Oe = pe(Ce, Be, ve);
          Se.push(Ie.length === 1 && Ie[0].type === "BlockStatement" ? [" ", Oe] : p([u, Oe]));
        }
        return Se;
      }
      case "DebuggerStatement":
        return ["debugger", Ye];
      case "ClassDeclaration":
      case "ClassExpression":
        return U(Ce, Be, ve);
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "MethodDefinition":
        return Z(Ce, Be, ve);
      case "ClassProperty":
      case "PropertyDefinition":
      case "ClassPrivateProperty":
      case "ClassAccessorProperty":
      case "AccessorProperty":
        return se(Ce, Be, ve);
      case "TemplateElement":
        return d(xe2.value.raw);
      case "TemplateLiteral":
        return ue(Ce, ve, Be);
      case "TaggedTemplateExpression":
        return [ve("tag"), ve("typeParameters"), ve("quasi")];
      case "PrivateIdentifier":
        return ["#", ve("name")];
      case "PrivateName":
        return ["#", ve("id")];
      case "InterpreterDirective":
        return Se.push("#!", xe2.value, u), P(xe2, Be) && Se.push(u), Se;
      case "TopicReference":
        return "%";
      case "ArgumentPlaceholder":
        return "?";
      case "ModuleExpression": {
        Se.push("module {");
        let Ie = ve("body");
        return Ie && Se.push(p([u, Ie]), u), Se.push("}"), Se;
      }
      default:
        throw new Error("unknown type: " + JSON.stringify(xe2.type));
    }
  }
  function ye2(Ce) {
    return Ce.type && !v(Ce) && !I(Ce) && Ce.type !== "EmptyStatement" && Ce.type !== "TemplateElement" && Ce.type !== "Import" && Ce.type !== "TSEmptyBodyFunctionExpression";
  }
  r.exports = { preprocess: _, print: G, embed: y, insertPragma: c, massageAstNode: g, hasPrettierIgnore(Ce) {
    return D(Ce) || M(Ce);
  }, willPrintOwnComments: f.willPrintOwnComments, canAttachComment: ye2, printComment: Ee, isBlockComment: v, handleComments: { avoidAstMutation: true, ownLine: f.handleOwnLineComment, endOfLine: f.handleEndOfLineComment, remaining: f.handleRemainingComment }, getCommentChildNodes: f.getCommentChildNodes };
} });
var fd = te({ "src/language-js/printer-estree-json.js"(e, r) {
  "use strict";
  ne();
  var { builders: { hardline: t, indent: s, join: a } } = qe(), n = Do();
  function u(d, y, g) {
    let c = d.getValue();
    switch (c.type) {
      case "JsonRoot":
        return [g("node"), t];
      case "ArrayExpression": {
        if (c.elements.length === 0) return "[]";
        let f = d.map(() => d.getValue() === null ? "null" : g(), "elements");
        return ["[", s([t, a([",", t], f)]), t, "]"];
      }
      case "ObjectExpression":
        return c.properties.length === 0 ? "{}" : ["{", s([t, a([",", t], d.map(g, "properties"))]), t, "}"];
      case "ObjectProperty":
        return [g("key"), ": ", g("value")];
      case "UnaryExpression":
        return [c.operator === "+" ? "" : c.operator, g("argument")];
      case "NullLiteral":
        return "null";
      case "BooleanLiteral":
        return c.value ? "true" : "false";
      case "StringLiteral":
        return JSON.stringify(c.value);
      case "NumericLiteral":
        return i(d) ? JSON.stringify(String(c.value)) : JSON.stringify(c.value);
      case "Identifier":
        return i(d) ? JSON.stringify(c.name) : c.name;
      case "TemplateLiteral":
        return g(["quasis", 0]);
      case "TemplateElement":
        return JSON.stringify(c.value.cooked);
      default:
        throw new Error("unknown type: " + JSON.stringify(c.type));
    }
  }
  function i(d) {
    return d.getName() === "key" && d.getParentNode().type === "ObjectProperty";
  }
  var l = /* @__PURE__ */ new Set(["start", "end", "extra", "loc", "comments", "leadingComments", "trailingComments", "innerComments", "errors", "range", "tokens"]);
  function p(d, y) {
    let { type: g } = d;
    if (g === "ObjectProperty") {
      let { key: c } = d;
      c.type === "Identifier" ? y.key = { type: "StringLiteral", value: c.name } : c.type === "NumericLiteral" && (y.key = { type: "StringLiteral", value: String(c.value) });
      return;
    }
    if (g === "UnaryExpression" && d.operator === "+") return y.argument;
    if (g === "ArrayExpression") {
      for (let [c, f] of d.elements.entries()) f === null && y.elements.splice(c, 0, { type: "NullLiteral" });
      return;
    }
    if (g === "TemplateLiteral") return { type: "StringLiteral", value: d.quasis[0].value.cooked };
  }
  p.ignoredProperties = l, r.exports = { preprocess: n, print: u, massageAstNode: p };
} });
var jt = te({ "src/common/common-options.js"(e, r) {
  "use strict";
  ne();
  var t = "Common";
  r.exports = { bracketSpacing: { since: "0.0.0", category: t, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: t, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, proseWrap: { since: "1.8.2", category: t, type: "choice", default: [{ since: "1.8.2", value: true }, { since: "1.9.0", value: "preserve" }], description: "How to wrap prose.", choices: [{ since: "1.9.0", value: "always", description: "Wrap prose if it exceeds the print width." }, { since: "1.9.0", value: "never", description: "Do not wrap prose." }, { since: "1.9.0", value: "preserve", description: "Wrap prose as-is." }] }, bracketSameLine: { since: "2.4.0", category: t, type: "boolean", default: false, description: "Put > of opening tags on the last line instead of on a new line." }, singleAttributePerLine: { since: "2.6.0", category: t, type: "boolean", default: false, description: "Enforce single attribute per line in HTML, Vue and JSX." } };
} });
var Dd = te({ "src/language-js/options.js"(e, r) {
  "use strict";
  ne();
  var t = jt(), s = "JavaScript";
  r.exports = { arrowParens: { since: "1.9.0", category: s, type: "choice", default: [{ since: "1.9.0", value: "avoid" }, { since: "2.0.0", value: "always" }], description: "Include parentheses around a sole arrow function parameter.", choices: [{ value: "always", description: "Always include parens. Example: `(x) => x`" }, { value: "avoid", description: "Omit parens when possible. Example: `x => x`" }] }, bracketSameLine: t.bracketSameLine, bracketSpacing: t.bracketSpacing, jsxBracketSameLine: { since: "0.17.0", category: s, type: "boolean", description: "Put > on the last line instead of at a new line.", deprecated: "2.4.0" }, semi: { since: "1.0.0", category: s, type: "boolean", default: true, description: "Print semicolons.", oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them." }, singleQuote: t.singleQuote, jsxSingleQuote: { since: "1.15.0", category: s, type: "boolean", default: false, description: "Use single quotes in JSX." }, quoteProps: { since: "1.17.0", category: s, type: "choice", default: "as-needed", description: "Change when properties in objects are quoted.", choices: [{ value: "as-needed", description: "Only add quotes around object properties where required." }, { value: "consistent", description: "If at least one property in an object requires quotes, quote all properties." }, { value: "preserve", description: "Respect the input use of quotes in object properties." }] }, trailingComma: { since: "0.0.0", category: s, type: "choice", default: [{ since: "0.0.0", value: false }, { since: "0.19.0", value: "none" }, { since: "2.0.0", value: "es5" }], description: "Print trailing commas wherever possible when multi-line.", choices: [{ value: "es5", description: "Trailing commas where valid in ES5 (objects, arrays, etc.)" }, { value: "none", description: "No trailing commas." }, { value: "all", description: "Trailing commas wherever possible (including function arguments)." }] }, singleAttributePerLine: t.singleAttributePerLine };
} });
var md = te({ "src/language-js/parse/parsers.js"() {
  ne();
} });
var In = te({ "node_modules/linguist-languages/data/JavaScript.json"(e, r) {
  r.exports = { name: "JavaScript", type: "programming", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", color: "#f1e05a", aliases: ["js", "node"], extensions: [".js", "._js", ".bones", ".cjs", ".es", ".es6", ".frag", ".gs", ".jake", ".javascript", ".jsb", ".jscad", ".jsfl", ".jslib", ".jsm", ".jspre", ".jss", ".jsx", ".mjs", ".njs", ".pac", ".sjs", ".ssjs", ".xsjs", ".xsjslib"], filenames: ["Jakefile"], interpreters: ["chakra", "d8", "gjs", "js", "node", "nodejs", "qjs", "rhino", "v8", "v8-shell"], languageId: 183 };
} });
var dd = te({ "node_modules/linguist-languages/data/TypeScript.json"(e, r) {
  r.exports = { name: "TypeScript", type: "programming", color: "#3178c6", aliases: ["ts"], interpreters: ["deno", "ts-node"], extensions: [".ts", ".cts", ".mts"], tmScope: "source.ts", aceMode: "typescript", codemirrorMode: "javascript", codemirrorMimeType: "application/typescript", languageId: 378 };
} });
var gd = te({ "node_modules/linguist-languages/data/TSX.json"(e, r) {
  r.exports = { name: "TSX", type: "programming", color: "#3178c6", group: "TypeScript", extensions: [".tsx"], tmScope: "source.tsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", languageId: 94901924 };
} });
var Fa = te({ "node_modules/linguist-languages/data/JSON.json"(e, r) {
  r.exports = { name: "JSON", type: "data", color: "#292929", tmScope: "source.json", aceMode: "json", codemirrorMode: "javascript", codemirrorMimeType: "application/json", aliases: ["geojson", "jsonl", "topojson"], extensions: [".json", ".4DForm", ".4DProject", ".avsc", ".geojson", ".gltf", ".har", ".ice", ".JSON-tmLanguage", ".jsonl", ".mcmeta", ".tfstate", ".tfstate.backup", ".topojson", ".webapp", ".webmanifest", ".yy", ".yyp"], filenames: [".arcconfig", ".auto-changelog", ".c8rc", ".htmlhintrc", ".imgbotconfig", ".nycrc", ".tern-config", ".tern-project", ".watchmanconfig", "Pipfile.lock", "composer.lock", "mcmod.info"], languageId: 174 };
} });
var yd = te({ "node_modules/linguist-languages/data/JSON with Comments.json"(e, r) {
  r.exports = { name: "JSON with Comments", type: "data", color: "#292929", group: "JSON", tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "text/javascript", aliases: ["jsonc"], extensions: [".jsonc", ".code-snippets", ".sublime-build", ".sublime-commands", ".sublime-completions", ".sublime-keymap", ".sublime-macro", ".sublime-menu", ".sublime-mousemap", ".sublime-project", ".sublime-settings", ".sublime-theme", ".sublime-workspace", ".sublime_metrics", ".sublime_session"], filenames: [".babelrc", ".devcontainer.json", ".eslintrc.json", ".jscsrc", ".jshintrc", ".jslintrc", "api-extractor.json", "devcontainer.json", "jsconfig.json", "language-configuration.json", "tsconfig.json", "tslint.json"], languageId: 423 };
} });
var hd = te({ "node_modules/linguist-languages/data/JSON5.json"(e, r) {
  r.exports = { name: "JSON5", type: "data", color: "#267CB9", extensions: [".json5"], tmScope: "source.js", aceMode: "javascript", codemirrorMode: "javascript", codemirrorMimeType: "application/json", languageId: 175 };
} });
var vd = te({ "src/language-js/index.js"(e, r) {
  "use strict";
  ne();
  var t = wt(), s = pd(), a = fd(), n = Dd(), u = md(), i = [t(In(), (p) => ({ since: "0.0.0", parsers: ["babel", "acorn", "espree", "meriyah", "babel-flow", "babel-ts", "flow", "typescript"], vscodeLanguageIds: ["javascript", "mongo"], interpreters: [...p.interpreters, "zx"], extensions: [...p.extensions.filter((d) => d !== ".jsx"), ".wxs"] })), t(In(), () => ({ name: "Flow", since: "0.0.0", parsers: ["flow", "babel-flow"], vscodeLanguageIds: ["javascript"], aliases: [], filenames: [], extensions: [".js.flow"] })), t(In(), () => ({ name: "JSX", since: "0.0.0", parsers: ["babel", "babel-flow", "babel-ts", "flow", "typescript", "espree", "meriyah"], vscodeLanguageIds: ["javascriptreact"], aliases: void 0, filenames: void 0, extensions: [".jsx"], group: "JavaScript", interpreters: void 0, tmScope: "source.js.jsx", aceMode: "javascript", codemirrorMode: "jsx", codemirrorMimeType: "text/jsx", color: void 0 })), t(dd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescript"] })), t(gd(), () => ({ since: "1.4.0", parsers: ["typescript", "babel-ts"], vscodeLanguageIds: ["typescriptreact"] })), t(Fa(), () => ({ name: "JSON.stringify", since: "1.13.0", parsers: ["json-stringify"], vscodeLanguageIds: ["json"], extensions: [".importmap"], filenames: ["package.json", "package-lock.json", "composer.json"] })), t(Fa(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["json"], extensions: p.extensions.filter((d) => d !== ".jsonl") })), t(yd(), (p) => ({ since: "1.5.0", parsers: ["json"], vscodeLanguageIds: ["jsonc"], filenames: [...p.filenames, ".eslintrc", ".swcrc"] })), t(hd(), () => ({ since: "1.13.0", parsers: ["json5"], vscodeLanguageIds: ["json5"] }))], l = { estree: s, "estree-json": a };
  r.exports = { languages: i, options: n, printers: l, parsers: u };
} });
var Cd = te({ "src/language-css/clean.js"(e, r) {
  "use strict";
  ne();
  var { isFrontMatterNode: t } = Ue(), s = lt(), a = /* @__PURE__ */ new Set(["raw", "raws", "sourceIndex", "source", "before", "after", "trailingComma"]);
  function n(i, l, p) {
    if (t(i) && i.lang === "yaml" && delete l.value, i.type === "css-comment" && p.type === "css-root" && p.nodes.length > 0 && ((p.nodes[0] === i || t(p.nodes[0]) && p.nodes[1] === i) && (delete l.text, /^\*\s*@(?:format|prettier)\s*$/.test(i.text)) || p.type === "css-root" && s(p.nodes) === i)) return null;
    if (i.type === "value-root" && delete l.text, (i.type === "media-query" || i.type === "media-query-list" || i.type === "media-feature-expression") && delete l.value, i.type === "css-rule" && delete l.params, i.type === "selector-combinator" && (l.value = l.value.replace(/\s+/g, " ")), i.type === "media-feature" && (l.value = l.value.replace(/ /g, "")), (i.type === "value-word" && (i.isColor && i.isHex || ["initial", "inherit", "unset", "revert"].includes(l.value.replace().toLowerCase())) || i.type === "media-feature" || i.type === "selector-root-invalid" || i.type === "selector-pseudo") && (l.value = l.value.toLowerCase()), i.type === "css-decl" && (l.prop = l.prop.toLowerCase()), (i.type === "css-atrule" || i.type === "css-import") && (l.name = l.name.toLowerCase()), i.type === "value-number" && (l.unit = l.unit.toLowerCase()), (i.type === "media-feature" || i.type === "media-keyword" || i.type === "media-type" || i.type === "media-unknown" || i.type === "media-url" || i.type === "media-value" || i.type === "selector-attribute" || i.type === "selector-string" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "value-string") && l.value && (l.value = u(l.value)), i.type === "selector-attribute" && (l.attribute = l.attribute.trim(), l.namespace && typeof l.namespace == "string" && (l.namespace = l.namespace.trim(), l.namespace.length === 0 && (l.namespace = true)), l.value && (l.value = l.value.trim().replace(/^["']|["']$/g, ""), delete l.quoted)), (i.type === "media-value" || i.type === "media-type" || i.type === "value-number" || i.type === "selector-root-invalid" || i.type === "selector-class" || i.type === "selector-combinator" || i.type === "selector-tag") && l.value && (l.value = l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g, (d, y, g) => {
      let c = Number(y);
      return Number.isNaN(c) ? d : c + g.toLowerCase();
    })), i.type === "selector-tag") {
      let d = i.value.toLowerCase();
      ["from", "to"].includes(d) && (l.value = d);
    }
    if (i.type === "css-atrule" && i.name.toLowerCase() === "supports" && delete l.value, i.type === "selector-unknown" && delete l.value, i.type === "value-comma_group") {
      let d = i.groups.findIndex((y) => y.type === "value-number" && y.unit === "...");
      d !== -1 && (l.groups[d].unit = "", l.groups.splice(d + 1, 0, { type: "value-word", value: "...", isColor: false, isHex: false }));
    }
    if (i.type === "value-comma_group" && i.groups.some((d) => d.type === "value-atword" && d.value.endsWith("[") || d.type === "value-word" && d.value.startsWith("]"))) return { type: "value-atword", value: i.groups.map((d) => d.value).join(""), group: { open: null, close: null, groups: [], type: "value-paren_group" } };
  }
  n.ignoredProperties = a;
  function u(i) {
    return i.replace(/'/g, '"').replace(/\\([^\dA-Fa-f])/g, "$1");
  }
  r.exports = n;
} });
var ru = te({ "src/utils/front-matter/print.js"(e, r) {
  "use strict";
  ne();
  var { builders: { hardline: t, markAsRoot: s } } = qe();
  function a(n, u) {
    if (n.lang === "yaml") {
      let i = n.value.trim(), l = i ? u(i, { parser: "yaml" }, { stripTrailingHardline: true }) : "";
      return s([n.startDelimiter, t, l, l ? t : "", n.endDelimiter]);
    }
  }
  r.exports = a;
} });
var Ed = te({ "src/language-css/embed.js"(e, r) {
  "use strict";
  ne();
  var { builders: { hardline: t } } = qe(), s = ru();
  function a(n, u, i) {
    let l = n.getValue();
    if (l.type === "front-matter") {
      let p = s(l, i);
      return p ? [p, t] : "";
    }
  }
  r.exports = a;
} });
var Ao = te({ "src/utils/front-matter/parse.js"(e, r) {
  "use strict";
  ne();
  var t = new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)", "s");
  function s(a) {
    let n = a.match(t);
    if (!n) return { content: a };
    let { startDelimiter: u, language: i, value: l = "", endDelimiter: p } = n.groups, d = i.trim() || "yaml";
    if (u === "+++" && (d = "toml"), d !== "yaml" && u !== p) return { content: a };
    let [y] = n;
    return { frontMatter: { type: "front-matter", lang: d, value: l, startDelimiter: u, endDelimiter: p, raw: y.replace(/\n$/, "") }, content: y.replace(/[^\n]/g, " ") + a.slice(y.length) };
  }
  r.exports = s;
} });
var Fd = te({ "src/language-css/pragma.js"(e, r) {
  "use strict";
  ne();
  var t = po(), s = Ao();
  function a(u) {
    return t.hasPragma(s(u).content);
  }
  function n(u) {
    let { frontMatter: i, content: l } = s(u);
    return (i ? i.raw + `

` : "") + t.insertPragma(l);
  }
  r.exports = { hasPragma: a, insertPragma: n };
} });
var Ad = te({ "src/language-css/utils/index.js"(e, r) {
  "use strict";
  ne();
  var t = /* @__PURE__ */ new Set(["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"]);
  function s(z, U) {
    let Z = Array.isArray(U) ? U : [U], se = -1, fe;
    for (; fe = z.getParentNode(++se); ) if (Z.includes(fe.type)) return se;
    return -1;
  }
  function a(z, U) {
    let Z = s(z, U);
    return Z === -1 ? null : z.getParentNode(Z);
  }
  function n(z) {
    var U;
    let Z = a(z, "css-decl");
    return Z == null || (U = Z.prop) === null || U === void 0 ? void 0 : U.toLowerCase();
  }
  var u = /* @__PURE__ */ new Set(["initial", "inherit", "unset", "revert"]);
  function i(z) {
    return u.has(z.toLowerCase());
  }
  function l(z, U) {
    let Z = a(z, "css-atrule");
    return (Z == null ? void 0 : Z.name) && Z.name.toLowerCase().endsWith("keyframes") && ["from", "to"].includes(U.toLowerCase());
  }
  function p(z) {
    return z.includes("$") || z.includes("@") || z.includes("#") || z.startsWith("%") || z.startsWith("--") || z.startsWith(":--") || z.includes("(") && z.includes(")") ? z : z.toLowerCase();
  }
  function d(z, U) {
    var Z;
    let se = a(z, "value-func");
    return (se == null || (Z = se.value) === null || Z === void 0 ? void 0 : Z.toLowerCase()) === U;
  }
  function y(z) {
    var U;
    let Z = a(z, "css-rule"), se = Z == null || (U = Z.raws) === null || U === void 0 ? void 0 : U.selector;
    return se && (se.startsWith(":import") || se.startsWith(":export"));
  }
  function g(z, U) {
    let Z = Array.isArray(U) ? U : [U], se = a(z, "css-atrule");
    return se && Z.includes(se.name.toLowerCase());
  }
  function c(z) {
    let U = z.getValue(), Z = a(z, "css-atrule");
    return (Z == null ? void 0 : Z.name) === "import" && U.groups[0].value === "url" && U.groups.length === 2;
  }
  function f(z) {
    return z.type === "value-func" && z.value.toLowerCase() === "url";
  }
  function E2(z, U) {
    var Z;
    let se = (Z = z.getParentNode()) === null || Z === void 0 ? void 0 : Z.nodes;
    return se && se.indexOf(U) === se.length - 1;
  }
  function _(z) {
    let { selector: U } = z;
    return U ? typeof U == "string" && /^@.+:.*$/.test(U) || U.value && /^@.+:.*$/.test(U.value) : false;
  }
  function w(z) {
    return z.type === "value-word" && ["from", "through", "end"].includes(z.value);
  }
  function F(z) {
    return z.type === "value-word" && ["and", "or", "not"].includes(z.value);
  }
  function N(z) {
    return z.type === "value-word" && z.value === "in";
  }
  function x(z) {
    return z.type === "value-operator" && z.value === "*";
  }
  function I(z) {
    return z.type === "value-operator" && z.value === "/";
  }
  function P(z) {
    return z.type === "value-operator" && z.value === "+";
  }
  function $2(z) {
    return z.type === "value-operator" && z.value === "-";
  }
  function D(z) {
    return z.type === "value-operator" && z.value === "%";
  }
  function T(z) {
    return x(z) || I(z) || P(z) || $2(z) || D(z);
  }
  function m(z) {
    return z.type === "value-word" && ["==", "!="].includes(z.value);
  }
  function C(z) {
    return z.type === "value-word" && ["<", ">", "<=", ">="].includes(z.value);
  }
  function o(z) {
    return z.type === "css-atrule" && ["if", "else", "for", "each", "while"].includes(z.name);
  }
  function h(z) {
    var U;
    return ((U = z.raws) === null || U === void 0 ? void 0 : U.params) && /^\(\s*\)$/.test(z.raws.params);
  }
  function v(z) {
    return z.name.startsWith("prettier-placeholder");
  }
  function S(z) {
    return z.prop.startsWith("@prettier-placeholder");
  }
  function b(z, U) {
    return z.value === "$$" && z.type === "value-func" && (U == null ? void 0 : U.type) === "value-word" && !U.raws.before;
  }
  function B(z) {
    var U, Z;
    return ((U = z.value) === null || U === void 0 ? void 0 : U.type) === "value-root" && ((Z = z.value.group) === null || Z === void 0 ? void 0 : Z.type) === "value-value" && z.prop.toLowerCase() === "composes";
  }
  function k(z) {
    var U, Z, se;
    return ((U = z.value) === null || U === void 0 || (Z = U.group) === null || Z === void 0 || (se = Z.group) === null || se === void 0 ? void 0 : se.type) === "value-paren_group" && z.value.group.group.open !== null && z.value.group.group.close !== null;
  }
  function M(z) {
    var U;
    return ((U = z.raws) === null || U === void 0 ? void 0 : U.before) === "";
  }
  function R(z) {
    var U, Z;
    return z.type === "value-comma_group" && ((U = z.groups) === null || U === void 0 || (Z = U[1]) === null || Z === void 0 ? void 0 : Z.type) === "value-colon";
  }
  function q(z) {
    var U;
    return z.type === "value-paren_group" && ((U = z.groups) === null || U === void 0 ? void 0 : U[0]) && R(z.groups[0]);
  }
  function J2(z) {
    var U;
    let Z = z.getValue();
    if (Z.groups.length === 0) return false;
    let se = z.getParentNode(1);
    if (!q(Z) && !(se && q(se))) return false;
    let fe = a(z, "css-decl");
    return !!(fe != null && (U = fe.prop) !== null && U !== void 0 && U.startsWith("$") || q(se) || se.type === "value-func");
  }
  function L(z) {
    return z.type === "value-comment" && z.inline;
  }
  function Q2(z) {
    return z.type === "value-word" && z.value === "#";
  }
  function V(z) {
    return z.type === "value-word" && z.value === "{";
  }
  function j(z) {
    return z.type === "value-word" && z.value === "}";
  }
  function Y(z) {
    return ["value-word", "value-atword"].includes(z.type);
  }
  function ie(z) {
    return (z == null ? void 0 : z.type) === "value-colon";
  }
  function ee(z, U) {
    if (!R(U)) return false;
    let { groups: Z } = U, se = Z.indexOf(z);
    return se === -1 ? false : ie(Z[se + 1]);
  }
  function ce(z) {
    return z.value && ["not", "and", "or"].includes(z.value.toLowerCase());
  }
  function W(z) {
    return z.type !== "value-func" ? false : t.has(z.value.toLowerCase());
  }
  function K(z) {
    return /\/\//.test(z.split(/[\n\r]/).pop());
  }
  function de(z) {
    return (z == null ? void 0 : z.type) === "value-atword" && z.value.startsWith("prettier-placeholder-");
  }
  function ue(z, U) {
    var Z, se;
    if (((Z = z.open) === null || Z === void 0 ? void 0 : Z.value) !== "(" || ((se = z.close) === null || se === void 0 ? void 0 : se.value) !== ")" || z.groups.some((fe) => fe.type !== "value-comma_group")) return false;
    if (U.type === "value-comma_group") {
      let fe = U.groups.indexOf(z) - 1, ge = U.groups[fe];
      if ((ge == null ? void 0 : ge.type) === "value-word" && ge.value === "with") return true;
    }
    return false;
  }
  function Fe(z) {
    var U, Z;
    return z.type === "value-paren_group" && ((U = z.open) === null || U === void 0 ? void 0 : U.value) === "(" && ((Z = z.close) === null || Z === void 0 ? void 0 : Z.value) === ")";
  }
  r.exports = { getAncestorCounter: s, getAncestorNode: a, getPropOfDeclNode: n, maybeToLowerCase: p, insideValueFunctionNode: d, insideICSSRuleNode: y, insideAtRuleNode: g, insideURLFunctionInImportAtRuleNode: c, isKeyframeAtRuleKeywords: l, isWideKeywords: i, isLastNode: E2, isSCSSControlDirectiveNode: o, isDetachedRulesetDeclarationNode: _, isRelationalOperatorNode: C, isEqualityOperatorNode: m, isMultiplicationNode: x, isDivisionNode: I, isAdditionNode: P, isSubtractionNode: $2, isModuloNode: D, isMathOperatorNode: T, isEachKeywordNode: N, isForKeywordNode: w, isURLFunctionNode: f, isIfElseKeywordNode: F, hasComposesNode: B, hasParensAroundNode: k, hasEmptyRawBefore: M, isDetachedRulesetCallNode: h, isTemplatePlaceholderNode: v, isTemplatePropNode: S, isPostcssSimpleVarNode: b, isKeyValuePairNode: R, isKeyValuePairInParenGroupNode: q, isKeyInValuePairNode: ee, isSCSSMapItemNode: J2, isInlineValueCommentNode: L, isHashNode: Q2, isLeftCurlyBraceNode: V, isRightCurlyBraceNode: j, isWordNode: Y, isColonNode: ie, isMediaAndSupportsKeywords: ce, isColorAdjusterFuncNode: W, lastLineHasInlineComment: K, isAtWordPlaceholderNode: de, isConfigurationNode: ue, isParenGroupNode: Fe };
} });
var Sd = te({ "src/utils/line-column-to-index.js"(e, r) {
  "use strict";
  ne(), r.exports = function(t, s) {
    let a = 0;
    for (let n = 0; n < t.line - 1; ++n) a = s.indexOf(`
`, a) + 1;
    return a + t.column;
  };
} });
var xd = te({ "src/language-css/loc.js"(e, r) {
  "use strict";
  ne();
  var { skipEverythingButNewLine: t } = wr(), s = lt(), a = Sd();
  function n(c, f) {
    return typeof c.sourceIndex == "number" ? c.sourceIndex : c.source ? a(c.source.start, f) - 1 : null;
  }
  function u(c, f) {
    if (c.type === "css-comment" && c.inline) return t(f, c.source.startOffset);
    let E2 = c.nodes && s(c.nodes);
    return E2 && c.source && !c.source.end && (c = E2), c.source && c.source.end ? a(c.source.end, f) : null;
  }
  function i(c, f) {
    c.source && (c.source.startOffset = n(c, f), c.source.endOffset = u(c, f));
    for (let E2 in c) {
      let _ = c[E2];
      E2 === "source" || !_ || typeof _ != "object" || (_.type === "value-root" || _.type === "value-unknown" ? l(_, p(c), _.text || _.value) : i(_, f));
    }
  }
  function l(c, f, E2) {
    c.source && (c.source.startOffset = n(c, E2) + f, c.source.endOffset = u(c, E2) + f);
    for (let _ in c) {
      let w = c[_];
      _ === "source" || !w || typeof w != "object" || l(w, f, E2);
    }
  }
  function p(c) {
    let f = c.source.startOffset;
    return typeof c.prop == "string" && (f += c.prop.length), c.type === "css-atrule" && typeof c.name == "string" && (f += 1 + c.name.length + c.raws.afterName.match(/^\s*:?\s*/)[0].length), c.type !== "css-atrule" && c.raws && typeof c.raws.between == "string" && (f += c.raws.between.length), f;
  }
  function d(c) {
    let f = "initial", E2 = "initial", _, w = false, F = [];
    for (let N = 0; N < c.length; N++) {
      let x = c[N];
      switch (f) {
        case "initial":
          if (x === "'") {
            f = "single-quotes";
            continue;
          }
          if (x === '"') {
            f = "double-quotes";
            continue;
          }
          if ((x === "u" || x === "U") && c.slice(N, N + 4).toLowerCase() === "url(") {
            f = "url", N += 3;
            continue;
          }
          if (x === "*" && c[N - 1] === "/") {
            f = "comment-block";
            continue;
          }
          if (x === "/" && c[N - 1] === "/") {
            f = "comment-inline", _ = N - 1;
            continue;
          }
          continue;
        case "single-quotes":
          if (x === "'" && c[N - 1] !== "\\" && (f = E2, E2 = "initial"), x === `
` || x === "\r") return c;
          continue;
        case "double-quotes":
          if (x === '"' && c[N - 1] !== "\\" && (f = E2, E2 = "initial"), x === `
` || x === "\r") return c;
          continue;
        case "url":
          if (x === ")" && (f = "initial"), x === `
` || x === "\r") return c;
          if (x === "'") {
            f = "single-quotes", E2 = "url";
            continue;
          }
          if (x === '"') {
            f = "double-quotes", E2 = "url";
            continue;
          }
          continue;
        case "comment-block":
          x === "/" && c[N - 1] === "*" && (f = "initial");
          continue;
        case "comment-inline":
          (x === '"' || x === "'" || x === "*") && (w = true), (x === `
` || x === "\r") && (w && F.push([_, N]), f = "initial", w = false);
          continue;
      }
    }
    for (let [N, x] of F) c = c.slice(0, N) + c.slice(N, x).replace(/["'*]/g, " ") + c.slice(x);
    return c;
  }
  function y(c) {
    return c.source.startOffset;
  }
  function g(c) {
    return c.source.endOffset;
  }
  r.exports = { locStart: y, locEnd: g, calculateLoc: i, replaceQuotesInInlineComments: d };
} });
var bd = te({ "src/language-css/utils/is-less-parser.js"(e, r) {
  "use strict";
  ne();
  function t(s) {
    return s.parser === "css" || s.parser === "less";
  }
  r.exports = t;
} });
var Td = te({ "src/language-css/utils/is-scss.js"(e, r) {
  "use strict";
  ne();
  function t(s, a) {
    return s === "less" || s === "scss" ? s === "scss" : /(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a);
  }
  r.exports = t;
} });
var Bd = te({ "src/language-css/utils/css-units.evaluate.js"(e, r) {
  r.exports = { em: "em", rem: "rem", ex: "ex", rex: "rex", cap: "cap", rcap: "rcap", ch: "ch", rch: "rch", ic: "ic", ric: "ric", lh: "lh", rlh: "rlh", vw: "vw", svw: "svw", lvw: "lvw", dvw: "dvw", vh: "vh", svh: "svh", lvh: "lvh", dvh: "dvh", vi: "vi", svi: "svi", lvi: "lvi", dvi: "dvi", vb: "vb", svb: "svb", lvb: "lvb", dvb: "dvb", vmin: "vmin", svmin: "svmin", lvmin: "lvmin", dvmin: "dvmin", vmax: "vmax", svmax: "svmax", lvmax: "lvmax", dvmax: "dvmax", cm: "cm", mm: "mm", q: "Q", in: "in", pt: "pt", pc: "pc", px: "px", deg: "deg", grad: "grad", rad: "rad", turn: "turn", s: "s", ms: "ms", hz: "Hz", khz: "kHz", dpi: "dpi", dpcm: "dpcm", dppx: "dppx", x: "x" };
} });
var Nd = te({ "src/language-css/utils/print-unit.js"(e, r) {
  "use strict";
  ne();
  var t = Bd();
  function s(a) {
    let n = a.toLowerCase();
    return Object.prototype.hasOwnProperty.call(t, n) ? t[n] : a;
  }
  r.exports = s;
} });
var wd = te({ "src/language-css/printer-postcss.js"(e, r) {
  "use strict";
  ne();
  var t = lt(), { printNumber: s, printString: a, hasNewline: n, isFrontMatterNode: u, isNextLineEmpty: i, isNonEmptyArray: l } = Ue(), { builders: { join: p, line: d, hardline: y, softline: g, group: c, fill: f, indent: E2, dedent: _, ifBreak: w, breakParent: F }, utils: { removeLines: N, getDocParts: x } } = qe(), I = Cd(), P = Ed(), { insertPragma: $2 } = Fd(), { getAncestorNode: D, getPropOfDeclNode: T, maybeToLowerCase: m, insideValueFunctionNode: C, insideICSSRuleNode: o, insideAtRuleNode: h, insideURLFunctionInImportAtRuleNode: v, isKeyframeAtRuleKeywords: S, isWideKeywords: b, isLastNode: B, isSCSSControlDirectiveNode: k, isDetachedRulesetDeclarationNode: M, isRelationalOperatorNode: R, isEqualityOperatorNode: q, isMultiplicationNode: J2, isDivisionNode: L, isAdditionNode: Q2, isSubtractionNode: V, isMathOperatorNode: j, isEachKeywordNode: Y, isForKeywordNode: ie, isURLFunctionNode: ee, isIfElseKeywordNode: ce, hasComposesNode: W, hasParensAroundNode: K, hasEmptyRawBefore: de, isKeyValuePairNode: ue, isKeyInValuePairNode: Fe, isDetachedRulesetCallNode: z, isTemplatePlaceholderNode: U, isTemplatePropNode: Z, isPostcssSimpleVarNode: se, isSCSSMapItemNode: fe, isInlineValueCommentNode: ge, isHashNode: he, isLeftCurlyBraceNode: we, isRightCurlyBraceNode: ke, isWordNode: Re, isColonNode: Ne, isMediaAndSupportsKeywords: Pe2, isColorAdjusterFuncNode: oe2, lastLineHasInlineComment: H, isAtWordPlaceholderNode: pe, isConfigurationNode: X, isParenGroupNode: le2 } = Ad(), { locStart: Ae, locEnd: Ee } = xd(), De = bd(), A = Td(), G = Nd();
  function re(be2) {
    return be2.trailingComma === "es5" || be2.trailingComma === "all";
  }
  function ye2(be2, je, Me2) {
    let ae = be2.getValue();
    if (!ae) return "";
    if (typeof ae == "string") return ae;
    switch (ae.type) {
      case "front-matter":
        return [ae.raw, y];
      case "css-root": {
        let Ve = Ce(be2, je, Me2), We = ae.raws.after.trim();
        return We.startsWith(";") && (We = We.slice(1).trim()), [Ve, We ? ` ${We}` : "", x(Ve).length > 0 ? y : ""];
      }
      case "css-comment": {
        let Ve = ae.inline || ae.raws.inline, We = je.originalText.slice(Ae(ae), Ee(ae));
        return Ve ? We.trimEnd() : We;
      }
      case "css-rule":
        return [Me2("selector"), ae.important ? " !important" : "", ae.nodes ? [ae.selector && ae.selector.type === "selector-unknown" && H(ae.selector.value) ? d : " ", "{", ae.nodes.length > 0 ? E2([y, Ce(be2, je, Me2)]) : "", y, "}", M(ae) ? ";" : ""] : ";"];
      case "css-decl": {
        let Ve = be2.getParentNode(), { between: We } = ae.raws, Xe = We.trim(), st2 = Xe === ":", O = W(ae) ? N(Me2("value")) : Me2("value");
        return !st2 && H(Xe) && (O = E2([y, _(O)])), [ae.raws.before.replace(/[\s;]/g, ""), Ve.type === "css-atrule" && Ve.variable || o(be2) ? ae.prop : m(ae.prop), Xe.startsWith("//") ? " " : "", Xe, ae.extend ? "" : " ", De(je) && ae.extend && ae.selector ? ["extend(", Me2("selector"), ")"] : "", O, ae.raws.important ? ae.raws.important.replace(/\s*!\s*important/i, " !important") : ae.important ? " !important" : "", ae.raws.scssDefault ? ae.raws.scssDefault.replace(/\s*!default/i, " !default") : ae.scssDefault ? " !default" : "", ae.raws.scssGlobal ? ae.raws.scssGlobal.replace(/\s*!global/i, " !global") : ae.scssGlobal ? " !global" : "", ae.nodes ? [" {", E2([g, Ce(be2, je, Me2)]), g, "}"] : Z(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";" ? "" : je.__isHTMLStyleAttribute && B(be2, ae) ? w(";") : ";"];
      }
      case "css-atrule": {
        let Ve = be2.getParentNode(), We = U(ae) && !Ve.raws.semicolon && je.originalText[Ee(ae) - 1] !== ";";
        if (De(je)) {
          if (ae.mixin) return [Me2("selector"), ae.important ? " !important" : "", We ? "" : ";"];
          if (ae.function) return [ae.name, Me2("params"), We ? "" : ";"];
          if (ae.variable) return ["@", ae.name, ": ", ae.value ? Me2("value") : "", ae.raws.between.trim() ? ae.raws.between.trim() + " " : "", ae.nodes ? ["{", E2([ae.nodes.length > 0 ? g : "", Ce(be2, je, Me2)]), g, "}"] : "", We ? "" : ";"];
        }
        return ["@", z(ae) || ae.name.endsWith(":") ? ae.name : m(ae.name), ae.params ? [z(ae) ? "" : U(ae) ? ae.raws.afterName === "" ? "" : ae.name.endsWith(":") ? " " : /^\s*\n\s*\n/.test(ae.raws.afterName) ? [y, y] : /^\s*\n/.test(ae.raws.afterName) ? y : " " : " ", Me2("params")] : "", ae.selector ? E2([" ", Me2("selector")]) : "", ae.value ? c([" ", Me2("value"), k(ae) ? K(ae) ? " " : d : ""]) : ae.name === "else" ? " " : "", ae.nodes ? [k(ae) ? "" : ae.selector && !ae.selector.nodes && typeof ae.selector.value == "string" && H(ae.selector.value) || !ae.selector && typeof ae.params == "string" && H(ae.params) ? d : " ", "{", E2([ae.nodes.length > 0 ? g : "", Ce(be2, je, Me2)]), g, "}"] : We ? "" : ";"];
      }
      case "media-query-list": {
        let Ve = [];
        return be2.each((We) => {
          let Xe = We.getValue();
          Xe.type === "media-query" && Xe.value === "" || Ve.push(Me2());
        }, "nodes"), c(E2(p(d, Ve)));
      }
      case "media-query":
        return [p(" ", be2.map(Me2, "nodes")), B(be2, ae) ? "" : ","];
      case "media-type":
        return Oe(Se(ae.value, je));
      case "media-feature-expression":
        return ae.nodes ? ["(", ...be2.map(Me2, "nodes"), ")"] : ae.value;
      case "media-feature":
        return m(Se(ae.value.replace(/ +/g, " "), je));
      case "media-colon":
        return [ae.value, " "];
      case "media-value":
        return Oe(Se(ae.value, je));
      case "media-keyword":
        return Se(ae.value, je);
      case "media-url":
        return Se(ae.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/g, ")"), je);
      case "media-unknown":
        return ae.value;
      case "selector-root":
        return c([h(be2, "custom-selector") ? [D(be2, "css-atrule").customSelector, d] : "", p([",", h(be2, ["extend", "custom-selector", "nest"]) ? d : y], be2.map(Me2, "nodes"))]);
      case "selector-selector":
        return c(E2(be2.map(Me2, "nodes")));
      case "selector-comment":
        return ae.value;
      case "selector-string":
        return Se(ae.value, je);
      case "selector-tag": {
        let Ve = be2.getParentNode(), We = Ve && Ve.nodes.indexOf(ae), Xe = We && Ve.nodes[We - 1];
        return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", Xe.type === "selector-nesting" ? ae.value : Oe(S(be2, ae.value) ? ae.value.toLowerCase() : ae.value)];
      }
      case "selector-id":
        return ["#", ae.value];
      case "selector-class":
        return [".", Oe(Se(ae.value, je))];
      case "selector-attribute": {
        var nt2;
        return ["[", ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.attribute.trim(), (nt2 = ae.operator) !== null && nt2 !== void 0 ? nt2 : "", ae.value ? Ie(Se(ae.value.trim(), je), je) : "", ae.insensitive ? " i" : "", "]"];
      }
      case "selector-combinator": {
        if (ae.value === "+" || ae.value === ">" || ae.value === "~" || ae.value === ">>>") {
          let Xe = be2.getParentNode();
          return [Xe.type === "selector-selector" && Xe.nodes[0] === ae ? "" : d, ae.value, B(be2, ae) ? "" : " "];
        }
        let Ve = ae.value.trim().startsWith("(") ? d : "", We = Oe(Se(ae.value.trim(), je)) || d;
        return [Ve, We];
      }
      case "selector-universal":
        return [ae.namespace ? [ae.namespace === true ? "" : ae.namespace.trim(), "|"] : "", ae.value];
      case "selector-pseudo":
        return [m(ae.value), l(ae.nodes) ? c(["(", E2([g, p([",", d], be2.map(Me2, "nodes"))]), g, ")"]) : ""];
      case "selector-nesting":
        return ae.value;
      case "selector-unknown": {
        let Ve = D(be2, "css-rule");
        if (Ve && Ve.isSCSSNesterProperty) return Oe(Se(m(ae.value), je));
        let We = be2.getParentNode();
        if (We.raws && We.raws.selector) {
          let st2 = Ae(We), O = st2 + We.raws.selector.length;
          return je.originalText.slice(st2, O).trim();
        }
        let Xe = be2.getParentNode(1);
        if (We.type === "value-paren_group" && Xe && Xe.type === "value-func" && Xe.value === "selector") {
          let st2 = Ee(We.open) + 1, O = Ae(We.close), me2 = je.originalText.slice(st2, O).trim();
          return H(me2) ? [F, me2] : me2;
        }
        return ae.value;
      }
      case "value-value":
      case "value-root":
        return Me2("group");
      case "value-comment":
        return je.originalText.slice(Ae(ae), Ee(ae));
      case "value-comma_group": {
        let Ve = be2.getParentNode(), We = be2.getParentNode(1), Xe = T(be2), st2 = Xe && Ve.type === "value-value" && (Xe === "grid" || Xe.startsWith("grid-template")), O = D(be2, "css-atrule"), me2 = O && k(O), _e = ae.groups.some((at3) => ge(at3)), He = be2.map(Me2, "groups"), Ge = [], it = C(be2, "url"), Qe = false, rt2 = false;
        for (let at3 = 0; at3 < ae.groups.length; ++at3) {
          var tt2;
          Ge.push(He[at3]);
          let Ze = ae.groups[at3 - 1], Le = ae.groups[at3], $e = ae.groups[at3 + 1], nr = ae.groups[at3 + 2];
          if (it) {
            ($e && Q2($e) || Q2(Le)) && Ge.push(" ");
            continue;
          }
          if (h(be2, "forward") && Le.type === "value-word" && Le.value && Ze !== void 0 && Ze.type === "value-word" && Ze.value === "as" && $e.type === "value-operator" && $e.value === "*" || !$e || Le.type === "value-word" && Le.value.endsWith("-") && pe($e)) continue;
          if (Le.type === "value-string" && Le.quoted) {
            let Mr = Le.value.lastIndexOf("#{"), Rr = Le.value.lastIndexOf("}");
            Mr !== -1 && Rr !== -1 ? Qe = Mr > Rr : Mr !== -1 ? Qe = true : Rr !== -1 && (Qe = false);
          }
          if (Qe || Ne(Le) || Ne($e) || Le.type === "value-atword" && (Le.value === "" || Le.value.endsWith("[")) || $e.type === "value-word" && $e.value.startsWith("]") || Le.value === "~" || Le.value && Le.value.includes("\\") && $e && $e.type !== "value-comment" || Ze && Ze.value && Ze.value.indexOf("\\") === Ze.value.length - 1 && Le.type === "value-operator" && Le.value === "/" || Le.value === "\\" || se(Le, $e) || he(Le) || we(Le) || ke($e) || we($e) && de($e) || ke(Le) && de($e) || Le.value === "--" && he($e)) continue;
          let qr = j(Le), su = j($e);
          if ((qr && he($e) || su && ke(Le)) && de($e) || !Ze && L(Le) || C(be2, "calc") && (Q2(Le) || Q2($e) || V(Le) || V($e)) && de($e)) continue;
          let No = (Q2(Le) || V(Le)) && at3 === 0 && ($e.type === "value-number" || $e.isHex) && We && oe2(We) && !de($e), iu = nr && nr.type === "value-func" || nr && Re(nr) || Le.type === "value-func" || Re(Le), au = $e.type === "value-func" || Re($e) || Ze && Ze.type === "value-func" || Ze && Re(Ze);
          if (!(!(J2($e) || J2(Le)) && !C(be2, "calc") && !No && (L($e) && !iu || L(Le) && !au || Q2($e) && !iu || Q2(Le) && !au || V($e) || V(Le)) && (de($e) || qr && (!Ze || Ze && j(Ze)))) && !((je.parser === "scss" || je.parser === "less") && qr && Le.value === "-" && le2($e) && Ee(Le) === Ae($e.open) && $e.open.value === "(")) {
            if (ge(Le)) {
              if (Ve.type === "value-paren_group") {
                Ge.push(_(y));
                continue;
              }
              Ge.push(y);
              continue;
            }
            if (me2 && (q($e) || R($e) || ce($e) || Y(Le) || ie(Le))) {
              Ge.push(" ");
              continue;
            }
            if (O && O.name.toLowerCase() === "namespace") {
              Ge.push(" ");
              continue;
            }
            if (st2) {
              Le.source && $e.source && Le.source.start.line !== $e.source.start.line ? (Ge.push(y), rt2 = true) : Ge.push(" ");
              continue;
            }
            if (su) {
              Ge.push(" ");
              continue;
            }
            if (!($e && $e.value === "...") && !(pe(Le) && pe($e) && Ee(Le) === Ae($e))) {
              if (pe(Le) && le2($e) && Ee(Le) === Ae($e.open)) {
                Ge.push(g);
                continue;
              }
              if (Le.value === "with" && le2($e)) {
                Ge.push(" ");
                continue;
              }
              (tt2 = Le.value) !== null && tt2 !== void 0 && tt2.endsWith("#") && $e.value === "{" && le2($e.group) || Ge.push(d);
            }
          }
        }
        return _e && Ge.push(F), rt2 && Ge.unshift(y), me2 ? c(E2(Ge)) : v(be2) ? c(f(Ge)) : c(E2(f(Ge)));
      }
      case "value-paren_group": {
        let Ve = be2.getParentNode();
        if (Ve && ee(Ve) && (ae.groups.length === 1 || ae.groups.length > 0 && ae.groups[0].type === "value-comma_group" && ae.groups[0].groups.length > 0 && ae.groups[0].groups[0].type === "value-word" && ae.groups[0].groups[0].value.startsWith("data:"))) return [ae.open ? Me2("open") : "", p(",", be2.map(Me2, "groups")), ae.close ? Me2("close") : ""];
        if (!ae.open) {
          let it = be2.map(Me2, "groups"), Qe = [];
          for (let rt2 = 0; rt2 < it.length; rt2++) rt2 !== 0 && Qe.push([",", d]), Qe.push(it[rt2]);
          return c(E2(f(Qe)));
        }
        let We = fe(be2), Xe = t(ae.groups), st2 = Xe && Xe.type === "value-comment", O = Fe(ae, Ve), me2 = X(ae, Ve), _e = me2 || We && !O, He = me2 || O, Ge = c([ae.open ? Me2("open") : "", E2([g, p([d], be2.map((it, Qe) => {
          let rt2 = it.getValue(), at3 = Qe === ae.groups.length - 1, Ze = [Me2(), at3 ? "" : ","];
          if (ue(rt2) && rt2.type === "value-comma_group" && rt2.groups && rt2.groups[0].type !== "value-paren_group" && rt2.groups[2] && rt2.groups[2].type === "value-paren_group") {
            let Le = x(Ze[0].contents.contents);
            Le[1] = c(Le[1]), Ze = [c(_(Ze))];
          }
          if (!at3 && rt2.type === "value-comma_group" && l(rt2.groups)) {
            let Le = t(rt2.groups);
            !Le.source && Le.close && (Le = Le.close), Le.source && i(je.originalText, Le, Ee) && Ze.push(y);
          }
          return Ze;
        }, "groups"))]), w(!st2 && A(je.parser, je.originalText) && We && re(je) ? "," : ""), g, ae.close ? Me2("close") : ""], { shouldBreak: _e });
        return He ? _(Ge) : Ge;
      }
      case "value-func":
        return [ae.value, h(be2, "supports") && Pe2(ae) ? " " : "", Me2("group")];
      case "value-paren":
        return ae.value;
      case "value-number":
        return [Je(ae.value), G(ae.unit)];
      case "value-operator":
        return ae.value;
      case "value-word":
        return ae.isColor && ae.isHex || b(ae.value) ? ae.value.toLowerCase() : ae.value;
      case "value-colon": {
        let Ve = be2.getParentNode(), We = Ve && Ve.groups.indexOf(ae), Xe = We && Ve.groups[We - 1];
        return [ae.value, Xe && typeof Xe.value == "string" && t(Xe.value) === "\\" || C(be2, "url") ? "" : d];
      }
      case "value-comma":
        return [ae.value, " "];
      case "value-string":
        return a(ae.raws.quote + ae.value + ae.raws.quote, je);
      case "value-atword":
        return ["@", ae.value];
      case "value-unicode-range":
        return ae.value;
      case "value-unknown":
        return ae.value;
      default:
        throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`);
    }
  }
  function Ce(be2, je, Me2) {
    let ae = [];
    return be2.each((nt2, tt2, Ve) => {
      let We = Ve[tt2 - 1];
      if (We && We.type === "css-comment" && We.text.trim() === "prettier-ignore") {
        let Xe = nt2.getValue();
        ae.push(je.originalText.slice(Ae(Xe), Ee(Xe)));
      } else ae.push(Me2());
      tt2 !== Ve.length - 1 && (Ve[tt2 + 1].type === "css-comment" && !n(je.originalText, Ae(Ve[tt2 + 1]), { backwards: true }) && !u(Ve[tt2]) || Ve[tt2 + 1].type === "css-atrule" && Ve[tt2 + 1].name === "else" && Ve[tt2].type !== "css-comment" ? ae.push(" ") : (ae.push(je.__isHTMLStyleAttribute ? d : y), i(je.originalText, nt2.getValue(), Ee) && !u(Ve[tt2]) && ae.push(y)));
    }, "nodes"), ae;
  }
  var Be = /(["'])(?:(?!\1)[^\\]|\\.)*\1/gs, ve = /(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g, ze = /[A-Za-z]+/g, xe2 = /[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g, Ye = new RegExp(Be.source + `|(${xe2.source})?(${ve.source})(${ze.source})?`, "g");
  function Se(be2, je) {
    return be2.replace(Be, (Me2) => a(Me2, je));
  }
  function Ie(be2, je) {
    let Me2 = je.singleQuote ? "'" : '"';
    return be2.includes('"') || be2.includes("'") ? be2 : Me2 + be2 + Me2;
  }
  function Oe(be2) {
    return be2.replace(Ye, (je, Me2, ae, nt2, tt2) => !ae && nt2 ? Je(nt2) + m(tt2 || "") : je);
  }
  function Je(be2) {
    return s(be2).replace(/\.0(?=$|e)/, "");
  }
  r.exports = { print: ye2, embed: P, insertPragma: $2, massageAstNode: I };
} });
var _d = te({ "src/language-css/options.js"(e, r) {
  "use strict";
  ne();
  var t = jt();
  r.exports = { singleQuote: t.singleQuote };
} });
var Pd = te({ "src/language-css/parsers.js"() {
  ne();
} });
var Id = te({ "node_modules/linguist-languages/data/CSS.json"(e, r) {
  r.exports = { name: "CSS", type: "markup", tmScope: "source.css", aceMode: "css", codemirrorMode: "css", codemirrorMimeType: "text/css", color: "#563d7c", extensions: [".css"], languageId: 50 };
} });
var kd = te({ "node_modules/linguist-languages/data/PostCSS.json"(e, r) {
  r.exports = { name: "PostCSS", type: "markup", color: "#dc3a0c", tmScope: "source.postcss", group: "CSS", extensions: [".pcss", ".postcss"], aceMode: "text", languageId: 262764437 };
} });
var Ld = te({ "node_modules/linguist-languages/data/Less.json"(e, r) {
  r.exports = { name: "Less", type: "markup", color: "#1d365d", aliases: ["less-css"], extensions: [".less"], tmScope: "source.css.less", aceMode: "less", codemirrorMode: "css", codemirrorMimeType: "text/css", languageId: 198 };
} });
var Od = te({ "node_modules/linguist-languages/data/SCSS.json"(e, r) {
  r.exports = { name: "SCSS", type: "markup", color: "#c6538c", tmScope: "source.css.scss", aceMode: "scss", codemirrorMode: "css", codemirrorMimeType: "text/x-scss", extensions: [".scss"], languageId: 329 };
} });
var jd = te({ "src/language-css/index.js"(e, r) {
  "use strict";
  ne();
  var t = wt(), s = wd(), a = _d(), n = Pd(), u = [t(Id(), (l) => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["css"], extensions: [...l.extensions, ".wxss"] })), t(kd(), () => ({ since: "1.4.0", parsers: ["css"], vscodeLanguageIds: ["postcss"] })), t(Ld(), () => ({ since: "1.4.0", parsers: ["less"], vscodeLanguageIds: ["less"] })), t(Od(), () => ({ since: "1.4.0", parsers: ["scss"], vscodeLanguageIds: ["scss"] }))], i = { postcss: s };
  r.exports = { languages: u, options: a, printers: i, parsers: n };
} });
var qd = te({ "src/language-handlebars/loc.js"(e, r) {
  "use strict";
  ne();
  function t(a) {
    return a.loc.start.offset;
  }
  function s(a) {
    return a.loc.end.offset;
  }
  r.exports = { locStart: t, locEnd: s };
} });
var Md = te({ "src/language-handlebars/clean.js"(e, r) {
  "use strict";
  ne();
  function t(s, a) {
    if (s.type === "TextNode") {
      let n = s.chars.trim();
      if (!n) return null;
      a.chars = n.replace(/[\t\n\f\r ]+/g, " ");
    }
    s.type === "AttrNode" && s.name.toLowerCase() === "class" && delete a.value;
  }
  t.ignoredProperties = /* @__PURE__ */ new Set(["loc", "selfClosing"]), r.exports = t;
} });
var Rd = te({ "src/language-handlebars/html-void-elements.evaluate.js"(e, r) {
  r.exports = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
} });
var $d = te({ "src/language-handlebars/utils.js"(e, r) {
  "use strict";
  ne();
  var t = lt(), s = Rd();
  function a(x) {
    let I = x.getValue(), P = x.getParentNode(0);
    return !!(g(x, ["ElementNode"]) && t(P.children) === I || g(x, ["Block"]) && t(P.body) === I);
  }
  function n(x) {
    return x.toUpperCase() === x;
  }
  function u(x) {
    return y(x, ["ElementNode"]) && typeof x.tag == "string" && !x.tag.startsWith(":") && (n(x.tag[0]) || x.tag.includes("."));
  }
  var i = new Set(s);
  function l(x) {
    return i.has(x.toLowerCase()) && !n(x[0]);
  }
  function p(x) {
    return x.selfClosing === true || l(x.tag) || u(x) && x.children.every((I) => d(I));
  }
  function d(x) {
    return y(x, ["TextNode"]) && !/\S/.test(x.chars);
  }
  function y(x, I) {
    return x && I.includes(x.type);
  }
  function g(x, I) {
    let P = x.getParentNode(0);
    return y(P, I);
  }
  function c(x, I) {
    let P = _(x);
    return y(P, I);
  }
  function f(x, I) {
    let P = w(x);
    return y(P, I);
  }
  function E2(x, I) {
    var P, $2, D, T;
    let m = x.getValue(), C = (P = x.getParentNode(0)) !== null && P !== void 0 ? P : {}, o = ($2 = (D = (T = C.children) !== null && T !== void 0 ? T : C.body) !== null && D !== void 0 ? D : C.parts) !== null && $2 !== void 0 ? $2 : [], h = o.indexOf(m);
    return h !== -1 && o[h + I];
  }
  function _(x) {
    let I = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return E2(x, -I);
  }
  function w(x) {
    return E2(x, 1);
  }
  function F(x) {
    return y(x, ["MustacheCommentStatement"]) && typeof x.value == "string" && x.value.trim() === "prettier-ignore";
  }
  function N(x) {
    let I = x.getValue(), P = _(x, 2);
    return F(I) || F(P);
  }
  r.exports = { getNextNode: w, getPreviousNode: _, hasPrettierIgnore: N, isLastNodeOfSiblings: a, isNextNodeOfSomeType: f, isNodeOfSomeType: y, isParentOfSomeType: g, isPreviousNodeOfSomeType: c, isVoid: p, isWhitespaceNode: d };
} });
var Vd = te({ "src/language-handlebars/printer-glimmer.js"(e, r) {
  "use strict";
  ne();
  var { builders: { dedent: t, fill: s, group: a, hardline: n, ifBreak: u, indent: i, join: l, line: p, softline: d }, utils: { getDocParts: y, replaceTextEndOfLine: g } } = qe(), { getPreferredQuote: c, isNonEmptyArray: f } = Ue(), { locStart: E2, locEnd: _ } = qd(), w = Md(), { getNextNode: F, getPreviousNode: N, hasPrettierIgnore: x, isLastNodeOfSiblings: I, isNextNodeOfSomeType: P, isNodeOfSomeType: $2, isParentOfSomeType: D, isPreviousNodeOfSomeType: T, isVoid: m, isWhitespaceNode: C } = $d(), o = 2;
  function h(H, pe, X) {
    let le2 = H.getValue();
    if (!le2) return "";
    if (x(H)) return pe.originalText.slice(E2(le2), _(le2));
    let Ae = pe.singleQuote ? "'" : '"';
    switch (le2.type) {
      case "Block":
      case "Program":
      case "Template":
        return a(H.map(X, "body"));
      case "ElementNode": {
        let Ee = a(S(H, X)), De = pe.htmlWhitespaceSensitivity === "ignore" && P(H, ["ElementNode"]) ? d : "";
        if (m(le2)) return [Ee, De];
        let A = ["</", le2.tag, ">"];
        return le2.children.length === 0 ? [Ee, i(A), De] : pe.htmlWhitespaceSensitivity === "ignore" ? [Ee, i(b(H, pe, X)), n, i(A), De] : [Ee, i(a(b(H, pe, X))), i(A), De];
      }
      case "BlockStatement": {
        let Ee = H.getParentNode(1);
        return Ee && Ee.inverse && Ee.inverse.body.length === 1 && Ee.inverse.body[0] === le2 && Ee.inverse.body[0].path.parts[0] === Ee.path.parts[0] ? [ie(H, X, Ee.inverse.body[0].path.parts[0]), de(H, X, pe), ue(H, X, pe)] : [j(H, X), a([de(H, X, pe), ue(H, X, pe), ee(H, X, pe)])];
      }
      case "ElementModifierStatement":
        return a(["{{", Re(H, X), "}}"]);
      case "MustacheStatement":
        return a([k(le2), Re(H, X), M(le2)]);
      case "SubExpression":
        return a(["(", ke(H, X), d, ")"]);
      case "AttrNode": {
        let Ee = le2.value.type === "TextNode";
        if (Ee && le2.value.chars === "" && E2(le2.value) === _(le2.value)) return le2.name;
        let A = Ee ? c(le2.value.chars, Ae).quote : le2.value.type === "ConcatStatement" ? c(le2.value.parts.filter((re) => re.type === "TextNode").map((re) => re.chars).join(""), Ae).quote : "", G = X("value");
        return [le2.name, "=", A, le2.name === "class" && A ? a(i(G)) : G, A];
      }
      case "ConcatStatement":
        return H.map(X, "parts");
      case "Hash":
        return l(p, H.map(X, "pairs"));
      case "HashPair":
        return [le2.key, "=", X("value")];
      case "TextNode": {
        let Ee = le2.chars.replace(/{{/g, "\\{{"), De = U(H);
        if (De) {
          if (De === "class") {
            let Ye = Ee.trim().split(/\s+/).join(" "), Se = false, Ie = false;
            return D(H, ["ConcatStatement"]) && (T(H, ["MustacheStatement"]) && /^\s/.test(Ee) && (Se = true), P(H, ["MustacheStatement"]) && /\s$/.test(Ee) && Ye !== "" && (Ie = true)), [Se ? p : "", Ye, Ie ? p : ""];
          }
          return g(Ee);
        }
        let G = /^[\t\n\f\r ]*$/.test(Ee), re = !N(H), ye2 = !F(H);
        if (pe.htmlWhitespaceSensitivity !== "ignore") {
          let Ye = /^[\t\n\f\r ]*/, Se = /[\t\n\f\r ]*$/, Ie = ye2 && D(H, ["Template"]), Oe = re && D(H, ["Template"]);
          if (G) {
            if (Oe || Ie) return "";
            let ae = [p], nt2 = Z(Ee);
            return nt2 && (ae = ge(nt2)), I(H) && (ae = ae.map((tt2) => t(tt2))), ae;
          }
          let [Je] = Ee.match(Ye), [be2] = Ee.match(Se), je = [];
          if (Je) {
            je = [p];
            let ae = Z(Je);
            ae && (je = ge(ae)), Ee = Ee.replace(Ye, "");
          }
          let Me2 = [];
          if (be2) {
            if (!Ie) {
              Me2 = [p];
              let ae = Z(be2);
              ae && (Me2 = ge(ae)), I(H) && (Me2 = Me2.map((nt2) => t(nt2)));
            }
            Ee = Ee.replace(Se, "");
          }
          return [...je, s(Fe(Ee)), ...Me2];
        }
        let Ce = Z(Ee), Be = se(Ee), ve = fe(Ee);
        if ((re || ye2) && G && D(H, ["Block", "ElementNode", "Template"])) return "";
        G && Ce ? (Be = Math.min(Ce, o), ve = 0) : (P(H, ["BlockStatement", "ElementNode"]) && (ve = Math.max(ve, 1)), T(H, ["BlockStatement", "ElementNode"]) && (Be = Math.max(Be, 1)));
        let ze = "", xe2 = "";
        return ve === 0 && P(H, ["MustacheStatement"]) && (xe2 = " "), Be === 0 && T(H, ["MustacheStatement"]) && (ze = " "), re && (Be = 0, ze = ""), ye2 && (ve = 0, xe2 = ""), Ee = Ee.replace(/^[\t\n\f\r ]+/g, ze).replace(/[\t\n\f\r ]+$/, xe2), [...ge(Be), s(Fe(Ee)), ...ge(ve)];
      }
      case "MustacheCommentStatement": {
        let Ee = E2(le2), De = _(le2), A = pe.originalText.charAt(Ee + 2) === "~", G = pe.originalText.charAt(De - 3) === "~", re = le2.value.includes("}}") ? "--" : "";
        return ["{{", A ? "~" : "", "!", re, le2.value, re, G ? "~" : "", "}}"];
      }
      case "PathExpression":
        return le2.original;
      case "BooleanLiteral":
        return String(le2.value);
      case "CommentStatement":
        return ["<!--", le2.value, "-->"];
      case "StringLiteral": {
        if (we(H)) {
          let Ee = pe.singleQuote ? '"' : "'";
          return he(le2.value, Ee);
        }
        return he(le2.value, Ae);
      }
      case "NumberLiteral":
        return String(le2.value);
      case "UndefinedLiteral":
        return "undefined";
      case "NullLiteral":
        return "null";
      default:
        throw new Error("unknown glimmer type: " + JSON.stringify(le2.type));
    }
  }
  function v(H, pe) {
    return E2(H) - E2(pe);
  }
  function S(H, pe) {
    let X = H.getValue(), le2 = ["attributes", "modifiers", "comments"].filter((Ee) => f(X[Ee])), Ae = le2.flatMap((Ee) => X[Ee]).sort(v);
    for (let Ee of le2) H.each((De) => {
      let A = Ae.indexOf(De.getValue());
      Ae.splice(A, 1, [p, pe()]);
    }, Ee);
    return f(X.blockParams) && Ae.push(p, oe2(X)), ["<", X.tag, i(Ae), B(X)];
  }
  function b(H, pe, X) {
    let Ae = H.getValue().children.every((Ee) => C(Ee));
    return pe.htmlWhitespaceSensitivity === "ignore" && Ae ? "" : H.map((Ee, De) => {
      let A = X();
      return De === 0 && pe.htmlWhitespaceSensitivity === "ignore" ? [d, A] : A;
    }, "children");
  }
  function B(H) {
    return m(H) ? u([d, "/>"], [" />", d]) : u([d, ">"], ">");
  }
  function k(H) {
    let pe = H.escaped === false ? "{{{" : "{{", X = H.strip && H.strip.open ? "~" : "";
    return [pe, X];
  }
  function M(H) {
    let pe = H.escaped === false ? "}}}" : "}}";
    return [H.strip && H.strip.close ? "~" : "", pe];
  }
  function R(H) {
    let pe = k(H), X = H.openStrip.open ? "~" : "";
    return [pe, X, "#"];
  }
  function q(H) {
    let pe = M(H);
    return [H.openStrip.close ? "~" : "", pe];
  }
  function J2(H) {
    let pe = k(H), X = H.closeStrip.open ? "~" : "";
    return [pe, X, "/"];
  }
  function L(H) {
    let pe = M(H);
    return [H.closeStrip.close ? "~" : "", pe];
  }
  function Q2(H) {
    let pe = k(H), X = H.inverseStrip.open ? "~" : "";
    return [pe, X];
  }
  function V(H) {
    let pe = M(H);
    return [H.inverseStrip.close ? "~" : "", pe];
  }
  function j(H, pe) {
    let X = H.getValue(), le2 = [], Ae = Pe2(H, pe);
    return Ae && le2.push(a(Ae)), f(X.program.blockParams) && le2.push(oe2(X.program)), a([R(X), Ne(H, pe), le2.length > 0 ? i([p, l(p, le2)]) : "", d, q(X)]);
  }
  function Y(H, pe) {
    return [pe.htmlWhitespaceSensitivity === "ignore" ? n : "", Q2(H), "else", V(H)];
  }
  function ie(H, pe, X) {
    let le2 = H.getValue(), Ae = H.getParentNode(1);
    return a([Q2(Ae), ["else", " ", X], i([p, a(Pe2(H, pe)), ...f(le2.program.blockParams) ? [p, oe2(le2.program)] : []]), d, V(Ae)]);
  }
  function ee(H, pe, X) {
    let le2 = H.getValue();
    return X.htmlWhitespaceSensitivity === "ignore" ? [ce(le2) ? d : n, J2(le2), pe("path"), L(le2)] : [J2(le2), pe("path"), L(le2)];
  }
  function ce(H) {
    return $2(H, ["BlockStatement"]) && H.program.body.every((pe) => C(pe));
  }
  function W(H) {
    return K(H) && H.inverse.body.length === 1 && $2(H.inverse.body[0], ["BlockStatement"]) && H.inverse.body[0].path.parts[0] === H.path.parts[0];
  }
  function K(H) {
    return $2(H, ["BlockStatement"]) && H.inverse;
  }
  function de(H, pe, X) {
    let le2 = H.getValue();
    if (ce(le2)) return "";
    let Ae = pe("program");
    return X.htmlWhitespaceSensitivity === "ignore" ? i([n, Ae]) : i(Ae);
  }
  function ue(H, pe, X) {
    let le2 = H.getValue(), Ae = pe("inverse"), Ee = X.htmlWhitespaceSensitivity === "ignore" ? [n, Ae] : Ae;
    return W(le2) ? Ee : K(le2) ? [Y(le2, X), i(Ee)] : "";
  }
  function Fe(H) {
    return y(l(p, z(H)));
  }
  function z(H) {
    return H.split(/[\t\n\f\r ]+/);
  }
  function U(H) {
    for (let pe = 0; pe < 2; pe++) {
      let X = H.getParentNode(pe);
      if (X && X.type === "AttrNode") return X.name.toLowerCase();
    }
  }
  function Z(H) {
    return H = typeof H == "string" ? H : "", H.split(`
`).length - 1;
  }
  function se(H) {
    H = typeof H == "string" ? H : "";
    let pe = (H.match(/^([^\S\n\r]*[\n\r])+/g) || [])[0] || "";
    return Z(pe);
  }
  function fe(H) {
    H = typeof H == "string" ? H : "";
    let pe = (H.match(/([\n\r][^\S\n\r]*)+$/g) || [])[0] || "";
    return Z(pe);
  }
  function ge() {
    let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return Array.from({ length: Math.min(H, o) }).fill(n);
  }
  function he(H, pe) {
    let { quote: X, regex: le2 } = c(H, pe);
    return [X, H.replace(le2, `\\${X}`), X];
  }
  function we(H) {
    let pe = 0, X = H.getParentNode(pe);
    for (; X && $2(X, ["SubExpression"]); ) pe++, X = H.getParentNode(pe);
    return !!(X && $2(H.getParentNode(pe + 1), ["ConcatStatement"]) && $2(H.getParentNode(pe + 2), ["AttrNode"]));
  }
  function ke(H, pe) {
    let X = Ne(H, pe), le2 = Pe2(H, pe);
    return le2 ? i([X, p, a(le2)]) : X;
  }
  function Re(H, pe) {
    let X = Ne(H, pe), le2 = Pe2(H, pe);
    return le2 ? [i([X, p, le2]), d] : X;
  }
  function Ne(H, pe) {
    return pe("path");
  }
  function Pe2(H, pe) {
    let X = H.getValue(), le2 = [];
    if (X.params.length > 0) {
      let Ae = H.map(pe, "params");
      le2.push(...Ae);
    }
    if (X.hash && X.hash.pairs.length > 0) {
      let Ae = pe("hash");
      le2.push(Ae);
    }
    return le2.length === 0 ? "" : l(p, le2);
  }
  function oe2(H) {
    return ["as |", H.blockParams.join(" "), "|"];
  }
  r.exports = { print: h, massageAstNode: w };
} });
var Wd = te({ "src/language-handlebars/parsers.js"() {
  ne();
} });
var Hd = te({ "node_modules/linguist-languages/data/Handlebars.json"(e, r) {
  r.exports = { name: "Handlebars", type: "markup", color: "#f7931e", aliases: ["hbs", "htmlbars"], extensions: [".handlebars", ".hbs"], tmScope: "text.html.handlebars", aceMode: "handlebars", languageId: 155 };
} });
var Gd = te({ "src/language-handlebars/index.js"(e, r) {
  "use strict";
  ne();
  var t = wt(), s = Vd(), a = Wd(), n = [t(Hd(), () => ({ since: "2.3.0", parsers: ["glimmer"], vscodeLanguageIds: ["handlebars"] }))], u = { glimmer: s };
  r.exports = { languages: n, printers: u, parsers: a };
} });
var Ud = te({ "src/language-graphql/pragma.js"(e, r) {
  "use strict";
  ne();
  function t(a) {
    return /^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a);
  }
  function s(a) {
    return `# @format

` + a;
  }
  r.exports = { hasPragma: t, insertPragma: s };
} });
var Jd = te({ "src/language-graphql/loc.js"(e, r) {
  "use strict";
  ne();
  function t(a) {
    return typeof a.start == "number" ? a.start : a.loc && a.loc.start;
  }
  function s(a) {
    return typeof a.end == "number" ? a.end : a.loc && a.loc.end;
  }
  r.exports = { locStart: t, locEnd: s };
} });
var zd = te({ "src/language-graphql/printer-graphql.js"(e, r) {
  "use strict";
  ne();
  var { builders: { join: t, hardline: s, line: a, softline: n, group: u, indent: i, ifBreak: l } } = qe(), { isNextLineEmpty: p, isNonEmptyArray: d } = Ue(), { insertPragma: y } = Ud(), { locStart: g, locEnd: c } = Jd();
  function f(P, $2, D) {
    let T = P.getValue();
    if (!T) return "";
    if (typeof T == "string") return T;
    switch (T.kind) {
      case "Document": {
        let m = [];
        return P.each((C, o, h) => {
          m.push(D()), o !== h.length - 1 && (m.push(s), p($2.originalText, C.getValue(), c) && m.push(s));
        }, "definitions"), [...m, s];
      }
      case "OperationDefinition": {
        let m = $2.originalText[g(T)] !== "{", C = Boolean(T.name);
        return [m ? T.operation : "", m && C ? [" ", D("name")] : "", m && !C && d(T.variableDefinitions) ? " " : "", d(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", E2(P, D, T), T.selectionSet ? !m && !C ? "" : " " : "", D("selectionSet")];
      }
      case "FragmentDefinition":
        return ["fragment ", D("name"), d(T.variableDefinitions) ? u(["(", i([n, t([l("", ", "), n], P.map(D, "variableDefinitions"))]), n, ")"]) : "", " on ", D("typeCondition"), E2(P, D, T), " ", D("selectionSet")];
      case "SelectionSet":
        return ["{", i([s, t(s, _(P, $2, D, "selections"))]), s, "}"];
      case "Field":
        return u([T.alias ? [D("alias"), ": "] : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", E2(P, D, T), T.selectionSet ? " " : "", D("selectionSet")]);
      case "Name":
        return T.value;
      case "StringValue": {
        if (T.block) {
          let m = T.value.replace(/"""/g, "\\$&").split(`
`);
          return m.length === 1 && (m[0] = m[0].trim()), m.every((C) => C === "") && (m.length = 0), t(s, ['"""', ...m, '"""']);
        }
        return ['"', T.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"'];
      }
      case "IntValue":
      case "FloatValue":
      case "EnumValue":
        return T.value;
      case "BooleanValue":
        return T.value ? "true" : "false";
      case "NullValue":
        return "null";
      case "Variable":
        return ["$", D("name")];
      case "ListValue":
        return u(["[", i([n, t([l("", ", "), n], P.map(D, "values"))]), n, "]"]);
      case "ObjectValue":
        return u(["{", $2.bracketSpacing && T.fields.length > 0 ? " " : "", i([n, t([l("", ", "), n], P.map(D, "fields"))]), n, l("", $2.bracketSpacing && T.fields.length > 0 ? " " : ""), "}"]);
      case "ObjectField":
      case "Argument":
        return [D("name"), ": ", D("value")];
      case "Directive":
        return ["@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : ""];
      case "NamedType":
        return D("name");
      case "VariableDefinition":
        return [D("variable"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", E2(P, D, T)];
      case "ObjectTypeExtension":
      case "ObjectTypeDefinition":
        return [D("description"), T.description ? s : "", T.kind === "ObjectTypeExtension" ? "extend " : "", "type ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $2, D)] : "", E2(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "fields"))]), s, "}"] : ""];
      case "FieldDefinition":
        return [D("description"), T.description ? s : "", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", ": ", D("type"), E2(P, D, T)];
      case "DirectiveDefinition":
        return [D("description"), T.description ? s : "", "directive ", "@", D("name"), T.arguments.length > 0 ? u(["(", i([n, t([l("", ", "), n], _(P, $2, D, "arguments"))]), n, ")"]) : "", T.repeatable ? " repeatable" : "", " on ", t(" | ", P.map(D, "locations"))];
      case "EnumTypeExtension":
      case "EnumTypeDefinition":
        return [D("description"), T.description ? s : "", T.kind === "EnumTypeExtension" ? "extend " : "", "enum ", D("name"), E2(P, D, T), T.values.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "values"))]), s, "}"] : ""];
      case "EnumValueDefinition":
        return [D("description"), T.description ? s : "", D("name"), E2(P, D, T)];
      case "InputValueDefinition":
        return [D("description"), T.description ? T.description.block ? s : a : "", D("name"), ": ", D("type"), T.defaultValue ? [" = ", D("defaultValue")] : "", E2(P, D, T)];
      case "InputObjectTypeExtension":
      case "InputObjectTypeDefinition":
        return [D("description"), T.description ? s : "", T.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", D("name"), E2(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "fields"))]), s, "}"] : ""];
      case "SchemaExtension":
        return ["extend schema", E2(P, D, T), ...T.operationTypes.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "operationTypes"))]), s, "}"] : []];
      case "SchemaDefinition":
        return [D("description"), T.description ? s : "", "schema", E2(P, D, T), " {", T.operationTypes.length > 0 ? i([s, t(s, _(P, $2, D, "operationTypes"))]) : "", s, "}"];
      case "OperationTypeDefinition":
        return [D("operation"), ": ", D("type")];
      case "InterfaceTypeExtension":
      case "InterfaceTypeDefinition":
        return [D("description"), T.description ? s : "", T.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", D("name"), T.interfaces.length > 0 ? [" implements ", ...N(P, $2, D)] : "", E2(P, D, T), T.fields.length > 0 ? [" {", i([s, t(s, _(P, $2, D, "fields"))]), s, "}"] : ""];
      case "FragmentSpread":
        return ["...", D("name"), E2(P, D, T)];
      case "InlineFragment":
        return ["...", T.typeCondition ? [" on ", D("typeCondition")] : "", E2(P, D, T), " ", D("selectionSet")];
      case "UnionTypeExtension":
      case "UnionTypeDefinition":
        return u([D("description"), T.description ? s : "", u([T.kind === "UnionTypeExtension" ? "extend " : "", "union ", D("name"), E2(P, D, T), T.types.length > 0 ? [" =", l("", " "), i([l([a, "  "]), t([a, "| "], P.map(D, "types"))])] : ""])]);
      case "ScalarTypeExtension":
      case "ScalarTypeDefinition":
        return [D("description"), T.description ? s : "", T.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", D("name"), E2(P, D, T)];
      case "NonNullType":
        return [D("type"), "!"];
      case "ListType":
        return ["[", D("type"), "]"];
      default:
        throw new Error("unknown graphql type: " + JSON.stringify(T.kind));
    }
  }
  function E2(P, $2, D) {
    if (D.directives.length === 0) return "";
    let T = t(a, P.map($2, "directives"));
    return D.kind === "FragmentDefinition" || D.kind === "OperationDefinition" ? u([a, T]) : [" ", u(i([n, T]))];
  }
  function _(P, $2, D, T) {
    return P.map((m, C, o) => {
      let h = D();
      return C < o.length - 1 && p($2.originalText, m.getValue(), c) ? [h, s] : h;
    }, T);
  }
  function w(P) {
    return P.kind && P.kind !== "Comment";
  }
  function F(P) {
    let $2 = P.getValue();
    if ($2.kind === "Comment") return "#" + $2.value.trimEnd();
    throw new Error("Not a comment: " + JSON.stringify($2));
  }
  function N(P, $2, D) {
    let T = P.getNode(), m = [], { interfaces: C } = T, o = P.map((h) => D(h), "interfaces");
    for (let h = 0; h < C.length; h++) {
      let v = C[h];
      m.push(o[h]);
      let S = C[h + 1];
      if (S) {
        let b = $2.originalText.slice(v.loc.end, S.loc.start), B = b.includes("#"), k = b.replace(/#.*/g, "").trim();
        m.push(k === "," ? "," : " &", B ? a : " ");
      }
    }
    return m;
  }
  function x(P, $2) {
    P.kind === "StringValue" && P.block && !P.value.includes(`
`) && ($2.value = $2.value.trim());
  }
  x.ignoredProperties = /* @__PURE__ */ new Set(["loc", "comments"]);
  function I(P) {
    var $2;
    let D = P.getValue();
    return D == null || ($2 = D.comments) === null || $2 === void 0 ? void 0 : $2.some((T) => T.value.trim() === "prettier-ignore");
  }
  r.exports = { print: f, massageAstNode: x, hasPrettierIgnore: I, insertPragma: y, printComment: F, canAttachComment: w };
} });
var Xd = te({ "src/language-graphql/options.js"(e, r) {
  "use strict";
  ne();
  var t = jt();
  r.exports = { bracketSpacing: t.bracketSpacing };
} });
var Kd = te({ "src/language-graphql/parsers.js"() {
  ne();
} });
var Yd = te({ "node_modules/linguist-languages/data/GraphQL.json"(e, r) {
  r.exports = { name: "GraphQL", type: "data", color: "#e10098", extensions: [".graphql", ".gql", ".graphqls"], tmScope: "source.graphql", aceMode: "text", languageId: 139 };
} });
var Qd = te({ "src/language-graphql/index.js"(e, r) {
  "use strict";
  ne();
  var t = wt(), s = zd(), a = Xd(), n = Kd(), u = [t(Yd(), () => ({ since: "1.5.0", parsers: ["graphql"], vscodeLanguageIds: ["graphql"] }))], i = { graphql: s };
  r.exports = { languages: u, options: a, printers: i, parsers: n };
} });
var So = te({ "node_modules/collapse-white-space/index.js"(e, r) {
  "use strict";
  ne(), r.exports = t;
  function t(s) {
    return String(s).replace(/\s+/g, " ");
  }
} });
var xo = te({ "src/language-markdown/loc.js"(e, r) {
  "use strict";
  ne();
  function t(a) {
    return a.position.start.offset;
  }
  function s(a) {
    return a.position.end.offset;
  }
  r.exports = { locStart: t, locEnd: s };
} });
var Zd = te({ "src/language-markdown/constants.evaluate.js"(e, r) {
  r.exports = { cjkPattern: "(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?", kPattern: "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]", punctuationPattern: "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]" };
} });
var nu = te({ "src/language-markdown/utils.js"(e, r) {
  "use strict";
  ne();
  var { getLast: t } = Ue(), { locStart: s, locEnd: a } = xo(), { cjkPattern: n, kPattern: u, punctuationPattern: i } = Zd(), l = ["liquidNode", "inlineCode", "emphasis", "esComment", "strong", "delete", "wikiLink", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"], p = [...l, "tableCell", "paragraph", "heading"], d = new RegExp(u), y = new RegExp(i);
  function g(F, N) {
    let x = "non-cjk", I = "cj-letter", P = "k-letter", $2 = "cjk-punctuation", D = [], T = (N.proseWrap === "preserve" ? F : F.replace(new RegExp(`(${n})
(${n})`, "g"), "$1$2")).split(/([\t\n ]+)/);
    for (let [C, o] of T.entries()) {
      if (C % 2 === 1) {
        D.push({ type: "whitespace", value: /\n/.test(o) ? `
` : " " });
        continue;
      }
      if ((C === 0 || C === T.length - 1) && o === "") continue;
      let h = o.split(new RegExp(`(${n})`));
      for (let [v, S] of h.entries()) if (!((v === 0 || v === h.length - 1) && S === "")) {
        if (v % 2 === 0) {
          S !== "" && m({ type: "word", value: S, kind: x, hasLeadingPunctuation: y.test(S[0]), hasTrailingPunctuation: y.test(t(S)) });
          continue;
        }
        m(y.test(S) ? { type: "word", value: S, kind: $2, hasLeadingPunctuation: true, hasTrailingPunctuation: true } : { type: "word", value: S, kind: d.test(S) ? P : I, hasLeadingPunctuation: false, hasTrailingPunctuation: false });
      }
    }
    return D;
    function m(C) {
      let o = t(D);
      o && o.type === "word" && (o.kind === x && C.kind === I && !o.hasTrailingPunctuation || o.kind === I && C.kind === x && !C.hasLeadingPunctuation ? D.push({ type: "whitespace", value: " " }) : !h(x, $2) && ![o.value, C.value].some((v) => /\u3000/.test(v)) && D.push({ type: "whitespace", value: "" })), D.push(C);
      function h(v, S) {
        return o.kind === v && C.kind === S || o.kind === S && C.kind === v;
      }
    }
  }
  function c(F, N) {
    let [, x, I, P] = N.slice(F.position.start.offset, F.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);
    return { numberText: x, marker: I, leadingSpaces: P };
  }
  function f(F, N) {
    if (!F.ordered || F.children.length < 2) return false;
    let x = Number(c(F.children[0], N.originalText).numberText), I = Number(c(F.children[1], N.originalText).numberText);
    if (x === 0 && F.children.length > 2) {
      let P = Number(c(F.children[2], N.originalText).numberText);
      return I === 1 && P === 1;
    }
    return I === 1;
  }
  function E2(F, N) {
    let { value: x } = F;
    return F.position.end.offset === N.length && x.endsWith(`
`) && N.endsWith(`
`) ? x.slice(0, -1) : x;
  }
  function _(F, N) {
    return function x(I, P, $2) {
      let D = Object.assign({}, N(I, P, $2));
      return D.children && (D.children = D.children.map((T, m) => x(T, m, [D, ...$2]))), D;
    }(F, null, []);
  }
  function w(F) {
    if ((F == null ? void 0 : F.type) !== "link" || F.children.length !== 1) return false;
    let [N] = F.children;
    return s(F) === s(N) && a(F) === a(N);
  }
  r.exports = { mapAst: _, splitText: g, punctuationPattern: i, getFencedCodeBlockValue: E2, getOrderedListItemInfo: c, hasGitDiffFriendlyOrderedList: f, INLINE_NODE_TYPES: l, INLINE_NODE_WRAPPER_TYPES: p, isAutolink: w };
} });
var eg = te({ "src/language-markdown/embed.js"(e, r) {
  "use strict";
  ne();
  var { inferParserByLanguage: t, getMaxContinuousCount: s } = Ue(), { builders: { hardline: a, markAsRoot: n }, utils: { replaceEndOfLine: u } } = qe(), i = ru(), { getFencedCodeBlockValue: l } = nu();
  function p(d, y, g, c) {
    let f = d.getValue();
    if (f.type === "code" && f.lang !== null) {
      let E2 = t(f.lang, c);
      if (E2) {
        let _ = c.__inJsTemplate ? "~" : "`", w = _.repeat(Math.max(3, s(f.value, _) + 1)), F = { parser: E2 };
        f.lang === "tsx" && (F.filepath = "dummy.tsx");
        let N = g(l(f, c.originalText), F, { stripTrailingHardline: true });
        return n([w, f.lang, f.meta ? " " + f.meta : "", a, u(N), a, w]);
      }
    }
    switch (f.type) {
      case "front-matter":
        return i(f, g);
      case "importExport":
        return [g(f.value, { parser: "babel" }, { stripTrailingHardline: true }), a];
      case "jsx":
        return g(`<$>${f.value}</$>`, { parser: "__js_expression", rootMarker: "mdx" }, { stripTrailingHardline: true });
    }
    return null;
  }
  r.exports = p;
} });
var bo = te({ "src/language-markdown/pragma.js"(e, r) {
  "use strict";
  ne();
  var t = Ao(), s = ["format", "prettier"];
  function a(n) {
    let u = `@(${s.join("|")})`, i = new RegExp([`<!--\\s*${u}\\s*-->`, `{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`, `<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"), "m"), l = n.match(i);
    return (l == null ? void 0 : l.index) === 0;
  }
  r.exports = { startWithPragma: a, hasPragma: (n) => a(t(n).content.trimStart()), insertPragma: (n) => {
    let u = t(n), i = `<!-- @${s[0]} -->`;
    return u.frontMatter ? `${u.frontMatter.raw}

${i}

${u.content}` : `${i}

${u.content}`;
  } };
} });
var tg = te({ "src/language-markdown/print-preprocess.js"(e, r) {
  "use strict";
  ne();
  var t = lt(), { getOrderedListItemInfo: s, mapAst: a, splitText: n } = nu(), u = /^.$/su;
  function i(w, F) {
    return w = d(w, F), w = c(w), w = p(w, F), w = E2(w, F), w = _(w, F), w = f(w, F), w = l(w), w = y(w), w;
  }
  function l(w) {
    return a(w, (F) => F.type !== "import" && F.type !== "export" ? F : Object.assign(Object.assign({}, F), {}, { type: "importExport" }));
  }
  function p(w, F) {
    return a(w, (N) => N.type !== "inlineCode" || F.proseWrap === "preserve" ? N : Object.assign(Object.assign({}, N), {}, { value: N.value.replace(/\s+/g, " ") }));
  }
  function d(w, F) {
    return a(w, (N) => N.type !== "text" || N.value === "*" || N.value === "_" || !u.test(N.value) || N.position.end.offset - N.position.start.offset === N.value.length ? N : Object.assign(Object.assign({}, N), {}, { value: F.originalText.slice(N.position.start.offset, N.position.end.offset) }));
  }
  function y(w) {
    return g(w, (F, N) => F.type === "importExport" && N.type === "importExport", (F, N) => ({ type: "importExport", value: F.value + `

` + N.value, position: { start: F.position.start, end: N.position.end } }));
  }
  function g(w, F, N) {
    return a(w, (x) => {
      if (!x.children) return x;
      let I = x.children.reduce((P, $2) => {
        let D = t(P);
        return D && F(D, $2) ? P.splice(-1, 1, N(D, $2)) : P.push($2), P;
      }, []);
      return Object.assign(Object.assign({}, x), {}, { children: I });
    });
  }
  function c(w) {
    return g(w, (F, N) => F.type === "text" && N.type === "text", (F, N) => ({ type: "text", value: F.value + N.value, position: { start: F.position.start, end: N.position.end } }));
  }
  function f(w, F) {
    return a(w, (N, x, I) => {
      let [P] = I;
      if (N.type !== "text") return N;
      let { value: $2 } = N;
      return P.type === "paragraph" && (x === 0 && ($2 = $2.trimStart()), x === P.children.length - 1 && ($2 = $2.trimEnd())), { type: "sentence", position: N.position, children: n($2, F) };
    });
  }
  function E2(w, F) {
    return a(w, (N, x, I) => {
      if (N.type === "code") {
        let P = /^\n?(?: {4,}|\t)/.test(F.originalText.slice(N.position.start.offset, N.position.end.offset));
        if (N.isIndented = P, P) for (let $2 = 0; $2 < I.length; $2++) {
          let D = I[$2];
          if (D.hasIndentedCodeblock) break;
          D.type === "list" && (D.hasIndentedCodeblock = true);
        }
      }
      return N;
    });
  }
  function _(w, F) {
    return a(w, (I, P, $2) => {
      if (I.type === "list" && I.children.length > 0) {
        for (let D = 0; D < $2.length; D++) {
          let T = $2[D];
          if (T.type === "list" && !T.isAligned) return I.isAligned = false, I;
        }
        I.isAligned = x(I);
      }
      return I;
    });
    function N(I) {
      return I.children.length === 0 ? -1 : I.children[0].position.start.column - 1;
    }
    function x(I) {
      if (!I.ordered) return true;
      let [P, $2] = I.children;
      if (s(P, F.originalText).leadingSpaces.length > 1) return true;
      let T = N(P);
      if (T === -1) return false;
      if (I.children.length === 1) return T % F.tabWidth === 0;
      let m = N($2);
      return T !== m ? false : T % F.tabWidth === 0 ? true : s($2, F.originalText).leadingSpaces.length > 1;
    }
  }
  r.exports = i;
} });
var rg = te({ "src/language-markdown/clean.js"(e, r) {
  "use strict";
  ne();
  var t = So(), { isFrontMatterNode: s } = Ue(), { startWithPragma: a } = bo(), n = /* @__PURE__ */ new Set(["position", "raw"]);
  function u(i, l, p) {
    if ((i.type === "front-matter" || i.type === "code" || i.type === "yaml" || i.type === "import" || i.type === "export" || i.type === "jsx") && delete l.value, i.type === "list" && delete l.isAligned, (i.type === "list" || i.type === "listItem") && (delete l.spread, delete l.loose), i.type === "text" || (i.type === "inlineCode" && (l.value = i.value.replace(/[\t\n ]+/g, " ")), i.type === "wikiLink" && (l.value = i.value.trim().replace(/[\t\n]+/g, " ")), (i.type === "definition" || i.type === "linkReference" || i.type === "imageReference") && (l.label = t(i.label)), (i.type === "definition" || i.type === "link" || i.type === "image") && i.title && (l.title = i.title.replace(/\\(["')])/g, "$1")), p && p.type === "root" && p.children.length > 0 && (p.children[0] === i || s(p.children[0]) && p.children[1] === i) && i.type === "html" && a(i.value))) return null;
  }
  u.ignoredProperties = n, r.exports = u;
} });
var ng = te({ "src/language-markdown/printer-markdown.js"(e, r) {
  "use strict";
  ne();
  var t = So(), { getLast: s, getMinNotPresentContinuousCount: a, getMaxContinuousCount: n, getStringWidth: u, isNonEmptyArray: i } = Ue(), { builders: { breakParent: l, join: p, line: d, literalline: y, markAsRoot: g, hardline: c, softline: f, ifBreak: E2, fill: _, align: w, indent: F, group: N, hardlineWithoutBreakParent: x }, utils: { normalizeDoc: I, replaceTextEndOfLine: P }, printer: { printDocToString: $2 } } = qe(), D = eg(), { insertPragma: T } = bo(), { locStart: m, locEnd: C } = xo(), o = tg(), h = rg(), { getFencedCodeBlockValue: v, hasGitDiffFriendlyOrderedList: S, splitText: b, punctuationPattern: B, INLINE_NODE_TYPES: k, INLINE_NODE_WRAPPER_TYPES: M, isAutolink: R } = nu(), q = /* @__PURE__ */ new Set(["importExport"]), J2 = ["heading", "tableCell", "link", "wikiLink"], L = /* @__PURE__ */ new Set(["listItem", "definition", "footnoteDefinition"]);
  function Q2(oe2, H, pe) {
    let X = oe2.getValue();
    if (ge(oe2)) return b(H.originalText.slice(X.position.start.offset, X.position.end.offset), H).map((le2) => le2.type === "word" ? le2.value : le2.value === "" ? "" : W(oe2, le2.value, H));
    switch (X.type) {
      case "front-matter":
        return H.originalText.slice(X.position.start.offset, X.position.end.offset);
      case "root":
        return X.children.length === 0 ? "" : [I(de(oe2, H, pe)), q.has(z(X).type) ? "" : c];
      case "paragraph":
        return ue(oe2, H, pe, { postprocessor: _ });
      case "sentence":
        return ue(oe2, H, pe);
      case "word": {
        let le2 = X.value.replace(/\*/g, "\\$&").replace(new RegExp([`(^|${B})(_+)`, `(_+)(${B}|$)`].join("|"), "g"), (De, A, G, re, ye2) => (G ? `${A}${G}` : `${re}${ye2}`).replace(/_/g, "\\_")), Ae = (De, A, G) => De.type === "sentence" && G === 0, Ee = (De, A, G) => R(De.children[G - 1]);
        return le2 !== X.value && (oe2.match(void 0, Ae, Ee) || oe2.match(void 0, Ae, (De, A, G) => De.type === "emphasis" && G === 0, Ee)) && (le2 = le2.replace(/^(\\?[*_])+/, (De) => De.replace(/\\/g, ""))), le2;
      }
      case "whitespace": {
        let le2 = oe2.getParentNode(), Ae = le2.children.indexOf(X), Ee = le2.children[Ae + 1], De = Ee && /^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ee.value) ? "never" : H.proseWrap;
        return W(oe2, X.value, { proseWrap: De });
      }
      case "emphasis": {
        let le2;
        if (R(X.children[0])) le2 = H.originalText[X.position.start.offset];
        else {
          let Ae = oe2.getParentNode(), Ee = Ae.children.indexOf(X), De = Ae.children[Ee - 1], A = Ae.children[Ee + 1];
          le2 = De && De.type === "sentence" && De.children.length > 0 && s(De.children).type === "word" && !s(De.children).hasTrailingPunctuation || A && A.type === "sentence" && A.children.length > 0 && A.children[0].type === "word" && !A.children[0].hasLeadingPunctuation || ce(oe2, "emphasis") ? "*" : "_";
        }
        return [le2, ue(oe2, H, pe), le2];
      }
      case "strong":
        return ["**", ue(oe2, H, pe), "**"];
      case "delete":
        return ["~~", ue(oe2, H, pe), "~~"];
      case "inlineCode": {
        let le2 = a(X.value, "`"), Ae = "`".repeat(le2 || 1), Ee = le2 && !/^\s/.test(X.value) ? " " : "";
        return [Ae, Ee, X.value, Ee, Ae];
      }
      case "wikiLink": {
        let le2 = "";
        return H.proseWrap === "preserve" ? le2 = X.value : le2 = X.value.replace(/[\t\n]+/g, " "), ["[[", le2, "]]"];
      }
      case "link":
        switch (H.originalText[X.position.start.offset]) {
          case "<": {
            let le2 = "mailto:";
            return ["<", X.url.startsWith(le2) && H.originalText.slice(X.position.start.offset + 1, X.position.start.offset + 1 + le2.length) !== le2 ? X.url.slice(le2.length) : X.url, ">"];
          }
          case "[":
            return ["[", ue(oe2, H, pe), "](", he(X.url, ")"), we(X.title, H), ")"];
          default:
            return H.originalText.slice(X.position.start.offset, X.position.end.offset);
        }
      case "image":
        return ["![", X.alt || "", "](", he(X.url, ")"), we(X.title, H), ")"];
      case "blockquote":
        return ["> ", w("> ", ue(oe2, H, pe))];
      case "heading":
        return ["#".repeat(X.depth) + " ", ue(oe2, H, pe)];
      case "code": {
        if (X.isIndented) {
          let Ee = " ".repeat(4);
          return w(Ee, [Ee, ...P(X.value, c)]);
        }
        let le2 = H.__inJsTemplate ? "~" : "`", Ae = le2.repeat(Math.max(3, n(X.value, le2) + 1));
        return [Ae, X.lang || "", X.meta ? " " + X.meta : "", c, ...P(v(X, H.originalText), c), c, Ae];
      }
      case "html": {
        let le2 = oe2.getParentNode(), Ae = le2.type === "root" && s(le2.children) === X ? X.value.trimEnd() : X.value, Ee = /^<!--.*-->$/s.test(Ae);
        return P(Ae, Ee ? c : g(y));
      }
      case "list": {
        let le2 = Y(X, oe2.getParentNode()), Ae = S(X, H);
        return ue(oe2, H, pe, { processor: (Ee, De) => {
          let A = re(), G = Ee.getValue();
          if (G.children.length === 2 && G.children[1].type === "html" && G.children[0].position.start.column !== G.children[1].position.start.column) return [A, V(Ee, H, pe, A)];
          return [A, w(" ".repeat(A.length), V(Ee, H, pe, A))];
          function re() {
            let ye2 = X.ordered ? (De === 0 ? X.start : Ae ? 1 : X.start + De) + (le2 % 2 === 0 ? ". " : ") ") : le2 % 2 === 0 ? "- " : "* ";
            return X.isAligned || X.hasIndentedCodeblock ? j(ye2, H) : ye2;
          }
        } });
      }
      case "thematicBreak": {
        let le2 = ee(oe2, "list");
        return le2 === -1 ? "---" : Y(oe2.getParentNode(le2), oe2.getParentNode(le2 + 1)) % 2 === 0 ? "***" : "---";
      }
      case "linkReference":
        return ["[", ue(oe2, H, pe), "]", X.referenceType === "full" ? Ne(X) : X.referenceType === "collapsed" ? "[]" : ""];
      case "imageReference":
        switch (X.referenceType) {
          case "full":
            return ["![", X.alt || "", "]", Ne(X)];
          default:
            return ["![", X.alt, "]", X.referenceType === "collapsed" ? "[]" : ""];
        }
      case "definition": {
        let le2 = H.proseWrap === "always" ? d : " ";
        return N([Ne(X), ":", F([le2, he(X.url), X.title === null ? "" : [le2, we(X.title, H, false)]])]);
      }
      case "footnote":
        return ["[^", ue(oe2, H, pe), "]"];
      case "footnoteReference":
        return Pe2(X);
      case "footnoteDefinition": {
        let le2 = oe2.getParentNode().children[oe2.getName() + 1], Ae = X.children.length === 1 && X.children[0].type === "paragraph" && (H.proseWrap === "never" || H.proseWrap === "preserve" && X.children[0].position.start.line === X.children[0].position.end.line);
        return [Pe2(X), ": ", Ae ? ue(oe2, H, pe) : N([w(" ".repeat(4), ue(oe2, H, pe, { processor: (Ee, De) => De === 0 ? N([f, pe()]) : pe() })), le2 && le2.type === "footnoteDefinition" ? f : ""])];
      }
      case "table":
        return K(oe2, H, pe);
      case "tableCell":
        return ue(oe2, H, pe);
      case "break":
        return /\s/.test(H.originalText[X.position.start.offset]) ? ["  ", g(y)] : ["\\", c];
      case "liquidNode":
        return P(X.value, c);
      case "importExport":
        return [X.value, c];
      case "esComment":
        return ["{/* ", X.value, " */}"];
      case "jsx":
        return X.value;
      case "math":
        return ["$$", c, X.value ? [...P(X.value, c), c] : "", "$$"];
      case "inlineMath":
        return H.originalText.slice(m(X), C(X));
      case "tableRow":
      case "listItem":
      default:
        throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`);
    }
  }
  function V(oe2, H, pe, X) {
    let le2 = oe2.getValue(), Ae = le2.checked === null ? "" : le2.checked ? "[x] " : "[ ] ";
    return [Ae, ue(oe2, H, pe, { processor: (Ee, De) => {
      if (De === 0 && Ee.getValue().type !== "list") return w(" ".repeat(Ae.length), pe());
      let A = " ".repeat(ke(H.tabWidth - X.length, 0, 3));
      return [A, w(A, pe())];
    } })];
  }
  function j(oe2, H) {
    let pe = X();
    return oe2 + " ".repeat(pe >= 4 ? 0 : pe);
    function X() {
      let le2 = oe2.length % H.tabWidth;
      return le2 === 0 ? 0 : H.tabWidth - le2;
    }
  }
  function Y(oe2, H) {
    return ie(oe2, H, (pe) => pe.ordered === oe2.ordered);
  }
  function ie(oe2, H, pe) {
    let X = -1;
    for (let le2 of H.children) if (le2.type === oe2.type && pe(le2) ? X++ : X = -1, le2 === oe2) return X;
  }
  function ee(oe2, H) {
    let pe = Array.isArray(H) ? H : [H], X = -1, le2;
    for (; le2 = oe2.getParentNode(++X); ) if (pe.includes(le2.type)) return X;
    return -1;
  }
  function ce(oe2, H) {
    let pe = ee(oe2, H);
    return pe === -1 ? null : oe2.getParentNode(pe);
  }
  function W(oe2, H, pe) {
    if (pe.proseWrap === "preserve" && H === `
`) return c;
    let X = pe.proseWrap === "always" && !ce(oe2, J2);
    return H !== "" ? X ? d : " " : X ? f : "";
  }
  function K(oe2, H, pe) {
    let X = oe2.getValue(), le2 = [], Ae = oe2.map((ye2) => ye2.map((Ce, Be) => {
      let ve = $2(pe(), H).formatted, ze = u(ve);
      return le2[Be] = Math.max(le2[Be] || 3, ze), { text: ve, width: ze };
    }, "children"), "children"), Ee = A(false);
    if (H.proseWrap !== "never") return [l, Ee];
    let De = A(true);
    return [l, N(E2(De, Ee))];
    function A(ye2) {
      let Ce = [re(Ae[0], ye2), G(ye2)];
      return Ae.length > 1 && Ce.push(p(x, Ae.slice(1).map((Be) => re(Be, ye2)))), p(x, Ce);
    }
    function G(ye2) {
      return `| ${le2.map((Be, ve) => {
        let ze = X.align[ve], xe2 = ze === "center" || ze === "left" ? ":" : "-", Ye = ze === "center" || ze === "right" ? ":" : "-", Se = ye2 ? "-" : "-".repeat(Be - 2);
        return `${xe2}${Se}${Ye}`;
      }).join(" | ")} |`;
    }
    function re(ye2, Ce) {
      return `| ${ye2.map((ve, ze) => {
        let { text: xe2, width: Ye } = ve;
        if (Ce) return xe2;
        let Se = le2[ze] - Ye, Ie = X.align[ze], Oe = 0;
        Ie === "right" ? Oe = Se : Ie === "center" && (Oe = Math.floor(Se / 2));
        let Je = Se - Oe;
        return `${" ".repeat(Oe)}${xe2}${" ".repeat(Je)}`;
      }).join(" | ")} |`;
    }
  }
  function de(oe2, H, pe) {
    let X = [], le2 = null, { children: Ae } = oe2.getValue();
    for (let [Ee, De] of Ae.entries()) switch (U(De)) {
      case "start":
        le2 === null && (le2 = { index: Ee, offset: De.position.end.offset });
        break;
      case "end":
        le2 !== null && (X.push({ start: le2, end: { index: Ee, offset: De.position.start.offset } }), le2 = null);
        break;
      default:
        break;
    }
    return ue(oe2, H, pe, { processor: (Ee, De) => {
      if (X.length > 0) {
        let A = X[0];
        if (De === A.start.index) return [Fe(Ae[A.start.index]), H.originalText.slice(A.start.offset, A.end.offset), Fe(Ae[A.end.index])];
        if (A.start.index < De && De < A.end.index) return false;
        if (De === A.end.index) return X.shift(), false;
      }
      return pe();
    } });
  }
  function ue(oe2, H, pe) {
    let X = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, { postprocessor: le2 } = X, Ae = X.processor || (() => pe()), Ee = oe2.getValue(), De = [], A;
    return oe2.each((G, re) => {
      let ye2 = G.getValue(), Ce = Ae(G, re);
      if (Ce !== false) {
        let Be = { parts: De, prevNode: A, parentNode: Ee, options: H };
        Z(ye2, Be) && (De.push(c), A && q.has(A.type) || (se(ye2, Be) || fe(ye2, Be)) && De.push(c), fe(ye2, Be) && De.push(c)), De.push(Ce), A = ye2;
      }
    }, "children"), le2 ? le2(De) : De;
  }
  function Fe(oe2) {
    if (oe2.type === "html") return oe2.value;
    if (oe2.type === "paragraph" && Array.isArray(oe2.children) && oe2.children.length === 1 && oe2.children[0].type === "esComment") return ["{/* ", oe2.children[0].value, " */}"];
  }
  function z(oe2) {
    let H = oe2;
    for (; i(H.children); ) H = s(H.children);
    return H;
  }
  function U(oe2) {
    let H;
    if (oe2.type === "html") H = oe2.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
    else {
      let pe;
      oe2.type === "esComment" ? pe = oe2 : oe2.type === "paragraph" && oe2.children.length === 1 && oe2.children[0].type === "esComment" && (pe = oe2.children[0]), pe && (H = pe.value.match(/^prettier-ignore(?:-(start|end))?$/));
    }
    return H ? H[1] || "next" : false;
  }
  function Z(oe2, H) {
    let pe = H.parts.length === 0, X = k.includes(oe2.type), le2 = oe2.type === "html" && M.includes(H.parentNode.type);
    return !pe && !X && !le2;
  }
  function se(oe2, H) {
    var pe, X, le2;
    let Ee = (H.prevNode && H.prevNode.type) === oe2.type && L.has(oe2.type), De = H.parentNode.type === "listItem" && !H.parentNode.loose, A = ((pe = H.prevNode) === null || pe === void 0 ? void 0 : pe.type) === "listItem" && H.prevNode.loose, G = U(H.prevNode) === "next", re = oe2.type === "html" && ((X = H.prevNode) === null || X === void 0 ? void 0 : X.type) === "html" && H.prevNode.position.end.line + 1 === oe2.position.start.line, ye2 = oe2.type === "html" && H.parentNode.type === "listItem" && ((le2 = H.prevNode) === null || le2 === void 0 ? void 0 : le2.type) === "paragraph" && H.prevNode.position.end.line + 1 === oe2.position.start.line;
    return A || !(Ee || De || G || re || ye2);
  }
  function fe(oe2, H) {
    let pe = H.prevNode && H.prevNode.type === "list", X = oe2.type === "code" && oe2.isIndented;
    return pe && X;
  }
  function ge(oe2) {
    let H = ce(oe2, ["linkReference", "imageReference"]);
    return H && (H.type !== "linkReference" || H.referenceType !== "full");
  }
  function he(oe2) {
    let H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], pe = [" ", ...Array.isArray(H) ? H : [H]];
    return new RegExp(pe.map((X) => `\\${X}`).join("|")).test(oe2) ? `<${oe2}>` : oe2;
  }
  function we(oe2, H) {
    let pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    if (!oe2) return "";
    if (pe) return " " + we(oe2, H, false);
    if (oe2 = oe2.replace(/\\(["')])/g, "$1"), oe2.includes('"') && oe2.includes("'") && !oe2.includes(")")) return `(${oe2})`;
    let X = oe2.split("'").length - 1, le2 = oe2.split('"').length - 1, Ae = X > le2 ? '"' : le2 > X || H.singleQuote ? "'" : '"';
    return oe2 = oe2.replace(/\\/, "\\\\"), oe2 = oe2.replace(new RegExp(`(${Ae})`, "g"), "\\$1"), `${Ae}${oe2}${Ae}`;
  }
  function ke(oe2, H, pe) {
    return oe2 < H ? H : oe2 > pe ? pe : oe2;
  }
  function Re(oe2) {
    let H = Number(oe2.getName());
    if (H === 0) return false;
    let pe = oe2.getParentNode().children[H - 1];
    return U(pe) === "next";
  }
  function Ne(oe2) {
    return `[${t(oe2.label)}]`;
  }
  function Pe2(oe2) {
    return `[^${oe2.label}]`;
  }
  r.exports = { preprocess: o, print: Q2, embed: D, massageAstNode: h, hasPrettierIgnore: Re, insertPragma: T };
} });
var ug = te({ "src/language-markdown/options.js"(e, r) {
  "use strict";
  ne();
  var t = jt();
  r.exports = { proseWrap: t.proseWrap, singleQuote: t.singleQuote };
} });
var sg = te({ "src/language-markdown/parsers.js"() {
  ne();
} });
var Aa = te({ "node_modules/linguist-languages/data/Markdown.json"(e, r) {
  r.exports = { name: "Markdown", type: "prose", color: "#083fa1", aliases: ["pandoc"], aceMode: "markdown", codemirrorMode: "gfm", codemirrorMimeType: "text/x-gfm", wrap: true, extensions: [".md", ".livemd", ".markdown", ".mdown", ".mdwn", ".mdx", ".mkd", ".mkdn", ".mkdown", ".ronn", ".scd", ".workbook"], filenames: ["contents.lr"], tmScope: "source.gfm", languageId: 222 };
} });
var ig = te({ "src/language-markdown/index.js"(e, r) {
  "use strict";
  ne();
  var t = wt(), s = ng(), a = ug(), n = sg(), u = [t(Aa(), (l) => ({ since: "1.8.0", parsers: ["markdown"], vscodeLanguageIds: ["markdown"], filenames: [...l.filenames, "README"], extensions: l.extensions.filter((p) => p !== ".mdx") })), t(Aa(), () => ({ name: "MDX", since: "1.15.0", parsers: ["mdx"], vscodeLanguageIds: ["mdx"], filenames: [], extensions: [".mdx"] }))], i = { mdast: s };
  r.exports = { languages: u, options: a, printers: i, parsers: n };
} });
var ag = te({ "src/language-html/clean.js"(e, r) {
  "use strict";
  ne();
  var { isFrontMatterNode: t } = Ue(), s = /* @__PURE__ */ new Set(["sourceSpan", "startSourceSpan", "endSourceSpan", "nameSpan", "valueSpan"]);
  function a(n, u) {
    if (n.type === "text" || n.type === "comment" || t(n) || n.type === "yaml" || n.type === "toml") return null;
    n.type === "attribute" && delete u.value, n.type === "docType" && delete u.value;
  }
  a.ignoredProperties = s, r.exports = a;
} });
var og = te({ "src/language-html/constants.evaluate.js"(e, r) {
  r.exports = { CSS_DISPLAY_TAGS: { area: "none", base: "none", basefont: "none", datalist: "none", head: "none", link: "none", meta: "none", noembed: "none", noframes: "none", param: "block", rp: "none", script: "block", source: "block", style: "none", template: "inline", track: "block", title: "none", html: "block", body: "block", address: "block", blockquote: "block", center: "block", div: "block", figure: "block", figcaption: "block", footer: "block", form: "block", header: "block", hr: "block", legend: "block", listing: "block", main: "block", p: "block", plaintext: "block", pre: "block", xmp: "block", slot: "contents", ruby: "ruby", rt: "ruby-text", article: "block", aside: "block", h1: "block", h2: "block", h3: "block", h4: "block", h5: "block", h6: "block", hgroup: "block", nav: "block", section: "block", dir: "block", dd: "block", dl: "block", dt: "block", ol: "block", ul: "block", li: "list-item", table: "table", caption: "table-caption", colgroup: "table-column-group", col: "table-column", thead: "table-header-group", tbody: "table-row-group", tfoot: "table-footer-group", tr: "table-row", td: "table-cell", th: "table-cell", fieldset: "block", button: "inline-block", details: "block", summary: "block", dialog: "block", meter: "inline-block", progress: "inline-block", object: "inline-block", video: "inline-block", audio: "inline-block", select: "inline-block", option: "block", optgroup: "block" }, CSS_DISPLAY_DEFAULT: "inline", CSS_WHITE_SPACE_TAGS: { listing: "pre", plaintext: "pre", pre: "pre", xmp: "pre", nobr: "nowrap", table: "initial", textarea: "pre-wrap" }, CSS_WHITE_SPACE_DEFAULT: "normal" };
} });
var lg = te({ "src/language-html/utils/is-unknown-namespace.js"(e, r) {
  "use strict";
  ne();
  function t(s) {
    return s.type === "element" && !s.hasExplicitNamespace && !["html", "svg"].includes(s.namespace);
  }
  r.exports = t;
} });
var qt = te({ "src/language-html/utils/index.js"(e, r) {
  "use strict";
  ne();
  var { inferParserByLanguage: t, isFrontMatterNode: s } = Ue(), { builders: { line: a, hardline: n, join: u }, utils: { getDocParts: i, replaceTextEndOfLine: l } } = qe(), { CSS_DISPLAY_TAGS: p, CSS_DISPLAY_DEFAULT: d, CSS_WHITE_SPACE_TAGS: y, CSS_WHITE_SPACE_DEFAULT: g } = og(), c = lg(), f = /* @__PURE__ */ new Set(["	", `
`, "\f", "\r", " "]), E2 = (A) => A.replace(/^[\t\n\f\r ]+/, ""), _ = (A) => A.replace(/[\t\n\f\r ]+$/, ""), w = (A) => E2(_(A)), F = (A) => A.replace(/^[\t\f\r ]*\n/g, ""), N = (A) => F(_(A)), x = (A) => A.split(/[\t\n\f\r ]+/), I = (A) => A.match(/^[\t\n\f\r ]*/)[0], P = (A) => {
    let [, G, re, ye2] = A.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);
    return { leadingWhitespace: G, trailingWhitespace: ye2, text: re };
  }, $2 = (A) => /[\t\n\f\r ]/.test(A);
  function D(A, G) {
    return !!(A.type === "ieConditionalComment" && A.lastChild && !A.lastChild.isSelfClosing && !A.lastChild.endSourceSpan || A.type === "ieConditionalComment" && !A.complete || se(A) && A.children.some((re) => re.type !== "text" && re.type !== "interpolation") || X(A, G) && !o(A) && A.type !== "interpolation");
  }
  function T(A) {
    return A.type === "attribute" || !A.parent || !A.prev ? false : m(A.prev);
  }
  function m(A) {
    return A.type === "comment" && A.value.trim() === "prettier-ignore";
  }
  function C(A) {
    return A.type === "text" || A.type === "comment";
  }
  function o(A) {
    return A.type === "element" && (A.fullName === "script" || A.fullName === "style" || A.fullName === "svg:style" || c(A) && (A.name === "script" || A.name === "style"));
  }
  function h(A) {
    return A.children && !o(A);
  }
  function v(A) {
    return o(A) || A.type === "interpolation" || S(A);
  }
  function S(A) {
    return we(A).startsWith("pre");
  }
  function b(A, G) {
    let re = ye2();
    if (re && !A.prev && A.parent && A.parent.tagDefinition && A.parent.tagDefinition.ignoreFirstLf) return A.type === "interpolation";
    return re;
    function ye2() {
      return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.prev && (A.prev.type === "text" || A.prev.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.prev && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !ue(A.parent.cssDisplay)) || A.prev && !U(A.prev.cssDisplay));
    }
  }
  function B(A, G) {
    return s(A) ? false : (A.type === "text" || A.type === "interpolation") && A.next && (A.next.type === "text" || A.next.type === "interpolation") ? true : !A.parent || A.parent.cssDisplay === "none" ? false : se(A.parent) ? true : !(!A.next && (A.parent.type === "root" || se(A) && A.parent || o(A.parent) || H(A.parent, G) || !Fe(A.parent.cssDisplay)) || A.next && !z(A.next.cssDisplay));
  }
  function k(A) {
    return Z(A.cssDisplay) && !o(A);
  }
  function M(A) {
    return s(A) || A.next && A.sourceSpan.end && A.sourceSpan.end.line + 1 < A.next.sourceSpan.start.line;
  }
  function R(A) {
    return q(A) || A.type === "element" && A.children.length > 0 && (["body", "script", "style"].includes(A.name) || A.children.some((G) => ee(G))) || A.firstChild && A.firstChild === A.lastChild && A.firstChild.type !== "text" && V(A.firstChild) && (!A.lastChild.isTrailingSpaceSensitive || j(A.lastChild));
  }
  function q(A) {
    return A.type === "element" && A.children.length > 0 && (["html", "head", "ul", "ol", "select"].includes(A.name) || A.cssDisplay.startsWith("table") && A.cssDisplay !== "table-cell");
  }
  function J2(A) {
    return Y(A) || A.prev && L(A.prev) || Q2(A);
  }
  function L(A) {
    return Y(A) || A.type === "element" && A.fullName === "br" || Q2(A);
  }
  function Q2(A) {
    return V(A) && j(A);
  }
  function V(A) {
    return A.hasLeadingSpaces && (A.prev ? A.prev.sourceSpan.end.line < A.sourceSpan.start.line : A.parent.type === "root" || A.parent.startSourceSpan.end.line < A.sourceSpan.start.line);
  }
  function j(A) {
    return A.hasTrailingSpaces && (A.next ? A.next.sourceSpan.start.line > A.sourceSpan.end.line : A.parent.type === "root" || A.parent.endSourceSpan && A.parent.endSourceSpan.start.line > A.sourceSpan.end.line);
  }
  function Y(A) {
    switch (A.type) {
      case "ieConditionalComment":
      case "comment":
      case "directive":
        return true;
      case "element":
        return ["script", "select"].includes(A.name);
    }
    return false;
  }
  function ie(A) {
    return A.lastChild ? ie(A.lastChild) : A;
  }
  function ee(A) {
    return A.children && A.children.some((G) => G.type !== "text");
  }
  function ce(A) {
    let { type: G, lang: re } = A.attrMap;
    if (G === "module" || G === "text/javascript" || G === "text/babel" || G === "application/javascript" || re === "jsx") return "babel";
    if (G === "application/x-typescript" || re === "ts" || re === "tsx") return "typescript";
    if (G === "text/markdown") return "markdown";
    if (G === "text/html") return "html";
    if (G && (G.endsWith("json") || G.endsWith("importmap")) || G === "speculationrules") return "json";
    if (G === "text/x-handlebars-template") return "glimmer";
  }
  function W(A, G) {
    let { lang: re } = A.attrMap;
    if (!re || re === "postcss" || re === "css") return "css";
    if (re === "scss") return "scss";
    if (re === "less") return "less";
    if (re === "stylus") return t("stylus", G);
  }
  function K(A, G) {
    if (A.name === "script" && !A.attrMap.src) return !A.attrMap.lang && !A.attrMap.type ? "babel" : ce(A);
    if (A.name === "style") return W(A, G);
    if (G && X(A, G)) return ce(A) || !("src" in A.attrMap) && t(A.attrMap.lang, G);
  }
  function de(A) {
    return A === "block" || A === "list-item" || A.startsWith("table");
  }
  function ue(A) {
    return !de(A) && A !== "inline-block";
  }
  function Fe(A) {
    return !de(A) && A !== "inline-block";
  }
  function z(A) {
    return !de(A);
  }
  function U(A) {
    return !de(A);
  }
  function Z(A) {
    return !de(A) && A !== "inline-block";
  }
  function se(A) {
    return we(A).startsWith("pre");
  }
  function fe(A, G) {
    let re = 0;
    for (let ye2 = A.stack.length - 1; ye2 >= 0; ye2--) {
      let Ce = A.stack[ye2];
      Ce && typeof Ce == "object" && !Array.isArray(Ce) && G(Ce) && re++;
    }
    return re;
  }
  function ge(A, G) {
    let re = A;
    for (; re; ) {
      if (G(re)) return true;
      re = re.parent;
    }
    return false;
  }
  function he(A, G) {
    if (A.prev && A.prev.type === "comment") {
      let ye2 = A.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);
      if (ye2) return ye2[1];
    }
    let re = false;
    if (A.type === "element" && A.namespace === "svg") if (ge(A, (ye2) => ye2.fullName === "svg:foreignObject")) re = true;
    else return A.name === "svg" ? "inline-block" : "block";
    switch (G.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";
      case "ignore":
        return "block";
      default:
        return G.parser === "vue" && A.parent && A.parent.type === "root" ? "block" : A.type === "element" && (!A.namespace || re || c(A)) && p[A.name] || d;
    }
  }
  function we(A) {
    return A.type === "element" && (!A.namespace || c(A)) && y[A.name] || g;
  }
  function ke(A) {
    let G = Number.POSITIVE_INFINITY;
    for (let re of A.split(`
`)) {
      if (re.length === 0) continue;
      if (!f.has(re[0])) return 0;
      let ye2 = I(re).length;
      re.length !== ye2 && ye2 < G && (G = ye2);
    }
    return G === Number.POSITIVE_INFINITY ? 0 : G;
  }
  function Re(A) {
    let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ke(A);
    return G === 0 ? A : A.split(`
`).map((re) => re.slice(G)).join(`
`);
  }
  function Ne(A, G) {
    let re = 0;
    for (let ye2 = 0; ye2 < A.length; ye2++) A[ye2] === G && re++;
    return re;
  }
  function Pe2(A) {
    return A.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  }
  var oe2 = /* @__PURE__ */ new Set(["template", "style", "script"]);
  function H(A, G) {
    return pe(A, G) && !oe2.has(A.fullName);
  }
  function pe(A, G) {
    return G.parser === "vue" && A.type === "element" && A.parent.type === "root" && A.fullName.toLowerCase() !== "html";
  }
  function X(A, G) {
    return pe(A, G) && (H(A, G) || A.attrMap.lang && A.attrMap.lang !== "html");
  }
  function le2(A) {
    let G = A.fullName;
    return G.charAt(0) === "#" || G === "slot-scope" || G === "v-slot" || G.startsWith("v-slot:");
  }
  function Ae(A, G) {
    let re = A.parent;
    if (!pe(re, G)) return false;
    let ye2 = re.fullName, Ce = A.fullName;
    return ye2 === "script" && Ce === "setup" || ye2 === "style" && Ce === "vars";
  }
  function Ee(A) {
    let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : A.value;
    return A.parent.isWhitespaceSensitive ? A.parent.isIndentationSensitive ? l(G) : l(Re(N(G)), n) : i(u(a, x(G)));
  }
  function De(A, G) {
    return pe(A, G) && A.name === "script";
  }
  r.exports = { htmlTrim: w, htmlTrimPreserveIndentation: N, hasHtmlWhitespace: $2, getLeadingAndTrailingHtmlWhitespace: P, canHaveInterpolation: h, countChars: Ne, countParents: fe, dedentString: Re, forceBreakChildren: q, forceBreakContent: R, forceNextEmptyLine: M, getLastDescendant: ie, getNodeCssStyleDisplay: he, getNodeCssStyleWhiteSpace: we, hasPrettierIgnore: T, inferScriptParser: K, isVueCustomBlock: H, isVueNonHtmlBlock: X, isVueScriptTag: De, isVueSlotAttribute: le2, isVueSfcBindingsAttribute: Ae, isVueSfcBlock: pe, isDanglingSpaceSensitiveNode: k, isIndentationSensitiveNode: S, isLeadingSpaceSensitiveNode: b, isPreLikeNode: se, isScriptLikeTag: o, isTextLikeNode: C, isTrailingSpaceSensitiveNode: B, isWhitespaceSensitiveNode: v, isUnknownNamespace: c, preferHardlineAsLeadingSpaces: J2, preferHardlineAsTrailingSpaces: L, shouldPreserveContent: D, unescapeQuoteEntities: Pe2, getTextValueParts: Ee };
} });
var cg = te({ "node_modules/angular-html-parser/lib/compiler/src/chars.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true }), e.$EOF = 0, e.$BSPACE = 8, e.$TAB = 9, e.$LF = 10, e.$VTAB = 11, e.$FF = 12, e.$CR = 13, e.$SPACE = 32, e.$BANG = 33, e.$DQ = 34, e.$HASH = 35, e.$$ = 36, e.$PERCENT = 37, e.$AMPERSAND = 38, e.$SQ = 39, e.$LPAREN = 40, e.$RPAREN = 41, e.$STAR = 42, e.$PLUS = 43, e.$COMMA = 44, e.$MINUS = 45, e.$PERIOD = 46, e.$SLASH = 47, e.$COLON = 58, e.$SEMICOLON = 59, e.$LT = 60, e.$EQ = 61, e.$GT = 62, e.$QUESTION = 63, e.$0 = 48, e.$7 = 55, e.$9 = 57, e.$A = 65, e.$E = 69, e.$F = 70, e.$X = 88, e.$Z = 90, e.$LBRACKET = 91, e.$BACKSLASH = 92, e.$RBRACKET = 93, e.$CARET = 94, e.$_ = 95, e.$a = 97, e.$b = 98, e.$e = 101, e.$f = 102, e.$n = 110, e.$r = 114, e.$t = 116, e.$u = 117, e.$v = 118, e.$x = 120, e.$z = 122, e.$LBRACE = 123, e.$BAR = 124, e.$RBRACE = 125, e.$NBSP = 160, e.$PIPE = 124, e.$TILDA = 126, e.$AT = 64, e.$BT = 96;
  function r(i) {
    return i >= e.$TAB && i <= e.$SPACE || i == e.$NBSP;
  }
  e.isWhitespace = r;
  function t(i) {
    return e.$0 <= i && i <= e.$9;
  }
  e.isDigit = t;
  function s(i) {
    return i >= e.$a && i <= e.$z || i >= e.$A && i <= e.$Z;
  }
  e.isAsciiLetter = s;
  function a(i) {
    return i >= e.$a && i <= e.$f || i >= e.$A && i <= e.$F || t(i);
  }
  e.isAsciiHexDigit = a;
  function n(i) {
    return i === e.$LF || i === e.$CR;
  }
  e.isNewLine = n;
  function u(i) {
    return e.$0 <= i && i <= e.$7;
  }
  e.isOctalDigit = u;
} });
var pg = te({ "node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = class {
    constructor(s, a, n) {
      this.filePath = s, this.name = a, this.members = n;
    }
    assertNoMembers() {
      if (this.members.length) throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);
    }
  };
  e.StaticSymbol = r;
  var t = class {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    get(s, a, n) {
      n = n || [];
      let u = n.length ? `.${n.join(".")}` : "", i = `"${s}".${a}${u}`, l = this.cache.get(i);
      return l || (l = new r(s, a, n), this.cache.set(i, l)), l;
    }
  };
  e.StaticSymbolCache = t;
} });
var fg = te({ "node_modules/angular-html-parser/lib/compiler/src/util.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = /-+([a-z0-9])/g;
  function t(o) {
    return o.replace(r, function() {
      for (var h = arguments.length, v = new Array(h), S = 0; S < h; S++) v[S] = arguments[S];
      return v[1].toUpperCase();
    });
  }
  e.dashCaseToCamelCase = t;
  function s(o, h) {
    return n(o, ":", h);
  }
  e.splitAtColon = s;
  function a(o, h) {
    return n(o, ".", h);
  }
  e.splitAtPeriod = a;
  function n(o, h, v) {
    let S = o.indexOf(h);
    return S == -1 ? v : [o.slice(0, S).trim(), o.slice(S + 1).trim()];
  }
  function u(o, h, v) {
    return Array.isArray(o) ? h.visitArray(o, v) : F(o) ? h.visitStringMap(o, v) : o == null || typeof o == "string" || typeof o == "number" || typeof o == "boolean" ? h.visitPrimitive(o, v) : h.visitOther(o, v);
  }
  e.visitValue = u;
  function i(o) {
    return o != null;
  }
  e.isDefined = i;
  function l(o) {
    return o === void 0 ? null : o;
  }
  e.noUndefined = l;
  var p = class {
    visitArray(o, h) {
      return o.map((v) => u(v, this, h));
    }
    visitStringMap(o, h) {
      let v = {};
      return Object.keys(o).forEach((S) => {
        v[S] = u(o[S], this, h);
      }), v;
    }
    visitPrimitive(o, h) {
      return o;
    }
    visitOther(o, h) {
      return o;
    }
  };
  e.ValueTransformer = p, e.SyncAsync = { assertSync: (o) => {
    if (P(o)) throw new Error("Illegal state: value cannot be a promise");
    return o;
  }, then: (o, h) => P(o) ? o.then(h) : h(o), all: (o) => o.some(P) ? Promise.all(o) : o };
  function d(o) {
    throw new Error(`Internal Error: ${o}`);
  }
  e.error = d;
  function y(o, h) {
    let v = Error(o);
    return v[g] = true, h && (v[c] = h), v;
  }
  e.syntaxError = y;
  var g = "ngSyntaxError", c = "ngParseErrors";
  function f(o) {
    return o[g];
  }
  e.isSyntaxError = f;
  function E2(o) {
    return o[c] || [];
  }
  e.getParseErrors = E2;
  function _(o) {
    return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
  }
  e.escapeRegExp = _;
  var w = Object.getPrototypeOf({});
  function F(o) {
    return typeof o == "object" && o !== null && Object.getPrototypeOf(o) === w;
  }
  function N(o) {
    let h = "";
    for (let v = 0; v < o.length; v++) {
      let S = o.charCodeAt(v);
      if (S >= 55296 && S <= 56319 && o.length > v + 1) {
        let b = o.charCodeAt(v + 1);
        b >= 56320 && b <= 57343 && (v++, S = (S - 55296 << 10) + b - 56320 + 65536);
      }
      S <= 127 ? h += String.fromCharCode(S) : S <= 2047 ? h += String.fromCharCode(S >> 6 & 31 | 192, S & 63 | 128) : S <= 65535 ? h += String.fromCharCode(S >> 12 | 224, S >> 6 & 63 | 128, S & 63 | 128) : S <= 2097151 && (h += String.fromCharCode(S >> 18 & 7 | 240, S >> 12 & 63 | 128, S >> 6 & 63 | 128, S & 63 | 128));
    }
    return h;
  }
  e.utf8Encode = N;
  function x(o) {
    if (typeof o == "string") return o;
    if (o instanceof Array) return "[" + o.map(x).join(", ") + "]";
    if (o == null) return "" + o;
    if (o.overriddenName) return `${o.overriddenName}`;
    if (o.name) return `${o.name}`;
    if (!o.toString) return "object";
    let h = o.toString();
    if (h == null) return "" + h;
    let v = h.indexOf(`
`);
    return v === -1 ? h : h.substring(0, v);
  }
  e.stringify = x;
  function I(o) {
    return typeof o == "function" && o.hasOwnProperty("__forward_ref__") ? o() : o;
  }
  e.resolveForwardRef = I;
  function P(o) {
    return !!o && typeof o.then == "function";
  }
  e.isPromise = P;
  var $2 = class {
    constructor(o) {
      this.full = o;
      let h = o.split(".");
      this.major = h[0], this.minor = h[1], this.patch = h.slice(2).join(".");
    }
  };
  e.Version = $2;
  var D = typeof window < "u" && window, T = typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self, m = typeof globalThis < "u" && globalThis, C = m || D || T;
  e.global = C;
} });
var Dg = te({ "node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = pg(), t = fg(), s = /^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;
  function a(v) {
    return v.replace(/\W/g, "_");
  }
  e.sanitizeIdentifier = a;
  var n = 0;
  function u(v) {
    if (!v || !v.reference) return null;
    let S = v.reference;
    if (S instanceof r.StaticSymbol) return S.name;
    if (S.__anonymousType) return S.__anonymousType;
    let b = t.stringify(S);
    return b.indexOf("(") >= 0 ? (b = `anonymous_${n++}`, S.__anonymousType = b) : b = a(b), b;
  }
  e.identifierName = u;
  function i(v) {
    let S = v.reference;
    return S instanceof r.StaticSymbol ? S.filePath : `./${t.stringify(S)}`;
  }
  e.identifierModuleUrl = i;
  function l(v, S) {
    return `View_${u({ reference: v })}_${S}`;
  }
  e.viewClassName = l;
  function p(v) {
    return `RenderType_${u({ reference: v })}`;
  }
  e.rendererTypeName = p;
  function d(v) {
    return `HostView_${u({ reference: v })}`;
  }
  e.hostViewClassName = d;
  function y(v) {
    return `${u({ reference: v })}NgFactory`;
  }
  e.componentFactoryName = y;
  var g;
  (function(v) {
    v[v.Pipe = 0] = "Pipe", v[v.Directive = 1] = "Directive", v[v.NgModule = 2] = "NgModule", v[v.Injectable = 3] = "Injectable";
  })(g = e.CompileSummaryKind || (e.CompileSummaryKind = {}));
  function c(v) {
    return v.value != null ? a(v.value) : u(v.identifier);
  }
  e.tokenName = c;
  function f(v) {
    return v.identifier != null ? v.identifier.reference : v.value;
  }
  e.tokenReference = f;
  var E2 = class {
    constructor() {
      let { moduleUrl: v, styles: S, styleUrls: b } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.moduleUrl = v || null, this.styles = P(S), this.styleUrls = P(b);
    }
  };
  e.CompileStylesheetMetadata = E2;
  var _ = class {
    constructor(v) {
      let { encapsulation: S, template: b, templateUrl: B, htmlAst: k, styles: M, styleUrls: R, externalStylesheets: q, animations: J2, ngContentSelectors: L, interpolation: Q2, isInline: V, preserveWhitespaces: j } = v;
      if (this.encapsulation = S, this.template = b, this.templateUrl = B, this.htmlAst = k, this.styles = P(M), this.styleUrls = P(R), this.externalStylesheets = P(q), this.animations = J2 ? D(J2) : [], this.ngContentSelectors = L || [], Q2 && Q2.length != 2) throw new Error("'interpolation' should have a start and an end symbol.");
      this.interpolation = Q2, this.isInline = V, this.preserveWhitespaces = j;
    }
    toSummary() {
      return { ngContentSelectors: this.ngContentSelectors, encapsulation: this.encapsulation, styles: this.styles, animations: this.animations };
    }
  };
  e.CompileTemplateMetadata = _;
  var w = class {
    static create(v) {
      let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q, outputs: J2, host: L, providers: Q2, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de } = v, ue = {}, Fe = {}, z = {};
      L != null && Object.keys(L).forEach((se) => {
        let fe = L[se], ge = se.match(s);
        ge === null ? z[se] = fe : ge[1] != null ? Fe[ge[1]] = fe : ge[2] != null && (ue[ge[2]] = fe);
      });
      let U = {};
      q != null && q.forEach((se) => {
        let fe = t.splitAtColon(se, [se, se]);
        U[fe[0]] = fe[1];
      });
      let Z = {};
      return J2 != null && J2.forEach((se) => {
        let fe = t.splitAtColon(se, [se, se]);
        Z[fe[0]] = fe[1];
      }), new w({ isHost: S, type: b, isComponent: !!B, selector: k, exportAs: M, changeDetection: R, inputs: U, outputs: Z, hostListeners: ue, hostProperties: Fe, hostAttributes: z, providers: Q2, viewProviders: V, queries: j, guards: Y, viewQueries: ie, entryComponents: ee, template: ce, componentViewType: W, rendererType: K, componentFactory: de });
    }
    constructor(v) {
      let { isHost: S, type: b, isComponent: B, selector: k, exportAs: M, changeDetection: R, inputs: q, outputs: J2, hostListeners: L, hostProperties: Q2, hostAttributes: V, providers: j, viewProviders: Y, queries: ie, guards: ee, viewQueries: ce, entryComponents: W, template: K, componentViewType: de, rendererType: ue, componentFactory: Fe } = v;
      this.isHost = !!S, this.type = b, this.isComponent = B, this.selector = k, this.exportAs = M, this.changeDetection = R, this.inputs = q, this.outputs = J2, this.hostListeners = L, this.hostProperties = Q2, this.hostAttributes = V, this.providers = P(j), this.viewProviders = P(Y), this.queries = P(ie), this.guards = ee, this.viewQueries = P(ce), this.entryComponents = P(W), this.template = K, this.componentViewType = de, this.rendererType = ue, this.componentFactory = Fe;
    }
    toSummary() {
      return { summaryKind: g.Directive, type: this.type, isComponent: this.isComponent, selector: this.selector, exportAs: this.exportAs, inputs: this.inputs, outputs: this.outputs, hostListeners: this.hostListeners, hostProperties: this.hostProperties, hostAttributes: this.hostAttributes, providers: this.providers, viewProviders: this.viewProviders, queries: this.queries, guards: this.guards, viewQueries: this.viewQueries, entryComponents: this.entryComponents, changeDetection: this.changeDetection, template: this.template && this.template.toSummary(), componentViewType: this.componentViewType, rendererType: this.rendererType, componentFactory: this.componentFactory };
    }
  };
  e.CompileDirectiveMetadata = w;
  var F = class {
    constructor(v) {
      let { type: S, name: b, pure: B } = v;
      this.type = S, this.name = b, this.pure = !!B;
    }
    toSummary() {
      return { summaryKind: g.Pipe, type: this.type, name: this.name, pure: this.pure };
    }
  };
  e.CompilePipeMetadata = F;
  var N = class {
  };
  e.CompileShallowModuleMetadata = N;
  var x = class {
    constructor(v) {
      let { type: S, providers: b, declaredDirectives: B, exportedDirectives: k, declaredPipes: M, exportedPipes: R, entryComponents: q, bootstrapComponents: J2, importedModules: L, exportedModules: Q2, schemas: V, transitiveModule: j, id: Y } = v;
      this.type = S || null, this.declaredDirectives = P(B), this.exportedDirectives = P(k), this.declaredPipes = P(M), this.exportedPipes = P(R), this.providers = P(b), this.entryComponents = P(q), this.bootstrapComponents = P(J2), this.importedModules = P(L), this.exportedModules = P(Q2), this.schemas = P(V), this.id = Y || null, this.transitiveModule = j || null;
    }
    toSummary() {
      let v = this.transitiveModule;
      return { summaryKind: g.NgModule, type: this.type, entryComponents: v.entryComponents, providers: v.providers, modules: v.modules, exportedDirectives: v.exportedDirectives, exportedPipes: v.exportedPipes };
    }
  };
  e.CompileNgModuleMetadata = x;
  var I = class {
    constructor() {
      this.directivesSet = /* @__PURE__ */ new Set(), this.directives = [], this.exportedDirectivesSet = /* @__PURE__ */ new Set(), this.exportedDirectives = [], this.pipesSet = /* @__PURE__ */ new Set(), this.pipes = [], this.exportedPipesSet = /* @__PURE__ */ new Set(), this.exportedPipes = [], this.modulesSet = /* @__PURE__ */ new Set(), this.modules = [], this.entryComponentsSet = /* @__PURE__ */ new Set(), this.entryComponents = [], this.providers = [];
    }
    addProvider(v, S) {
      this.providers.push({ provider: v, module: S });
    }
    addDirective(v) {
      this.directivesSet.has(v.reference) || (this.directivesSet.add(v.reference), this.directives.push(v));
    }
    addExportedDirective(v) {
      this.exportedDirectivesSet.has(v.reference) || (this.exportedDirectivesSet.add(v.reference), this.exportedDirectives.push(v));
    }
    addPipe(v) {
      this.pipesSet.has(v.reference) || (this.pipesSet.add(v.reference), this.pipes.push(v));
    }
    addExportedPipe(v) {
      this.exportedPipesSet.has(v.reference) || (this.exportedPipesSet.add(v.reference), this.exportedPipes.push(v));
    }
    addModule(v) {
      this.modulesSet.has(v.reference) || (this.modulesSet.add(v.reference), this.modules.push(v));
    }
    addEntryComponent(v) {
      this.entryComponentsSet.has(v.componentType) || (this.entryComponentsSet.add(v.componentType), this.entryComponents.push(v));
    }
  };
  e.TransitiveCompileNgModuleMetadata = I;
  function P(v) {
    return v || [];
  }
  var $2 = class {
    constructor(v, S) {
      let { useClass: b, useValue: B, useExisting: k, useFactory: M, deps: R, multi: q } = S;
      this.token = v, this.useClass = b || null, this.useValue = B, this.useExisting = k, this.useFactory = M || null, this.dependencies = R || null, this.multi = !!q;
    }
  };
  e.ProviderMeta = $2;
  function D(v) {
    return v.reduce((S, b) => {
      let B = Array.isArray(b) ? D(b) : b;
      return S.concat(B);
    }, []);
  }
  e.flatten = D;
  function T(v) {
    return v.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/, "ng:///");
  }
  function m(v, S, b) {
    let B;
    return b.isInline ? S.type.reference instanceof r.StaticSymbol ? B = `${S.type.reference.filePath}.${S.type.reference.name}.html` : B = `${u(v)}/${u(S.type)}.html` : B = b.templateUrl, S.type.reference instanceof r.StaticSymbol ? B : T(B);
  }
  e.templateSourceUrl = m;
  function C(v, S) {
    let b = v.moduleUrl.split(/\/\\/g), B = b[b.length - 1];
    return T(`css/${S}${B}.ngstyle.js`);
  }
  e.sharedStylesheetJitUrl = C;
  function o(v) {
    return T(`${u(v.type)}/module.ngfactory.js`);
  }
  e.ngModuleJitUrl = o;
  function h(v, S) {
    return T(`${u(v)}/${u(S.type)}.ngfactory.js`);
  }
  e.templateJitUrl = h;
} });
var mg = te({ "node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e) {
  "use strict";
  ne(), Object.defineProperty(e, "__esModule", { value: true });
  var r = cg(), t = Dg(), s = class {
    constructor(d, y, g, c) {
      this.file = d, this.offset = y, this.line = g, this.col = c;
    }
    toString() {
      return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;
    }
    moveBy(d) {
      let y = this.file.content, g = y.length, c = this.offset, f = this.line, E2 = this.col;
      for (; c > 0 && d < 0; ) if (c--, d++, y.charCodeAt(c) == r.$LF) {
        f--;
        let w = y.substr(0, c - 1).lastIndexOf(String.fromCharCode(r.$LF));
        E2 = w > 0 ? c - w : c;
      } else E2--;
      for (; c < g && d > 0; ) {
        let _ = y.charCodeAt(c);
        c++, d--, _ == r.$LF ? (f++, E2 = 0) : E2++;
      }
      return new s(this.file, c, f, E2);
    }
    getContext(d, y) {
      let g = this.file.content, c = this.offset;
      if (c != null) {
        c > g.length - 1 && (c = g.length - 1);
        let f = c, E2 = 0, _ = 0;
        for (; E2 < d && c > 0 && (c--, E2++, !(g[c] == `
` && ++_ == y)); ) ;
        for (E2 = 0, _ = 0; E2 < d && f < g.length - 1 && (f++, E2++, !(g[f] == `
` && ++_ == y)); ) ;
        return { before: g.substring(c, this.offset), after: g.substring(this.offset, f + 1) };
      }
      return null;
    }
  };
  e.ParseLocation = s;
  var a = class {
    constructor(d, y) {
      this.content = d, this.url = y;
    }
  };
  e.ParseSourceFile = a;
  var n = class {
    constructor(d, y) {
      let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      this.start = d, this.end = y, this.details = g;
    }
    toString() {
      return this.start.file.content.substring(this.start.offset, this.end.offset);
    }
  };
  e.ParseSourceSpan = n, e.EMPTY_PARSE_LOCATION = new s(new a("", ""), 0, 0, 0), e.EMPTY_SOURCE_SPAN = new n(e.EMPTY_PARSE_LOCATION, e.EMPTY_PARSE_LOCATION);
  var u;
  (function(d) {
    d[d.WARNING = 0] = "WARNING", d[d.ERROR = 1] = "ERROR";
  })(u = e.ParseErrorLevel || (e.ParseErrorLevel = {}));
  var i = class {
    constructor(d, y) {
      let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : u.ERROR;
      this.span = d, this.msg = y, this.level = g;
    }
    contextualMessage() {
      let d = this.span.start.getContext(100, 3);
      return d ? `${this.msg} ("${d.before}[${u[this.level]} ->]${d.after}")` : this.msg;
    }
    toString() {
      let d = this.span.details ? `, ${this.span.details}` : "";
      return `${this.contextualMessage()}: ${this.span.start}${d}`;
    }
  };
  e.ParseError = i;
  function l(d, y) {
    let g = t.identifierModuleUrl(y), c = g != null ? `in ${d} ${t.identifierName(y)} in ${g}` : `in ${d} ${t.identifierName(y)}`, f = new a("", c);
    return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
  }
  e.typeSourceSpan = l;
  function p(d, y, g) {
    let c = `in ${d} ${y} in ${g}`, f = new a("", c);
    return new n(new s(f, -1, -1, -1), new s(f, -1, -1, -1));
  }
  e.r3JitTypeSourceSpan = p;
} });
var dg = te({ "src/language-html/print-preprocess.js"(e, r) {
  "use strict";
  ne();
  var { ParseSourceSpan: t } = mg(), { htmlTrim: s, getLeadingAndTrailingHtmlWhitespace: a, hasHtmlWhitespace: n, canHaveInterpolation: u, getNodeCssStyleDisplay: i, isDanglingSpaceSensitiveNode: l, isIndentationSensitiveNode: p, isLeadingSpaceSensitiveNode: d, isTrailingSpaceSensitiveNode: y, isWhitespaceSensitiveNode: g, isVueScriptTag: c } = qt(), f = [_, w, N, I, P, T, $2, D, m, x, C];
  function E2(o, h) {
    for (let v of f) v(o, h);
    return o;
  }
  function _(o) {
    o.walk((h) => {
      if (h.type === "element" && h.tagDefinition.ignoreFirstLf && h.children.length > 0 && h.children[0].type === "text" && h.children[0].value[0] === `
`) {
        let v = h.children[0];
        v.value.length === 1 ? h.removeChild(v) : v.value = v.value.slice(1);
      }
    });
  }
  function w(o) {
    let h = (v) => v.type === "element" && v.prev && v.prev.type === "ieConditionalStartComment" && v.prev.sourceSpan.end.offset === v.startSourceSpan.start.offset && v.firstChild && v.firstChild.type === "ieConditionalEndComment" && v.firstChild.sourceSpan.start.offset === v.startSourceSpan.end.offset;
    o.walk((v) => {
      if (v.children) for (let S = 0; S < v.children.length; S++) {
        let b = v.children[S];
        if (!h(b)) continue;
        let B = b.prev, k = b.firstChild;
        v.removeChild(B), S--;
        let M = new t(B.sourceSpan.start, k.sourceSpan.end), R = new t(M.start, b.sourceSpan.end);
        b.condition = B.condition, b.sourceSpan = R, b.startSourceSpan = M, b.removeChild(k);
      }
    });
  }
  function F(o, h, v) {
    o.walk((S) => {
      if (S.children) for (let b = 0; b < S.children.length; b++) {
        let B = S.children[b];
        if (B.type !== "text" && !h(B)) continue;
        B.type !== "text" && (B.type = "text", B.value = v(B));
        let k = B.prev;
        !k || k.type !== "text" || (k.value += B.value, k.sourceSpan = new t(k.sourceSpan.start, B.sourceSpan.end), S.removeChild(B), b--);
      }
    });
  }
  function N(o) {
    return F(o, (h) => h.type === "cdata", (h) => `<![CDATA[${h.value}]]>`);
  }
  function x(o) {
    let h = (v) => v.type === "element" && v.attrs.length === 0 && v.children.length === 1 && v.firstChild.type === "text" && !n(v.children[0].value) && !v.firstChild.hasLeadingSpaces && !v.firstChild.hasTrailingSpaces && v.isLeadingSpaceSensitive && !v.hasLeadingSpaces && v.isTrailingSpaceSensitive && !v.hasTrailingSpaces && v.prev && v.prev.type === "text" && v.next && v.next.type === "text";
    o.walk((v) => {
      if (v.children) for (let S = 0; S < v.children.length; S++) {
        let b = v.children[S];
        if (!h(b)) continue;
        let B = b.prev, k = b.next;
        B.value += `<${b.rawName}>` + b.firstChild.value + `</${b.rawName}>` + k.value, B.sourceSpan = new t(B.sourceSpan.start, k.sourceSpan.end), B.isTrailingSpaceSensitive = k.isTrailingSpaceSensitive, B.hasTrailingSpaces = k.hasTrailingSpaces, v.removeChild(b), S--, v.removeChild(k);
      }
    });
  }
  function I(o, h) {
    if (h.parser === "html") return;
    let v = /{{(.+?)}}/s;
    o.walk((S) => {
      if (u(S)) for (let b of S.children) {
        if (b.type !== "text") continue;
        let B = b.sourceSpan.start, k = null, M = b.value.split(v);
        for (let R = 0; R < M.length; R++, B = k) {
          let q = M[R];
          if (R % 2 === 0) {
            k = B.moveBy(q.length), q.length > 0 && S.insertChildBefore(b, { type: "text", value: q, sourceSpan: new t(B, k) });
            continue;
          }
          k = B.moveBy(q.length + 4), S.insertChildBefore(b, { type: "interpolation", sourceSpan: new t(B, k), children: q.length === 0 ? [] : [{ type: "text", value: q, sourceSpan: new t(B.moveBy(2), k.moveBy(-2)) }] });
        }
        S.removeChild(b);
      }
    });
  }
  function P(o) {
    o.walk((h) => {
      if (!h.children) return;
      if (h.children.length === 0 || h.children.length === 1 && h.children[0].type === "text" && s(h.children[0].value).length === 0) {
        h.hasDanglingSpaces = h.children.length > 0, h.children = [];
        return;
      }
      let v = g(h), S = p(h);
      if (!v) for (let b = 0; b < h.children.length; b++) {
        let B = h.children[b];
        if (B.type !== "text") continue;
        let { leadingWhitespace: k, text: M, trailingWhitespace: R } = a(B.value), q = B.prev, J2 = B.next;
        M ? (B.value = M, B.sourceSpan = new t(B.sourceSpan.start.moveBy(k.length), B.sourceSpan.end.moveBy(-R.length)), k && (q && (q.hasTrailingSpaces = true), B.hasLeadingSpaces = true), R && (B.hasTrailingSpaces = true, J2 && (J2.hasLeadingSpaces = true))) : (h.removeChild(B), b--, (k || R) && (q && (q.hasTrailingSpaces = true), J2 && (J2.hasLeadingSpaces = true)));
      }
      h.isWhitespaceSensitive = v, h.isIndentationSensitive = S;
    });
  }
  function $2(o) {
    o.walk((h) => {
      h.isSelfClosing = !h.children || h.type === "element" && (h.tagDefinition.isVoid || h.startSourceSpan === h.endSourceSpan);
    });
  }
  function D(o, h) {
    o.walk((v) => {
      v.type === "element" && (v.hasHtmComponentClosingTag = v.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(h.originalText.slice(v.endSourceSpan.start.offset, v.endSourceSpan.end.offset)));
    });
  }
  function T(o, h) {
    o.walk((v) => {
      v.cssDisplay = i(v, h);
    });
  }
  function m(o, h) {
    o.walk((v) => {
      let { children: S } = v;
      if (S) {
        if (S.length === 0) {
          v.isDanglingSpaceSensitive = l(v);
          return;
        }
        for (let b of S) b.isLeadingSpaceSensitive = d(b, h), b.isTrailingSpaceSensitive = y(b, h);
        for (let b = 0; b < S.length; b++) {
          let B = S[b];
          B.isLeadingSpaceSensitive = (b === 0 || B.prev.isTrailingSpaceSensitive) && B.isLeadingSpaceSensitive, B.isTrailingSpaceSensitive = (b === S.length - 1 || B.next.isLeadingSpaceSensitive) && B.isTrailingSpaceSensitive;
        }
      }
    });
  }
  function C(o, h) {
    if (h.parser === "vue") {
      let v = o.children.find((b) => c(b, h));
      if (!v) return;
      let { lang: S } = v.attrMap;
      (S === "ts" || S === "typescript") && (h.__should_parse_vue_template_with_ts = true);
    }
  }
  r.exports = E2;
} });
var gg = te({ "src/language-html/pragma.js"(e, r) {
  "use strict";
  ne();
  function t(a) {
    return /^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a);
  }
  function s(a) {
    return `<!-- @format -->

` + a.replace(/^\s*\n/, "");
  }
  r.exports = { hasPragma: t, insertPragma: s };
} });
var uu = te({ "src/language-html/loc.js"(e, r) {
  "use strict";
  ne();
  function t(a) {
    return a.sourceSpan.start.offset;
  }
  function s(a) {
    return a.sourceSpan.end.offset;
  }
  r.exports = { locStart: t, locEnd: s };
} });
var rr = te({ "src/language-html/print/tag.js"(e, r) {
  "use strict";
  ne();
  var t = Yt(), { isNonEmptyArray: s } = Ue(), { builders: { indent: a, join: n, line: u, softline: i, hardline: l }, utils: { replaceTextEndOfLine: p } } = qe(), { locStart: d, locEnd: y } = uu(), { isTextLikeNode: g, getLastDescendant: c, isPreLikeNode: f, hasPrettierIgnore: E2, shouldPreserveContent: _, isVueSfcBlock: w } = qt();
  function F(L, Q2) {
    return [L.isSelfClosing ? "" : N(L, Q2), x(L, Q2)];
  }
  function N(L, Q2) {
    return L.lastChild && o(L.lastChild) ? "" : [I(L, Q2), $2(L, Q2)];
  }
  function x(L, Q2) {
    return (L.next ? m(L.next) : C(L.parent)) ? "" : [D(L, Q2), P(L, Q2)];
  }
  function I(L, Q2) {
    return C(L) ? D(L.lastChild, Q2) : "";
  }
  function P(L, Q2) {
    return o(L) ? $2(L.parent, Q2) : h(L) ? q(L.next) : "";
  }
  function $2(L, Q2) {
    if (t(!L.isSelfClosing), T(L, Q2)) return "";
    switch (L.type) {
      case "ieConditionalComment":
        return "<!";
      case "element":
        if (L.hasHtmComponentClosingTag) return "<//";
      default:
        return `</${L.rawName}`;
    }
  }
  function D(L, Q2) {
    if (T(L, Q2)) return "";
    switch (L.type) {
      case "ieConditionalComment":
      case "ieConditionalEndComment":
        return "[endif]-->";
      case "ieConditionalStartComment":
        return "]><!-->";
      case "interpolation":
        return "}}";
      case "element":
        if (L.isSelfClosing) return "/>";
      default:
        return ">";
    }
  }
  function T(L, Q2) {
    return !L.isSelfClosing && !L.endSourceSpan && (E2(L) || _(L.parent, Q2));
  }
  function m(L) {
    return L.prev && L.prev.type !== "docType" && !g(L.prev) && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
  }
  function C(L) {
    return L.lastChild && L.lastChild.isTrailingSpaceSensitive && !L.lastChild.hasTrailingSpaces && !g(c(L.lastChild)) && !f(L);
  }
  function o(L) {
    return !L.next && !L.hasTrailingSpaces && L.isTrailingSpaceSensitive && g(c(L));
  }
  function h(L) {
    return L.next && !g(L.next) && g(L) && L.isTrailingSpaceSensitive && !L.hasTrailingSpaces;
  }
  function v(L) {
    let Q2 = L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);
    return Q2 ? Q2[1] ? Q2[1].split(/\s+/) : true : false;
  }
  function S(L) {
    return !L.prev && L.isLeadingSpaceSensitive && !L.hasLeadingSpaces;
  }
  function b(L, Q2, V) {
    let j = L.getValue();
    if (!s(j.attrs)) return j.isSelfClosing ? " " : "";
    let Y = j.prev && j.prev.type === "comment" && v(j.prev.value), ie = typeof Y == "boolean" ? () => Y : Array.isArray(Y) ? (ue) => Y.includes(ue.rawName) : () => false, ee = L.map((ue) => {
      let Fe = ue.getValue();
      return ie(Fe) ? p(Q2.originalText.slice(d(Fe), y(Fe))) : V();
    }, "attrs"), ce = j.type === "element" && j.fullName === "script" && j.attrs.length === 1 && j.attrs[0].fullName === "src" && j.children.length === 0, K = Q2.singleAttributePerLine && j.attrs.length > 1 && !w(j, Q2) ? l : u, de = [a([ce ? " " : u, n(K, ee)])];
    return j.firstChild && S(j.firstChild) || j.isSelfClosing && C(j.parent) || ce ? de.push(j.isSelfClosing ? " " : "") : de.push(Q2.bracketSameLine ? j.isSelfClosing ? " " : "" : j.isSelfClosing ? u : i), de;
  }
  function B(L) {
    return L.firstChild && S(L.firstChild) ? "" : J2(L);
  }
  function k(L, Q2, V) {
    let j = L.getValue();
    return [M(j, Q2), b(L, Q2, V), j.isSelfClosing ? "" : B(j)];
  }
  function M(L, Q2) {
    return L.prev && h(L.prev) ? "" : [R(L, Q2), q(L)];
  }
  function R(L, Q2) {
    return S(L) ? J2(L.parent) : m(L) ? D(L.prev, Q2) : "";
  }
  function q(L) {
    switch (L.type) {
      case "ieConditionalComment":
      case "ieConditionalStartComment":
        return `<!--[if ${L.condition}`;
      case "ieConditionalEndComment":
        return "<!--<!";
      case "interpolation":
        return "{{";
      case "docType":
        return "<!DOCTYPE";
      case "element":
        if (L.condition) return `<!--[if ${L.condition}]><!--><${L.rawName}`;
      default:
        return `<${L.rawName}`;
    }
  }
  function J2(L) {
    switch (t(!L.isSelfClosing), L.type) {
      case "ieConditionalComment":
        return "]>";
      case "element":
        if (L.condition) return "><!--<![endif]-->";
      default:
        return ">";
    }
  }
  r.exports = { printClosingTag: F, printClosingTagStart: N, printClosingTagStartMarker: $2, printClosingTagEndMarker: D, printClosingTagSuffix: P, printClosingTagEnd: x, needsToBorrowLastChildClosingTagEndMarker: C, needsToBorrowParentClosingTagStartMarker: o, needsToBorrowPrevClosingTagEndMarker: m, printOpeningTag: k, printOpeningTagStart: M, printOpeningTagPrefix: R, printOpeningTagStartMarker: q, printOpeningTagEndMarker: J2, needsToBorrowNextOpeningTagStartMarker: h, needsToBorrowParentOpeningTagEndMarker: S };
} });
var yg = te({ "node_modules/parse-srcset/src/parse-srcset.js"(e, r) {
  ne(), function(t, s) {
    typeof define == "function" && define.amd ? define([], s) : typeof r == "object" && r.exports ? r.exports = s() : t.parseSrcset = s();
  }(e, function() {
    return function(t, s) {
      var a = s && s.logger || console;
      function n($2) {
        return $2 === " " || $2 === "	" || $2 === `
` || $2 === "\f" || $2 === "\r";
      }
      function u($2) {
        var D, T = $2.exec(t.substring(N));
        if (T) return D = T[0], N += D.length, D;
      }
      for (var i = t.length, l = /^[ \t\n\r\u000c]+/, p = /^[, \t\n\r\u000c]+/, d = /^[^ \t\n\r\u000c]+/, y = /[,]+$/, g = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, f, E2, _, w, F, N = 0, x = []; ; ) {
        if (u(p), N >= i) return x;
        f = u(d), E2 = [], f.slice(-1) === "," ? (f = f.replace(y, ""), P()) : I();
      }
      function I() {
        for (u(l), _ = "", w = "in descriptor"; ; ) {
          if (F = t.charAt(N), w === "in descriptor") if (n(F)) _ && (E2.push(_), _ = "", w = "after descriptor");
          else if (F === ",") {
            N += 1, _ && E2.push(_), P();
            return;
          } else if (F === "(") _ = _ + F, w = "in parens";
          else if (F === "") {
            _ && E2.push(_), P();
            return;
          } else _ = _ + F;
          else if (w === "in parens") if (F === ")") _ = _ + F, w = "in descriptor";
          else if (F === "") {
            E2.push(_), P();
            return;
          } else _ = _ + F;
          else if (w === "after descriptor" && !n(F)) if (F === "") {
            P();
            return;
          } else w = "in descriptor", N -= 1;
          N += 1;
        }
      }
      function P() {
        var $2 = false, D, T, m, C, o = {}, h, v, S, b, B;
        for (C = 0; C < E2.length; C++) h = E2[C], v = h[h.length - 1], S = h.substring(0, h.length - 1), b = parseInt(S, 10), B = parseFloat(S), g.test(S) && v === "w" ? ((D || T) && ($2 = true), b === 0 ? $2 = true : D = b) : c.test(S) && v === "x" ? ((D || T || m) && ($2 = true), B < 0 ? $2 = true : T = B) : g.test(S) && v === "h" ? ((m || T) && ($2 = true), b === 0 ? $2 = true : m = b) : $2 = true;
        $2 ? a && a.error && a.error("Invalid srcset descriptor found in '" + t + "' at '" + h + "'.") : (o.url = f, D && (o.w = D), T && (o.d = T), m && (o.h = m), x.push(o));
      }
    };
  });
} });
var hg = te({ "src/language-html/syntax-attribute.js"(e, r) {
  "use strict";
  ne();
  var t = yg(), { builders: { ifBreak: s, join: a, line: n } } = qe();
  function u(l) {
    let p = t(l, { logger: { error(I) {
      throw new Error(I);
    } } }), d = p.some((I) => {
      let { w: P } = I;
      return P;
    }), y = p.some((I) => {
      let { h: P } = I;
      return P;
    }), g = p.some((I) => {
      let { d: P } = I;
      return P;
    });
    if (d + y + g > 1) throw new Error("Mixed descriptor in srcset is not supported");
    let c = d ? "w" : y ? "h" : "d", f = d ? "w" : y ? "h" : "x", E2 = (I) => Math.max(...I), _ = p.map((I) => I.url), w = E2(_.map((I) => I.length)), F = p.map((I) => I[c]).map((I) => I ? I.toString() : ""), N = F.map((I) => {
      let P = I.indexOf(".");
      return P === -1 ? I.length : P;
    }), x = E2(N);
    return a([",", n], _.map((I, P) => {
      let $2 = [I], D = F[P];
      if (D) {
        let T = w - I.length + 1, m = x - N[P], C = " ".repeat(T + m);
        $2.push(s(C, " "), D + f);
      }
      return $2;
    }));
  }
  function i(l) {
    return l.trim().split(/\s+/).join(" ");
  }
  r.exports = { printImgSrcset: u, printClassNames: i };
} });
var vg = te({ "src/language-html/syntax-vue.js"(e, r) {
  "use strict";
  ne();
  var { builders: { group: t } } = qe();
  function s(i, l) {
    let { left: p, operator: d, right: y } = a(i);
    return [t(l(`function _(${p}) {}`, { parser: "babel", __isVueForBindingLeft: true })), " ", d, " ", l(y, { parser: "__js_expression" }, { stripTrailingHardline: true })];
  }
  function a(i) {
    let l = /(.*?)\s+(in|of)\s+(.*)/s, p = /,([^,\]}]*)(?:,([^,\]}]*))?$/, d = /^\(|\)$/g, y = i.match(l);
    if (!y) return;
    let g = {};
    if (g.for = y[3].trim(), !g.for) return;
    let c = y[1].trim().replace(d, ""), f = c.match(p);
    f ? (g.alias = c.replace(p, ""), g.iterator1 = f[1].trim(), f[2] && (g.iterator2 = f[2].trim())) : g.alias = c;
    let E2 = [g.alias, g.iterator1, g.iterator2];
    if (!E2.some((_, w) => !_ && (w === 0 || E2.slice(w + 1).some(Boolean)))) return { left: E2.filter(Boolean).join(","), operator: y[2], right: g.for };
  }
  function n(i, l) {
    return l(`function _(${i}) {}`, { parser: "babel", __isVueBindings: true });
  }
  function u(i) {
    let l = /^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/, p = /^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/, d = i.trim();
    return l.test(d) || p.test(d);
  }
  r.exports = { isVueEventBindingExpression: u, printVueFor: s, printVueBindings: n };
} });
var To = te({ "src/language-html/get-node-content.js"(e, r) {
  "use strict";
  ne();
  var { needsToBorrowParentClosingTagStartMarker: t, printClosingTagStartMarker: s, needsToBorrowLastChildClosingTagEndMarker: a, printClosingTagEndMarker: n, needsToBorrowParentOpeningTagEndMarker: u, printOpeningTagEndMarker: i } = rr();
  function l(p, d) {
    let y = p.startSourceSpan.end.offset;
    p.firstChild && u(p.firstChild) && (y -= i(p).length);
    let g = p.endSourceSpan.start.offset;
    return p.lastChild && t(p.lastChild) ? g += s(p, d).length : a(p) && (g -= n(p.lastChild, d).length), d.originalText.slice(y, g);
  }
  r.exports = l;
} });
var Cg = te({ "src/language-html/embed.js"(e, r) {
  "use strict";
  ne();
  var { builders: { breakParent: t, group: s, hardline: a, indent: n, line: u, fill: i, softline: l }, utils: { mapDoc: p, replaceTextEndOfLine: d } } = qe(), y = ru(), { printClosingTag: g, printClosingTagSuffix: c, needsToBorrowPrevClosingTagEndMarker: f, printOpeningTagPrefix: E2, printOpeningTag: _ } = rr(), { printImgSrcset: w, printClassNames: F } = hg(), { printVueFor: N, printVueBindings: x, isVueEventBindingExpression: I } = vg(), { isScriptLikeTag: P, isVueNonHtmlBlock: $2, inferScriptParser: D, htmlTrimPreserveIndentation: T, dedentString: m, unescapeQuoteEntities: C, isVueSlotAttribute: o, isVueSfcBindingsAttribute: h, getTextValueParts: v } = qt(), S = To();
  function b(k, M, R) {
    let q = (ee) => new RegExp(ee.join("|")).test(k.fullName), J2 = () => C(k.value), L = false, Q2 = (ee, ce) => {
      let W = ee.type === "NGRoot" ? ee.node.type === "NGMicrosyntax" && ee.node.body.length === 1 && ee.node.body[0].type === "NGMicrosyntaxExpression" ? ee.node.body[0].expression : ee.node : ee.type === "JsExpressionRoot" ? ee.node : ee;
      W && (W.type === "ObjectExpression" || W.type === "ArrayExpression" || ce.parser === "__vue_expression" && (W.type === "TemplateLiteral" || W.type === "StringLiteral")) && (L = true);
    }, V = (ee) => s(ee), j = function(ee) {
      let ce = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return s([n([l, ee]), ce ? l : ""]);
    }, Y = (ee) => L ? V(ee) : j(ee), ie = (ee, ce) => M(ee, Object.assign({ __onHtmlBindingRoot: Q2, __embeddedInHtml: true }, ce));
    if (k.fullName === "srcset" && (k.parent.fullName === "img" || k.parent.fullName === "source")) return j(w(J2()));
    if (k.fullName === "class" && !R.parentParser) {
      let ee = J2();
      if (!ee.includes("{{")) return F(ee);
    }
    if (k.fullName === "style" && !R.parentParser) {
      let ee = J2();
      if (!ee.includes("{{")) return j(ie(ee, { parser: "css", __isHTMLStyleAttribute: true }));
    }
    if (R.parser === "vue") {
      if (k.fullName === "v-for") return N(J2(), ie);
      if (o(k) || h(k, R)) return x(J2(), ie);
      let ee = ["^@", "^v-on:"], ce = ["^:", "^v-bind:"], W = ["^v-"];
      if (q(ee)) {
        let K = J2(), de = I(K) ? "__js_expression" : R.__should_parse_vue_template_with_ts ? "__vue_ts_event_binding" : "__vue_event_binding";
        return Y(ie(K, { parser: de }));
      }
      if (q(ce)) return Y(ie(J2(), { parser: "__vue_expression" }));
      if (q(W)) return Y(ie(J2(), { parser: "__js_expression" }));
    }
    if (R.parser === "angular") {
      let ee = (z, U) => ie(z, Object.assign(Object.assign({}, U), {}, { trailingComma: "none" })), ce = ["^\\*"], W = ["^\\(.+\\)$", "^on-"], K = ["^\\[.+\\]$", "^bind(on)?-", "^ng-(if|show|hide|class|style)$"], de = ["^i18n(-.+)?$"];
      if (q(W)) return Y(ee(J2(), { parser: "__ng_action" }));
      if (q(K)) return Y(ee(J2(), { parser: "__ng_binding" }));
      if (q(de)) {
        let z = J2().trim();
        return j(i(v(k, z)), !z.includes("@@"));
      }
      if (q(ce)) return Y(ee(J2(), { parser: "__ng_directive" }));
      let ue = /{{(.+?)}}/s, Fe = J2();
      if (ue.test(Fe)) {
        let z = [];
        for (let [U, Z] of Fe.split(ue).entries()) if (U % 2 === 0) z.push(d(Z));
        else try {
          z.push(s(["{{", n([u, ee(Z, { parser: "__ng_interpolation", __isInHtmlInterpolation: true })]), u, "}}"]));
        } catch {
          z.push("{{", d(Z), "}}");
        }
        return s(z);
      }
    }
    return null;
  }
  function B(k, M, R, q) {
    let J2 = k.getValue();
    switch (J2.type) {
      case "element": {
        if (P(J2) || J2.type === "interpolation") return;
        if (!J2.isSelfClosing && $2(J2, q)) {
          let L = D(J2, q);
          if (!L) return;
          let Q2 = S(J2, q), V = /^\s*$/.test(Q2), j = "";
          return V || (j = R(T(Q2), { parser: L, __embeddedInHtml: true }, { stripTrailingHardline: true }), V = j === ""), [E2(J2, q), s(_(k, q, M)), V ? "" : a, j, V ? "" : a, g(J2, q), c(J2, q)];
        }
        break;
      }
      case "text": {
        if (P(J2.parent)) {
          let L = D(J2.parent, q);
          if (L) {
            let Q2 = L === "markdown" ? m(J2.value.replace(/^[^\S\n]*\n/, "")) : J2.value, V = { parser: L, __embeddedInHtml: true };
            if (q.parser === "html" && L === "babel") {
              let j = "script", { attrMap: Y } = J2.parent;
              Y && (Y.type === "module" || Y.type === "text/babel" && Y["data-type"] === "module") && (j = "module"), V.__babelSourceType = j;
            }
            return [t, E2(J2, q), R(Q2, V, { stripTrailingHardline: true }), c(J2, q)];
          }
        } else if (J2.parent.type === "interpolation") {
          let L = { __isInHtmlInterpolation: true, __embeddedInHtml: true };
          return q.parser === "angular" ? (L.parser = "__ng_interpolation", L.trailingComma = "none") : q.parser === "vue" ? L.parser = q.__should_parse_vue_template_with_ts ? "__vue_ts_expression" : "__vue_expression" : L.parser = "__js_expression", [n([u, R(J2.value, L, { stripTrailingHardline: true })]), J2.parent.next && f(J2.parent.next) ? " " : u];
        }
        break;
      }
      case "attribute": {
        if (!J2.value) break;
        if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J2.valueSpan.start.offset, J2.valueSpan.end.offset))) return [J2.rawName, "=", J2.value];
        if (q.parser === "lwc" && /^{.*}$/s.test(q.originalText.slice(J2.valueSpan.start.offset, J2.valueSpan.end.offset))) return [J2.rawName, "=", J2.value];
        let L = b(J2, (Q2, V) => R(Q2, Object.assign({ __isInHtmlAttribute: true, __embeddedInHtml: true }, V), { stripTrailingHardline: true }), q);
        if (L) return [J2.rawName, '="', s(p(L, (Q2) => typeof Q2 == "string" ? Q2.replace(/"/g, "&quot;") : Q2)), '"'];
        break;
      }
      case "front-matter":
        return y(J2, R);
    }
  }
  r.exports = B;
} });
var Bo = te({ "src/language-html/print/children.js"(e, r) {
  "use strict";
  ne();
  var { builders: { breakParent: t, group: s, ifBreak: a, line: n, softline: u, hardline: i }, utils: { replaceTextEndOfLine: l } } = qe(), { locStart: p, locEnd: d } = uu(), { forceBreakChildren: y, forceNextEmptyLine: g, isTextLikeNode: c, hasPrettierIgnore: f, preferHardlineAsLeadingSpaces: E2 } = qt(), { printOpeningTagPrefix: _, needsToBorrowNextOpeningTagStartMarker: w, printOpeningTagStartMarker: F, needsToBorrowPrevClosingTagEndMarker: N, printClosingTagEndMarker: x, printClosingTagSuffix: I, needsToBorrowParentClosingTagStartMarker: P } = rr();
  function $2(m, C, o) {
    let h = m.getValue();
    return f(h) ? [_(h, C), ...l(C.originalText.slice(p(h) + (h.prev && w(h.prev) ? F(h).length : 0), d(h) - (h.next && N(h.next) ? x(h, C).length : 0))), I(h, C)] : o();
  }
  function D(m, C) {
    return c(m) && c(C) ? m.isTrailingSpaceSensitive ? m.hasTrailingSpaces ? E2(C) ? i : n : "" : E2(C) ? i : u : w(m) && (f(C) || C.firstChild || C.isSelfClosing || C.type === "element" && C.attrs.length > 0) || m.type === "element" && m.isSelfClosing && N(C) ? "" : !C.isLeadingSpaceSensitive || E2(C) || N(C) && m.lastChild && P(m.lastChild) && m.lastChild.lastChild && P(m.lastChild.lastChild) ? i : C.hasLeadingSpaces ? n : u;
  }
  function T(m, C, o) {
    let h = m.getValue();
    if (y(h)) return [t, ...m.map((S) => {
      let b = S.getValue(), B = b.prev ? D(b.prev, b) : "";
      return [B ? [B, g(b.prev) ? i : ""] : "", $2(S, C, o)];
    }, "children")];
    let v = h.children.map(() => Symbol(""));
    return m.map((S, b) => {
      let B = S.getValue();
      if (c(B)) {
        if (B.prev && c(B.prev)) {
          let Q2 = D(B.prev, B);
          if (Q2) return g(B.prev) ? [i, i, $2(S, C, o)] : [Q2, $2(S, C, o)];
        }
        return $2(S, C, o);
      }
      let k = [], M = [], R = [], q = [], J2 = B.prev ? D(B.prev, B) : "", L = B.next ? D(B, B.next) : "";
      return J2 && (g(B.prev) ? k.push(i, i) : J2 === i ? k.push(i) : c(B.prev) ? M.push(J2) : M.push(a("", u, { groupId: v[b - 1] }))), L && (g(B) ? c(B.next) && q.push(i, i) : L === i ? c(B.next) && q.push(i) : R.push(L)), [...k, s([...M, s([$2(S, C, o), ...R], { id: v[b] })]), ...q];
    }, "children");
  }
  r.exports = { printChildren: T };
} });
var Eg = te({ "src/language-html/print/element.js"(e, r) {
  "use strict";
  ne();
  var { builders: { breakParent: t, dedentToRoot: s, group: a, ifBreak: n, indentIfBreak: u, indent: i, line: l, softline: p }, utils: { replaceTextEndOfLine: d } } = qe(), y = To(), { shouldPreserveContent: g, isScriptLikeTag: c, isVueCustomBlock: f, countParents: E2, forceBreakContent: _ } = qt(), { printOpeningTagPrefix: w, printOpeningTag: F, printClosingTagSuffix: N, printClosingTag: x, needsToBorrowPrevClosingTagEndMarker: I, needsToBorrowLastChildClosingTagEndMarker: P } = rr(), { printChildren: $2 } = Bo();
  function D(T, m, C) {
    let o = T.getValue();
    if (g(o, m)) return [w(o, m), a(F(T, m, C)), ...d(y(o, m)), ...x(o, m), N(o, m)];
    let h = o.children.length === 1 && o.firstChild.type === "interpolation" && o.firstChild.isLeadingSpaceSensitive && !o.firstChild.hasLeadingSpaces && o.lastChild.isTrailingSpaceSensitive && !o.lastChild.hasTrailingSpaces, v = Symbol("element-attr-group-id"), S = (M) => a([a(F(T, m, C), { id: v }), M, x(o, m)]), b = (M) => h ? u(M, { groupId: v }) : (c(o) || f(o, m)) && o.parent.type === "root" && m.parser === "vue" && !m.vueIndentScriptAndStyle ? M : i(M), B = () => h ? n(p, "", { groupId: v }) : o.firstChild.hasLeadingSpaces && o.firstChild.isLeadingSpaceSensitive ? l : o.firstChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive ? s(p) : p, k = () => (o.next ? I(o.next) : P(o.parent)) ? o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? " " : "" : h ? n(p, "", { groupId: v }) : o.lastChild.hasTrailingSpaces && o.lastChild.isTrailingSpaceSensitive ? l : (o.lastChild.type === "comment" || o.lastChild.type === "text" && o.isWhitespaceSensitive && o.isIndentationSensitive) && new RegExp(`\\n[\\t ]{${m.tabWidth * E2(T, (R) => R.parent && R.parent.type !== "root")}}$`).test(o.lastChild.value) ? "" : p;
    return o.children.length === 0 ? S(o.hasDanglingSpaces && o.isDanglingSpaceSensitive ? l : "") : S([_(o) ? t : "", b([B(), $2(T, m, C)]), k()]);
  }
  r.exports = { printElement: D };
} });
var Fg = te({ "src/language-html/printer-html.js"(e, r) {
  "use strict";
  ne();
  var { builders: { fill: t, group: s, hardline: a, literalline: n }, utils: { cleanDoc: u, getDocParts: i, isConcat: l, replaceTextEndOfLine: p } } = qe(), d = ag(), { countChars: y, unescapeQuoteEntities: g, getTextValueParts: c } = qt(), f = dg(), { insertPragma: E2 } = gg(), { locStart: _, locEnd: w } = uu(), F = Cg(), { printClosingTagSuffix: N, printClosingTagEnd: x, printOpeningTagPrefix: I, printOpeningTagStart: P } = rr(), { printElement: $2 } = Eg(), { printChildren: D } = Bo();
  function T(m, C, o) {
    let h = m.getValue();
    switch (h.type) {
      case "front-matter":
        return p(h.raw);
      case "root":
        return C.__onHtmlRoot && C.__onHtmlRoot(h), [s(D(m, C, o)), a];
      case "element":
      case "ieConditionalComment":
        return $2(m, C, o);
      case "ieConditionalStartComment":
      case "ieConditionalEndComment":
        return [P(h), x(h)];
      case "interpolation":
        return [P(h, C), ...m.map(o, "children"), x(h, C)];
      case "text": {
        if (h.parent.type === "interpolation") {
          let S = /\n[^\S\n]*$/, b = S.test(h.value), B = b ? h.value.replace(S, "") : h.value;
          return [...p(B), b ? a : ""];
        }
        let v = u([I(h, C), ...c(h), N(h, C)]);
        return l(v) || v.type === "fill" ? t(i(v)) : v;
      }
      case "docType":
        return [s([P(h, C), " ", h.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")]), x(h, C)];
      case "comment":
        return [I(h, C), ...p(C.originalText.slice(_(h), w(h)), n), N(h, C)];
      case "attribute": {
        if (h.value === null) return h.rawName;
        let v = g(h.value), S = y(v, "'"), b = y(v, '"'), B = S < b ? "'" : '"';
        return [h.rawName, "=", B, ...p(B === '"' ? v.replace(/"/g, "&quot;") : v.replace(/'/g, "&apos;")), B];
      }
      default:
        throw new Error(`Unexpected node type ${h.type}`);
    }
  }
  r.exports = { preprocess: f, print: T, insertPragma: E2, massageAstNode: d, embed: F };
} });
var Ag = te({ "src/language-html/options.js"(e, r) {
  "use strict";
  ne();
  var t = jt(), s = "HTML";
  r.exports = { bracketSameLine: t.bracketSameLine, htmlWhitespaceSensitivity: { since: "1.15.0", category: s, type: "choice", default: "css", description: "How to handle whitespaces in HTML.", choices: [{ value: "css", description: "Respect the default value of CSS display property." }, { value: "strict", description: "Whitespaces are considered sensitive." }, { value: "ignore", description: "Whitespaces are considered insensitive." }] }, singleAttributePerLine: t.singleAttributePerLine, vueIndentScriptAndStyle: { since: "1.19.0", category: s, type: "boolean", default: false, description: "Indent script and style tags in Vue files." } };
} });
var Sg = te({ "src/language-html/parsers.js"() {
  ne();
} });
var kn = te({ "node_modules/linguist-languages/data/HTML.json"(e, r) {
  r.exports = { name: "HTML", type: "markup", tmScope: "text.html.basic", aceMode: "html", codemirrorMode: "htmlmixed", codemirrorMimeType: "text/html", color: "#e34c26", aliases: ["xhtml"], extensions: [".html", ".hta", ".htm", ".html.hl", ".inc", ".xht", ".xhtml"], languageId: 146 };
} });
var xg = te({ "node_modules/linguist-languages/data/Vue.json"(e, r) {
  r.exports = { name: "Vue", type: "markup", color: "#41b883", extensions: [".vue"], tmScope: "text.html.vue", aceMode: "html", languageId: 391 };
} });
var bg = te({ "src/language-html/index.js"(e, r) {
  "use strict";
  ne();
  var t = wt(), s = Fg(), a = Ag(), n = Sg(), u = [t(kn(), () => ({ name: "Angular", since: "1.15.0", parsers: ["angular"], vscodeLanguageIds: ["html"], extensions: [".component.html"], filenames: [] })), t(kn(), (l) => ({ since: "1.15.0", parsers: ["html"], vscodeLanguageIds: ["html"], extensions: [...l.extensions, ".mjml"] })), t(kn(), () => ({ name: "Lightning Web Components", since: "1.17.0", parsers: ["lwc"], vscodeLanguageIds: ["html"], extensions: [], filenames: [] })), t(xg(), () => ({ since: "1.10.0", parsers: ["vue"], vscodeLanguageIds: ["vue"] }))], i = { html: s };
  r.exports = { languages: u, printers: i, options: a, parsers: n };
} });
var Tg = te({ "src/language-yaml/pragma.js"(e, r) {
  "use strict";
  ne();
  function t(n) {
    return /^\s*@(?:prettier|format)\s*$/.test(n);
  }
  function s(n) {
    return /^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n);
  }
  function a(n) {
    return `# @format

${n}`;
  }
  r.exports = { isPragma: t, hasPragma: s, insertPragma: a };
} });
var Bg = te({ "src/language-yaml/loc.js"(e, r) {
  "use strict";
  ne();
  function t(a) {
    return a.position.start.offset;
  }
  function s(a) {
    return a.position.end.offset;
  }
  r.exports = { locStart: t, locEnd: s };
} });
var Ng = te({ "src/language-yaml/embed.js"(e, r) {
  "use strict";
  ne();
  function t(s, a, n, u) {
    if (s.getValue().type === "root" && u.filepath && /(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath)) return n(u.originalText, Object.assign(Object.assign({}, u), {}, { parser: "json" }));
  }
  r.exports = t;
} });
var Mt = te({ "src/language-yaml/utils.js"(e, r) {
  "use strict";
  ne();
  var { getLast: t, isNonEmptyArray: s } = Ue();
  function a(D, T) {
    let m = 0, C = D.stack.length - 1;
    for (let o = 0; o < C; o++) {
      let h = D.stack[o];
      n(h) && T(h) && m++;
    }
    return m;
  }
  function n(D, T) {
    return D && typeof D.type == "string" && (!T || T.includes(D.type));
  }
  function u(D, T, m) {
    return T("children" in D ? Object.assign(Object.assign({}, D), {}, { children: D.children.map((C) => u(C, T, D)) }) : D, m);
  }
  function i(D, T, m) {
    Object.defineProperty(D, T, { get: m, enumerable: false });
  }
  function l(D, T) {
    let m = 0, C = T.length;
    for (let o = D.position.end.offset - 1; o < C; o++) {
      let h = T[o];
      if (h === `
` && m++, m === 1 && /\S/.test(h)) return false;
      if (m === 2) return true;
    }
    return false;
  }
  function p(D) {
    switch (D.getValue().type) {
      case "tag":
      case "anchor":
      case "comment":
        return false;
    }
    let m = D.stack.length;
    for (let C = 1; C < m; C++) {
      let o = D.stack[C], h = D.stack[C - 1];
      if (Array.isArray(h) && typeof o == "number" && o !== h.length - 1) return false;
    }
    return true;
  }
  function d(D) {
    return s(D.children) ? d(t(D.children)) : D;
  }
  function y(D) {
    return D.value.trim() === "prettier-ignore";
  }
  function g(D) {
    let T = D.getValue();
    if (T.type === "documentBody") {
      let m = D.getParentNode();
      return N(m.head) && y(t(m.head.endComments));
    }
    return E2(T) && y(t(T.leadingComments));
  }
  function c(D) {
    return !s(D.children) && !f(D);
  }
  function f(D) {
    return E2(D) || _(D) || w(D) || F(D) || N(D);
  }
  function E2(D) {
    return s(D == null ? void 0 : D.leadingComments);
  }
  function _(D) {
    return s(D == null ? void 0 : D.middleComments);
  }
  function w(D) {
    return D == null ? void 0 : D.indicatorComment;
  }
  function F(D) {
    return D == null ? void 0 : D.trailingComment;
  }
  function N(D) {
    return s(D == null ? void 0 : D.endComments);
  }
  function x(D) {
    let T = [], m;
    for (let C of D.split(/( +)/)) C !== " " ? m === " " ? T.push(C) : T.push((T.pop() || "") + C) : m === void 0 && T.unshift(""), m = C;
    return m === " " && T.push((T.pop() || "") + " "), T[0] === "" && (T.shift(), T.unshift(" " + (T.shift() || ""))), T;
  }
  function I(D, T, m) {
    let C = T.split(`
`).map((o, h, v) => h === 0 && h === v.length - 1 ? o : h !== 0 && h !== v.length - 1 ? o.trim() : h === 0 ? o.trimEnd() : o.trimStart());
    return m.proseWrap === "preserve" ? C.map((o) => o.length === 0 ? [] : [o]) : C.map((o) => o.length === 0 ? [] : x(o)).reduce((o, h, v) => v !== 0 && C[v - 1].length > 0 && h.length > 0 && !(D === "quoteDouble" && t(t(o)).endsWith("\\")) ? [...o.slice(0, -1), [...t(o), ...h]] : [...o, h], []).map((o) => m.proseWrap === "never" ? [o.join(" ")] : o);
  }
  function P(D, T) {
    let { parentIndent: m, isLastDescendant: C, options: o } = T, h = D.position.start.line === D.position.end.line ? "" : o.originalText.slice(D.position.start.offset, D.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1], v;
    if (D.indent === null) {
      let B = h.match(/^(?<leadingSpace> *)[^\n\r ]/m);
      v = B ? B.groups.leadingSpace.length : Number.POSITIVE_INFINITY;
    } else v = D.indent - 1 + m;
    let S = h.split(`
`).map((B) => B.slice(v));
    if (o.proseWrap === "preserve" || D.type === "blockLiteral") return b(S.map((B) => B.length === 0 ? [] : [B]));
    return b(S.map((B) => B.length === 0 ? [] : x(B)).reduce((B, k, M) => M !== 0 && S[M - 1].length > 0 && k.length > 0 && !/^\s/.test(k[0]) && !/^\s|\s$/.test(t(B)) ? [...B.slice(0, -1), [...t(B), ...k]] : [...B, k], []).map((B) => B.reduce((k, M) => k.length > 0 && /\s$/.test(t(k)) ? [...k.slice(0, -1), t(k) + " " + M] : [...k, M], [])).map((B) => o.proseWrap === "never" ? [B.join(" ")] : B));
    function b(B) {
      if (D.chomping === "keep") return t(B).length === 0 ? B.slice(0, -1) : B;
      let k = 0;
      for (let M = B.length - 1; M >= 0 && B[M].length === 0; M--) k++;
      return k === 0 ? B : k >= 2 && !C ? B.slice(0, -(k - 1)) : B.slice(0, -k);
    }
  }
  function $2(D) {
    if (!D) return true;
    switch (D.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
      case "alias":
      case "flowMapping":
      case "flowSequence":
        return true;
      default:
        return false;
    }
  }
  r.exports = { getLast: t, getAncestorCount: a, isNode: n, isEmptyNode: c, isInlineNode: $2, mapNode: u, defineShortcut: i, isNextLineEmpty: l, isLastDescendantNode: p, getBlockValueLineContents: P, getFlowScalarLineContents: I, getLastDescendantNode: d, hasPrettierIgnore: g, hasLeadingComments: E2, hasMiddleComments: _, hasIndicatorComment: w, hasTrailingComment: F, hasEndComments: N };
} });
var wg = te({ "src/language-yaml/print-preprocess.js"(e, r) {
  "use strict";
  ne();
  var { defineShortcut: t, mapNode: s } = Mt();
  function a(u) {
    return s(u, n);
  }
  function n(u) {
    switch (u.type) {
      case "document":
        t(u, "head", () => u.children[0]), t(u, "body", () => u.children[1]);
        break;
      case "documentBody":
      case "sequenceItem":
      case "flowSequenceItem":
      case "mappingKey":
      case "mappingValue":
        t(u, "content", () => u.children[0]);
        break;
      case "mappingItem":
      case "flowMappingItem":
        t(u, "key", () => u.children[0]), t(u, "value", () => u.children[1]);
        break;
    }
    return u;
  }
  r.exports = a;
} });
var jr = te({ "src/language-yaml/print/misc.js"(e, r) {
  "use strict";
  ne();
  var { builders: { softline: t, align: s } } = qe(), { hasEndComments: a, isNextLineEmpty: n, isNode: u } = Mt(), i = /* @__PURE__ */ new WeakMap();
  function l(y, g) {
    let c = y.getValue(), f = y.stack[0], E2;
    return i.has(f) ? E2 = i.get(f) : (E2 = /* @__PURE__ */ new Set(), i.set(f, E2)), !E2.has(c.position.end.line) && (E2.add(c.position.end.line), n(c, g) && !p(y.getParentNode())) ? t : "";
  }
  function p(y) {
    return a(y) && !u(y, ["documentHead", "documentBody", "flowMapping", "flowSequence"]);
  }
  function d(y, g) {
    return s(" ".repeat(y), g);
  }
  r.exports = { alignWithSpaces: d, shouldPrintEndComments: p, printNextEmptyLine: l };
} });
var _g = te({ "src/language-yaml/print/flow-mapping-sequence.js"(e, r) {
  "use strict";
  ne();
  var { builders: { ifBreak: t, line: s, softline: a, hardline: n, join: u } } = qe(), { isEmptyNode: i, getLast: l, hasEndComments: p } = Mt(), { printNextEmptyLine: d, alignWithSpaces: y } = jr();
  function g(f, E2, _) {
    let w = f.getValue(), F = w.type === "flowMapping", N = F ? "{" : "[", x = F ? "}" : "]", I = a;
    F && w.children.length > 0 && _.bracketSpacing && (I = s);
    let P = l(w.children), $2 = P && P.type === "flowMappingItem" && i(P.key) && i(P.value);
    return [N, y(_.tabWidth, [I, c(f, E2, _), _.trailingComma === "none" ? "" : t(","), p(w) ? [n, u(n, f.map(E2, "endComments"))] : ""]), $2 ? "" : I, x];
  }
  function c(f, E2, _) {
    let w = f.getValue();
    return f.map((N, x) => [E2(), x === w.children.length - 1 ? "" : [",", s, w.children[x].position.start.line !== w.children[x + 1].position.start.line ? d(N, _.originalText) : ""]], "children");
  }
  r.exports = { printFlowMapping: g, printFlowSequence: g };
} });
var Pg = te({ "src/language-yaml/print/mapping-item.js"(e, r) {
  "use strict";
  ne();
  var { builders: { conditionalGroup: t, group: s, hardline: a, ifBreak: n, join: u, line: i } } = qe(), { hasLeadingComments: l, hasMiddleComments: p, hasTrailingComment: d, hasEndComments: y, isNode: g, isEmptyNode: c, isInlineNode: f } = Mt(), { alignWithSpaces: E2 } = jr();
  function _(x, I, P, $2, D) {
    let { key: T, value: m } = x, C = c(T), o = c(m);
    if (C && o) return ": ";
    let h = $2("key"), v = F(x) ? " " : "";
    if (o) return x.type === "flowMappingItem" && I.type === "flowMapping" ? h : x.type === "mappingItem" && w(T.content, D) && !d(T.content) && (!I.tag || I.tag.value !== "tag:yaml.org,2002:set") ? [h, v, ":"] : ["? ", E2(2, h)];
    let S = $2("value");
    if (C) return [": ", E2(2, S)];
    if (l(m) || !f(T.content)) return ["? ", E2(2, h), a, u("", P.map($2, "value", "leadingComments").map((q) => [q, a])), ": ", E2(2, S)];
    if (N(T.content) && !l(T.content) && !p(T.content) && !d(T.content) && !y(T) && !l(m.content) && !p(m.content) && !y(m) && w(m.content, D)) return [h, v, ": ", S];
    let b = Symbol("mappingKey"), B = s([n("? "), s(E2(2, h), { id: b })]), k = [a, ": ", E2(2, S)], M = [v, ":"];
    l(m.content) || y(m) && m.content && !g(m.content, ["mapping", "sequence"]) || I.type === "mapping" && d(T.content) && f(m.content) || g(m.content, ["mapping", "sequence"]) && m.content.tag === null && m.content.anchor === null ? M.push(a) : m.content && M.push(i), M.push(S);
    let R = E2(D.tabWidth, M);
    return w(T.content, D) && !l(T.content) && !p(T.content) && !y(T) ? t([[h, R]]) : t([[B, n(k, R, { groupId: b })]]);
  }
  function w(x, I) {
    if (!x) return true;
    switch (x.type) {
      case "plain":
      case "quoteSingle":
      case "quoteDouble":
        break;
      case "alias":
        return true;
      default:
        return false;
    }
    if (I.proseWrap === "preserve") return x.position.start.line === x.position.end.line;
    if (/\\$/m.test(I.originalText.slice(x.position.start.offset, x.position.end.offset))) return false;
    switch (I.proseWrap) {
      case "never":
        return !x.value.includes(`
`);
      case "always":
        return !/[\n ]/.test(x.value);
      default:
        return false;
    }
  }
  function F(x) {
    return x.key.content && x.key.content.type === "alias";
  }
  function N(x) {
    if (!x) return true;
    switch (x.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
        return x.position.start.line === x.position.end.line;
      case "alias":
        return true;
      default:
        return false;
    }
  }
  r.exports = _;
} });
var Ig = te({ "src/language-yaml/print/block.js"(e, r) {
  "use strict";
  ne();
  var { builders: { dedent: t, dedentToRoot: s, fill: a, hardline: n, join: u, line: i, literalline: l, markAsRoot: p }, utils: { getDocParts: d } } = qe(), { getAncestorCount: y, getBlockValueLineContents: g, hasIndicatorComment: c, isLastDescendantNode: f, isNode: E2 } = Mt(), { alignWithSpaces: _ } = jr();
  function w(F, N, x) {
    let I = F.getValue(), P = y(F, (C) => E2(C, ["sequence", "mapping"])), $2 = f(F), D = [I.type === "blockFolded" ? ">" : "|"];
    I.indent !== null && D.push(I.indent.toString()), I.chomping !== "clip" && D.push(I.chomping === "keep" ? "+" : "-"), c(I) && D.push(" ", N("indicatorComment"));
    let T = g(I, { parentIndent: P, isLastDescendant: $2, options: x }), m = [];
    for (let [C, o] of T.entries()) C === 0 && m.push(n), m.push(a(d(u(i, o)))), C !== T.length - 1 ? m.push(o.length === 0 ? n : p(l)) : I.chomping === "keep" && $2 && m.push(s(o.length === 0 ? n : l));
    return I.indent === null ? D.push(t(_(x.tabWidth, m))) : D.push(s(_(I.indent - 1 + P, m))), D;
  }
  r.exports = w;
} });
var kg = te({ "src/language-yaml/printer-yaml.js"(e, r) {
  "use strict";
  ne();
  var { builders: { breakParent: t, fill: s, group: a, hardline: n, join: u, line: i, lineSuffix: l, literalline: p }, utils: { getDocParts: d, replaceTextEndOfLine: y } } = qe(), { isPreviousLineEmpty: g } = Ue(), { insertPragma: c, isPragma: f } = Tg(), { locStart: E2 } = Bg(), _ = Ng(), { getFlowScalarLineContents: w, getLastDescendantNode: F, hasLeadingComments: N, hasMiddleComments: x, hasTrailingComment: I, hasEndComments: P, hasPrettierIgnore: $2, isLastDescendantNode: D, isNode: T, isInlineNode: m } = Mt(), C = wg(), { alignWithSpaces: o, printNextEmptyLine: h, shouldPrintEndComments: v } = jr(), { printFlowMapping: S, printFlowSequence: b } = _g(), B = Pg(), k = Ig();
  function M(j, Y, ie) {
    let ee = j.getValue(), ce = [];
    ee.type !== "mappingValue" && N(ee) && ce.push([u(n, j.map(ie, "leadingComments")), n]);
    let { tag: W, anchor: K } = ee;
    W && ce.push(ie("tag")), W && K && ce.push(" "), K && ce.push(ie("anchor"));
    let de = "";
    T(ee, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !D(j) && (de = h(j, Y.originalText)), (W || K) && (T(ee, ["sequence", "mapping"]) && !x(ee) ? ce.push(n) : ce.push(" ")), x(ee) && ce.push([ee.middleComments.length === 1 ? "" : n, u(n, j.map(ie, "middleComments")), n]);
    let ue = j.getParentNode();
    return $2(j) ? ce.push(y(Y.originalText.slice(ee.position.start.offset, ee.position.end.offset).trimEnd(), p)) : ce.push(a(R(ee, ue, j, Y, ie))), I(ee) && !T(ee, ["document", "documentHead"]) && ce.push(l([ee.type === "mappingValue" && !ee.content ? "" : " ", ue.type === "mappingKey" && j.getParentNode(2).type === "mapping" && m(ee) ? "" : t, ie("trailingComment")])), v(ee) && ce.push(o(ee.type === "sequenceItem" ? 2 : 0, [n, u(n, j.map((Fe) => [g(Y.originalText, Fe.getValue(), E2) ? n : "", ie()], "endComments"))])), ce.push(de), ce;
  }
  function R(j, Y, ie, ee, ce) {
    switch (j.type) {
      case "root": {
        let { children: W } = j, K = [];
        ie.each((ue, Fe) => {
          let z = W[Fe], U = W[Fe + 1];
          Fe !== 0 && K.push(n), K.push(ce()), J2(z, U) ? (K.push(n, "..."), I(z) && K.push(" ", ce("trailingComment"))) : U && !I(U.head) && K.push(n, "---");
        }, "children");
        let de = F(j);
        return (!T(de, ["blockLiteral", "blockFolded"]) || de.chomping !== "keep") && K.push(n), K;
      }
      case "document": {
        let W = Y.children[ie.getName() + 1], K = [];
        return L(j, W, Y, ee) === "head" && ((j.head.children.length > 0 || j.head.endComments.length > 0) && K.push(ce("head")), I(j.head) ? K.push(["---", " ", ce(["head", "trailingComment"])]) : K.push("---")), q(j) && K.push(ce("body")), u(n, K);
      }
      case "documentHead":
        return u(n, [...ie.map(ce, "children"), ...ie.map(ce, "endComments")]);
      case "documentBody": {
        let { children: W, endComments: K } = j, de = "";
        if (W.length > 0 && K.length > 0) {
          let ue = F(j);
          T(ue, ["blockFolded", "blockLiteral"]) ? ue.chomping !== "keep" && (de = [n, n]) : de = n;
        }
        return [u(n, ie.map(ce, "children")), de, u(n, ie.map(ce, "endComments"))];
      }
      case "directive":
        return ["%", u(" ", [j.name, ...j.parameters])];
      case "comment":
        return ["#", j.value];
      case "alias":
        return ["*", j.value];
      case "tag":
        return ee.originalText.slice(j.position.start.offset, j.position.end.offset);
      case "anchor":
        return ["&", j.value];
      case "plain":
        return Q2(j.type, ee.originalText.slice(j.position.start.offset, j.position.end.offset), ee);
      case "quoteDouble":
      case "quoteSingle": {
        let W = "'", K = '"', de = ee.originalText.slice(j.position.start.offset + 1, j.position.end.offset - 1);
        if (j.type === "quoteSingle" && de.includes("\\") || j.type === "quoteDouble" && /\\[^"]/.test(de)) {
          let Fe = j.type === "quoteDouble" ? K : W;
          return [Fe, Q2(j.type, de, ee), Fe];
        }
        if (de.includes(K)) return [W, Q2(j.type, j.type === "quoteDouble" ? de.replace(/\\"/g, K).replace(/'/g, W.repeat(2)) : de, ee), W];
        if (de.includes(W)) return [K, Q2(j.type, j.type === "quoteSingle" ? de.replace(/''/g, W) : de, ee), K];
        let ue = ee.singleQuote ? W : K;
        return [ue, Q2(j.type, de, ee), ue];
      }
      case "blockFolded":
      case "blockLiteral":
        return k(ie, ce, ee);
      case "mapping":
      case "sequence":
        return u(n, ie.map(ce, "children"));
      case "sequenceItem":
        return ["- ", o(2, j.content ? ce("content") : "")];
      case "mappingKey":
      case "mappingValue":
        return j.content ? ce("content") : "";
      case "mappingItem":
      case "flowMappingItem":
        return B(j, Y, ie, ce, ee);
      case "flowMapping":
        return S(ie, ce, ee);
      case "flowSequence":
        return b(ie, ce, ee);
      case "flowSequenceItem":
        return ce("content");
      default:
        throw new Error(`Unexpected node type ${j.type}`);
    }
  }
  function q(j) {
    return j.body.children.length > 0 || P(j.body);
  }
  function J2(j, Y) {
    return I(j) || Y && (Y.head.children.length > 0 || P(Y.head));
  }
  function L(j, Y, ie, ee) {
    return ie.children[0] === j && /---(?:\s|$)/.test(ee.originalText.slice(E2(j), E2(j) + 4)) || j.head.children.length > 0 || P(j.head) || I(j.head) ? "head" : J2(j, Y) ? false : Y ? "root" : false;
  }
  function Q2(j, Y, ie) {
    let ee = w(j, Y, ie);
    return u(n, ee.map((ce) => s(d(u(i, ce)))));
  }
  function V(j, Y) {
    if (T(Y)) switch (delete Y.position, Y.type) {
      case "comment":
        if (f(Y.value)) return null;
        break;
      case "quoteDouble":
      case "quoteSingle":
        Y.type = "quote";
        break;
    }
  }
  r.exports = { preprocess: C, embed: _, print: M, massageAstNode: V, insertPragma: c };
} });
var Lg = te({ "src/language-yaml/options.js"(e, r) {
  "use strict";
  ne();
  var t = jt();
  r.exports = { bracketSpacing: t.bracketSpacing, singleQuote: t.singleQuote, proseWrap: t.proseWrap };
} });
var Og = te({ "src/language-yaml/parsers.js"() {
  ne();
} });
var jg = te({ "node_modules/linguist-languages/data/YAML.json"(e, r) {
  r.exports = { name: "YAML", type: "data", color: "#cb171e", tmScope: "source.yaml", aliases: ["yml"], extensions: [".yml", ".mir", ".reek", ".rviz", ".sublime-syntax", ".syntax", ".yaml", ".yaml-tmlanguage", ".yaml.sed", ".yml.mysql"], filenames: [".clang-format", ".clang-tidy", ".gemrc", "CITATION.cff", "glide.lock", "yarn.lock"], aceMode: "yaml", codemirrorMode: "yaml", codemirrorMimeType: "text/x-yaml", languageId: 407 };
} });
var qg = te({ "src/language-yaml/index.js"(e, r) {
  "use strict";
  ne();
  var t = wt(), s = kg(), a = Lg(), n = Og(), u = [t(jg(), (i) => ({ since: "1.14.0", parsers: ["yaml"], vscodeLanguageIds: ["yaml", "ansible", "home-assistant"], filenames: [...i.filenames.filter((l) => l !== "yarn.lock"), ".prettierrc", ".stylelintrc", ".lintstagedrc"] }))];
  r.exports = { languages: u, printers: { yaml: s }, options: a, parsers: n };
} });
var Mg = te({ "src/languages.js"(e, r) {
  "use strict";
  ne(), r.exports = [vd(), jd(), Gd(), Qd(), ig(), bg(), qg()];
} });
var Rg = te({ "src/standalone.js"(e, r) {
  ne();
  var { version: t } = xa(), s = Om(), { getSupportInfo: a } = Un(), n = jm(), u = Mg(), i = qe();
  function l(d) {
    let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return function() {
      for (var g = arguments.length, c = new Array(g), f = 0; f < g; f++) c[f] = arguments[f];
      let E2 = c[y] || {}, _ = E2.plugins || [];
      return c[y] = Object.assign(Object.assign({}, E2), {}, { plugins: [...u, ...Array.isArray(_) ? _ : Object.values(_)] }), d(...c);
    };
  }
  var p = l(s.formatWithCursor);
  r.exports = { formatWithCursor: p, format(d, y) {
    return p(d, y).formatted;
  }, check(d, y) {
    let { formatted: g } = p(d, y);
    return g === d;
  }, doc: i, getSupportInfo: l(a, 0), version: t, util: n, __debug: { parse: l(s.parse), formatAST: l(s.formatAST), formatDoc: l(s.formatDoc), printToDoc: l(s.printToDoc), printDocToString: l(s.printDocToString) } };
} });
var Ty = Rg();

// ../../../node_modules/.pnpm/prettier@2.8.8/node_modules/prettier/esm/parser-espree.mjs
var E = (a, u) => () => (u || a((u = { exports: {} }).exports, u), u.exports);
var oe = E((Qh, zr) => {
  var Ye = function(a) {
    return a && a.Math == Math && a;
  };
  zr.exports = Ye(typeof globalThis == "object" && globalThis) || Ye(typeof window == "object" && window) || Ye(typeof self == "object" && self) || Ye(typeof global == "object" && global) || /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")();
});
var me = E(($h, Gr2) => {
  Gr2.exports = function(a) {
    try {
      return !!a();
    } catch {
      return true;
    }
  };
});
var xe = E((Yh, Hr) => {
  var fn = me();
  Hr.exports = !fn(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] != 7;
  });
});
var bt2 = E((Zh, Kr2) => {
  var dn2 = me();
  Kr2.exports = !dn2(function() {
    var a = function() {
    }.bind();
    return typeof a != "function" || a.hasOwnProperty("prototype");
  });
});
var et2 = E((el, Xr2) => {
  var mn = bt2(), Ze = Function.prototype.call;
  Xr2.exports = mn ? Ze.bind(Ze) : function() {
    return Ze.apply(Ze, arguments);
  };
});
var Yr2 = E(($r) => {
  "use strict";
  var Jr2 = {}.propertyIsEnumerable, Qr = Object.getOwnPropertyDescriptor, vn = Qr && !Jr2.call({ 1: 2 }, 1);
  $r.f = vn ? function(u) {
    var o = Qr(this, u);
    return !!o && o.enumerable;
  } : Jr2;
});
var _t2 = E((rl, Zr) => {
  Zr.exports = function(a, u) {
    return { enumerable: !(a & 1), configurable: !(a & 2), writable: !(a & 4), value: u };
  };
});
var ye = E((il, ri2) => {
  var ei = bt2(), ti = Function.prototype, St2 = ti.call, gn2 = ei && ti.bind.bind(St2, St2);
  ri2.exports = ei ? gn2 : function(a) {
    return function() {
      return St2.apply(a, arguments);
    };
  };
});
var ai = E((sl, si) => {
  var ii = ye(), xn2 = ii({}.toString), yn = ii("".slice);
  si.exports = function(a) {
    return yn(xn2(a), 8, -1);
  };
});
var ui2 = E((al, ni) => {
  var An = ye(), Cn = me(), En2 = ai(), wt2 = Object, bn2 = An("".split);
  ni.exports = Cn(function() {
    return !wt2("z").propertyIsEnumerable(0);
  }) ? function(a) {
    return En2(a) == "String" ? bn2(a, "") : wt2(a);
  } : wt2;
});
var kt2 = E((nl, oi2) => {
  oi2.exports = function(a) {
    return a == null;
  };
});
var Ft2 = E((ul, hi) => {
  var _n2 = kt2(), Sn2 = TypeError;
  hi.exports = function(a) {
    if (_n2(a)) throw Sn2("Can't call method on " + a);
    return a;
  };
});
var tt = E((ol, li) => {
  var wn2 = ui2(), kn2 = Ft2();
  li.exports = function(a) {
    return wn2(kn2(a));
  };
});
var It2 = E((hl, ci) => {
  var Bt = typeof document == "object" && document.all, Fn = typeof Bt > "u" && Bt !== void 0;
  ci.exports = { all: Bt, IS_HTMLDDA: Fn };
});
var le = E((ll, fi) => {
  var pi2 = It2(), Bn = pi2.all;
  fi.exports = pi2.IS_HTMLDDA ? function(a) {
    return typeof a == "function" || a === Bn;
  } : function(a) {
    return typeof a == "function";
  };
});
var Pe = E((cl, vi2) => {
  var di2 = le(), mi = It2(), In2 = mi.all;
  vi2.exports = mi.IS_HTMLDDA ? function(a) {
    return typeof a == "object" ? a !== null : di2(a) || a === In2;
  } : function(a) {
    return typeof a == "object" ? a !== null : di2(a);
  };
});
var rt = E((pl, gi) => {
  var Tt2 = oe(), Tn2 = le(), Pn = function(a) {
    return Tn2(a) ? a : void 0;
  };
  gi.exports = function(a, u) {
    return arguments.length < 2 ? Pn(Tt2[a]) : Tt2[a] && Tt2[a][u];
  };
});
var yi2 = E((fl, xi) => {
  var Dn = ye();
  xi.exports = Dn({}.isPrototypeOf);
});
var Ci = E((dl, Ai) => {
  var Nn2 = rt();
  Ai.exports = Nn2("navigator", "userAgent") || "";
});
var Fi2 = E((ml, ki) => {
  var wi2 = oe(), Pt = Ci(), Ei = wi2.process, bi = wi2.Deno, _i = Ei && Ei.versions || bi && bi.version, Si2 = _i && _i.v8, ce, it;
  Si2 && (ce = Si2.split("."), it = ce[0] > 0 && ce[0] < 4 ? 1 : +(ce[0] + ce[1]));
  !it && Pt && (ce = Pt.match(/Edge\/(\d+)/), (!ce || ce[1] >= 74) && (ce = Pt.match(/Chrome\/(\d+)/), ce && (it = +ce[1])));
  ki.exports = it;
});
var Dt2 = E((vl, Ii) => {
  var Bi2 = Fi2(), On2 = me();
  Ii.exports = !!Object.getOwnPropertySymbols && !On2(function() {
    var a = Symbol();
    return !String(a) || !(Object(a) instanceof Symbol) || !Symbol.sham && Bi2 && Bi2 < 41;
  });
});
var Nt2 = E((gl, Ti) => {
  var Ln2 = Dt2();
  Ti.exports = Ln2 && !Symbol.sham && typeof Symbol.iterator == "symbol";
});
var Ot2 = E((xl, Pi) => {
  var Vn2 = rt(), Rn2 = le(), jn2 = yi2(), qn2 = Nt2(), Mn2 = Object;
  Pi.exports = qn2 ? function(a) {
    return typeof a == "symbol";
  } : function(a) {
    var u = Vn2("Symbol");
    return Rn2(u) && jn2(u.prototype, Mn2(a));
  };
});
var Ni = E((yl, Di2) => {
  var Un2 = String;
  Di2.exports = function(a) {
    try {
      return Un2(a);
    } catch {
      return "Object";
    }
  };
});
var Li = E((Al, Oi) => {
  var Wn2 = le(), zn2 = Ni(), Gn2 = TypeError;
  Oi.exports = function(a) {
    if (Wn2(a)) return a;
    throw Gn2(zn2(a) + " is not a function");
  };
});
var Ri = E((Cl, Vi) => {
  var Hn2 = Li(), Kn2 = kt2();
  Vi.exports = function(a, u) {
    var o = a[u];
    return Kn2(o) ? void 0 : Hn2(o);
  };
});
var qi = E((El, ji2) => {
  var Lt2 = et2(), Vt2 = le(), Rt2 = Pe(), Xn2 = TypeError;
  ji2.exports = function(a, u) {
    var o, l;
    if (u === "string" && Vt2(o = a.toString) && !Rt2(l = Lt2(o, a)) || Vt2(o = a.valueOf) && !Rt2(l = Lt2(o, a)) || u !== "string" && Vt2(o = a.toString) && !Rt2(l = Lt2(o, a))) return l;
    throw Xn2("Can't convert object to primitive value");
  };
});
var Ui = E((bl, Mi) => {
  Mi.exports = false;
});
var st = E((_l, zi2) => {
  var Wi = oe(), Jn2 = Object.defineProperty;
  zi2.exports = function(a, u) {
    try {
      Jn2(Wi, a, { value: u, configurable: true, writable: true });
    } catch {
      Wi[a] = u;
    }
    return u;
  };
});
var at2 = E((Sl, Hi2) => {
  var Qn2 = oe(), $n2 = st(), Gi = "__core-js_shared__", Yn2 = Qn2[Gi] || $n2(Gi, {});
  Hi2.exports = Yn2;
});
var jt2 = E((wl, Xi) => {
  var Zn2 = Ui(), Ki = at2();
  (Xi.exports = function(a, u) {
    return Ki[a] || (Ki[a] = u !== void 0 ? u : {});
  })("versions", []).push({ version: "3.26.1", mode: Zn2 ? "pure" : "global", copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)", license: "https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE", source: "https://github.com/zloirock/core-js" });
});
var Qi2 = E((kl, Ji) => {
  var eu2 = Ft2(), tu2 = Object;
  Ji.exports = function(a) {
    return tu2(eu2(a));
  };
});
var be = E((Fl, $i) => {
  var ru2 = ye(), iu = Qi2(), su = ru2({}.hasOwnProperty);
  $i.exports = Object.hasOwn || function(u, o) {
    return su(iu(u), o);
  };
});
var qt2 = E((Bl, Yi) => {
  var au = ye(), nu2 = 0, uu2 = Math.random(), ou = au(1 .toString);
  Yi.exports = function(a) {
    return "Symbol(" + (a === void 0 ? "" : a) + ")_" + ou(++nu2 + uu2, 36);
  };
});
var ss = E((Il, is3) => {
  var hu = oe(), lu = jt2(), Zi = be(), cu = qt2(), es = Dt2(), rs = Nt2(), De = lu("wks"), we = hu.Symbol, ts2 = we && we.for, pu = rs ? we : we && we.withoutSetter || cu;
  is3.exports = function(a) {
    if (!Zi(De, a) || !(es || typeof De[a] == "string")) {
      var u = "Symbol." + a;
      es && Zi(we, a) ? De[a] = we[a] : rs && ts2 ? De[a] = ts2(u) : De[a] = pu(u);
    }
    return De[a];
  };
});
var os = E((Tl, us) => {
  var fu = et2(), as = Pe(), ns = Ot2(), du = Ri(), mu = qi(), vu = ss(), gu2 = TypeError, xu = vu("toPrimitive");
  us.exports = function(a, u) {
    if (!as(a) || ns(a)) return a;
    var o = du(a, xu), l;
    if (o) {
      if (u === void 0 && (u = "default"), l = fu(o, a, u), !as(l) || ns(l)) return l;
      throw gu2("Can't convert object to primitive value");
    }
    return u === void 0 && (u = "number"), mu(a, u);
  };
});
var Mt2 = E((Pl, hs) => {
  var yu = os(), Au = Ot2();
  hs.exports = function(a) {
    var u = yu(a, "string");
    return Au(u) ? u : u + "";
  };
});
var ps = E((Dl, cs) => {
  var Cu = oe(), ls = Pe(), Ut = Cu.document, Eu = ls(Ut) && ls(Ut.createElement);
  cs.exports = function(a) {
    return Eu ? Ut.createElement(a) : {};
  };
});
var Wt = E((Nl, fs) => {
  var bu = xe(), _u = me(), Su2 = ps();
  fs.exports = !bu && !_u(function() {
    return Object.defineProperty(Su2("div"), "a", { get: function() {
      return 7;
    } }).a != 7;
  });
});
var zt2 = E((ms) => {
  var wu = xe(), ku = et2(), Fu = Yr2(), Bu = _t2(), Iu = tt(), Tu = Mt2(), Pu = be(), Du = Wt(), ds = Object.getOwnPropertyDescriptor;
  ms.f = wu ? ds : function(u, o) {
    if (u = Iu(u), o = Tu(o), Du) try {
      return ds(u, o);
    } catch {
    }
    if (Pu(u, o)) return Bu(!ku(Fu.f, u, o), u[o]);
  };
});
var gs = E((Ll, vs2) => {
  var Nu = xe(), Ou = me();
  vs2.exports = Nu && Ou(function() {
    return Object.defineProperty(function() {
    }, "prototype", { value: 42, writable: false }).prototype != 42;
  });
});
var nt = E((Vl, xs) => {
  var Lu = Pe(), Vu = String, Ru = TypeError;
  xs.exports = function(a) {
    if (Lu(a)) return a;
    throw Ru(Vu(a) + " is not an object");
  };
});
var Me = E((As2) => {
  var ju2 = xe(), qu = Wt(), Mu = gs(), ut2 = nt(), ys = Mt2(), Uu = TypeError, Gt2 = Object.defineProperty, Wu = Object.getOwnPropertyDescriptor, Ht = "enumerable", Kt2 = "configurable", Xt2 = "writable";
  As2.f = ju2 ? Mu ? function(u, o, l) {
    if (ut2(u), o = ys(o), ut2(l), typeof u == "function" && o === "prototype" && "value" in l && Xt2 in l && !l[Xt2]) {
      var v = Wu(u, o);
      v && v[Xt2] && (u[o] = l.value, l = { configurable: Kt2 in l ? l[Kt2] : v[Kt2], enumerable: Ht in l ? l[Ht] : v[Ht], writable: false });
    }
    return Gt2(u, o, l);
  } : Gt2 : function(u, o, l) {
    if (ut2(u), o = ys(o), ut2(l), qu) try {
      return Gt2(u, o, l);
    } catch {
    }
    if ("get" in l || "set" in l) throw Uu("Accessors not supported");
    return "value" in l && (u[o] = l.value), u;
  };
});
var Jt2 = E((jl, Cs) => {
  var zu = xe(), Gu = Me(), Hu2 = _t2();
  Cs.exports = zu ? function(a, u, o) {
    return Gu.f(a, u, Hu2(1, o));
  } : function(a, u, o) {
    return a[u] = o, a;
  };
});
var _s = E((ql, bs) => {
  var Qt2 = xe(), Ku = be(), Es = Function.prototype, Xu = Qt2 && Object.getOwnPropertyDescriptor, $t2 = Ku(Es, "name"), Ju = $t2 && function() {
  }.name === "something", Qu = $t2 && (!Qt2 || Qt2 && Xu(Es, "name").configurable);
  bs.exports = { EXISTS: $t2, PROPER: Ju, CONFIGURABLE: Qu };
});
var ws = E((Ml, Ss) => {
  var $u = ye(), Yu = le(), Yt2 = at2(), Zu2 = $u(Function.toString);
  Yu(Yt2.inspectSource) || (Yt2.inspectSource = function(a) {
    return Zu2(a);
  });
  Ss.exports = Yt2.inspectSource;
});
var Bs2 = E((Ul, Fs) => {
  var eo2 = oe(), to2 = le(), ks = eo2.WeakMap;
  Fs.exports = to2(ks) && /native code/.test(String(ks));
});
var Ps = E((Wl, Ts) => {
  var ro2 = jt2(), io2 = qt2(), Is = ro2("keys");
  Ts.exports = function(a) {
    return Is[a] || (Is[a] = io2(a));
  };
});
var Zt2 = E((zl, Ds) => {
  Ds.exports = {};
});
var Vs2 = E((Gl, Ls2) => {
  var so2 = Bs2(), Os = oe(), ao2 = Pe(), no2 = Jt2(), er2 = be(), tr2 = at2(), uo2 = Ps(), oo2 = Zt2(), Ns = "Object already initialized", rr2 = Os.TypeError, ho2 = Os.WeakMap, ot2, Ue2, ht2, lo2 = function(a) {
    return ht2(a) ? Ue2(a) : ot2(a, {});
  }, co2 = function(a) {
    return function(u) {
      var o;
      if (!ao2(u) || (o = Ue2(u)).type !== a) throw rr2("Incompatible receiver, " + a + " required");
      return o;
    };
  };
  so2 || tr2.state ? (pe = tr2.state || (tr2.state = new ho2()), pe.get = pe.get, pe.has = pe.has, pe.set = pe.set, ot2 = function(a, u) {
    if (pe.has(a)) throw rr2(Ns);
    return u.facade = a, pe.set(a, u), u;
  }, Ue2 = function(a) {
    return pe.get(a) || {};
  }, ht2 = function(a) {
    return pe.has(a);
  }) : (ke = uo2("state"), oo2[ke] = true, ot2 = function(a, u) {
    if (er2(a, ke)) throw rr2(Ns);
    return u.facade = a, no2(a, ke, u), u;
  }, Ue2 = function(a) {
    return er2(a, ke) ? a[ke] : {};
  }, ht2 = function(a) {
    return er2(a, ke);
  });
  var pe, ke;
  Ls2.exports = { set: ot2, get: Ue2, has: ht2, enforce: lo2, getterFor: co2 };
});
var sr2 = E((Hl, js) => {
  var po2 = me(), fo2 = le(), lt2 = be(), ir = xe(), mo2 = _s().CONFIGURABLE, vo2 = ws(), Rs = Vs2(), go2 = Rs.enforce, xo2 = Rs.get, ct2 = Object.defineProperty, yo2 = ir && !po2(function() {
    return ct2(function() {
    }, "length", { value: 8 }).length !== 8;
  }), Ao2 = String(String).split("String"), Co2 = js.exports = function(a, u, o) {
    String(u).slice(0, 7) === "Symbol(" && (u = "[" + String(u).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), o && o.getter && (u = "get " + u), o && o.setter && (u = "set " + u), (!lt2(a, "name") || mo2 && a.name !== u) && (ir ? ct2(a, "name", { value: u, configurable: true }) : a.name = u), yo2 && o && lt2(o, "arity") && a.length !== o.arity && ct2(a, "length", { value: o.arity });
    try {
      o && lt2(o, "constructor") && o.constructor ? ir && ct2(a, "prototype", { writable: false }) : a.prototype && (a.prototype = void 0);
    } catch {
    }
    var l = go2(a);
    return lt2(l, "source") || (l.source = Ao2.join(typeof u == "string" ? u : "")), a;
  };
  Function.prototype.toString = Co2(function() {
    return fo2(this) && xo2(this).source || vo2(this);
  }, "toString");
});
var Ms2 = E((Kl, qs) => {
  var Eo2 = le(), bo2 = Me(), _o = sr2(), So2 = st();
  qs.exports = function(a, u, o, l) {
    l || (l = {});
    var v = l.enumerable, b = l.name !== void 0 ? l.name : u;
    if (Eo2(o) && _o(o, b, l), l.global) v ? a[u] = o : So2(u, o);
    else {
      try {
        l.unsafe ? a[u] && (v = true) : delete a[u];
      } catch {
      }
      v ? a[u] = o : bo2.f(a, u, { value: o, enumerable: false, configurable: !l.nonConfigurable, writable: !l.nonWritable });
    }
    return a;
  };
});
var Ws = E((Xl, Us) => {
  var wo = Math.ceil, ko = Math.floor;
  Us.exports = Math.trunc || function(u) {
    var o = +u;
    return (o > 0 ? ko : wo)(o);
  };
});
var ar2 = E((Jl, zs) => {
  var Fo2 = Ws();
  zs.exports = function(a) {
    var u = +a;
    return u !== u || u === 0 ? 0 : Fo2(u);
  };
});
var Hs = E((Ql, Gs) => {
  var Bo2 = ar2(), Io = Math.max, To2 = Math.min;
  Gs.exports = function(a, u) {
    var o = Bo2(a);
    return o < 0 ? Io(o + u, 0) : To2(o, u);
  };
});
var Xs = E(($l, Ks) => {
  var Po = ar2(), Do2 = Math.min;
  Ks.exports = function(a) {
    return a > 0 ? Do2(Po(a), 9007199254740991) : 0;
  };
});
var Qs = E((Yl, Js2) => {
  var No = Xs();
  Js2.exports = function(a) {
    return No(a.length);
  };
});
var Zs2 = E((Zl, Ys2) => {
  var Oo = tt(), Lo = Hs(), Vo = Qs(), $s = function(a) {
    return function(u, o, l) {
      var v = Oo(u), b = Vo(v), y = Lo(l, b), I;
      if (a && o != o) {
        for (; b > y; ) if (I = v[y++], I != I) return true;
      } else for (; b > y; y++) if ((a || y in v) && v[y] === o) return a || y || 0;
      return !a && -1;
    };
  };
  Ys2.exports = { includes: $s(true), indexOf: $s(false) };
});
var ra2 = E((ec, ta) => {
  var Ro = ye(), nr = be(), jo = tt(), qo = Zs2().indexOf, Mo = Zt2(), ea = Ro([].push);
  ta.exports = function(a, u) {
    var o = jo(a), l = 0, v = [], b;
    for (b in o) !nr(Mo, b) && nr(o, b) && ea(v, b);
    for (; u.length > l; ) nr(o, b = u[l++]) && (~qo(v, b) || ea(v, b));
    return v;
  };
});
var sa2 = E((tc, ia) => {
  ia.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
});
var na = E((aa) => {
  var Uo = ra2(), Wo = sa2(), zo = Wo.concat("length", "prototype");
  aa.f = Object.getOwnPropertyNames || function(u) {
    return Uo(u, zo);
  };
});
var oa = E((ua) => {
  ua.f = Object.getOwnPropertySymbols;
});
var la = E((sc, ha2) => {
  var Go = rt(), Ho = ye(), Ko = na(), Xo = oa(), Jo = nt(), Qo = Ho([].concat);
  ha2.exports = Go("Reflect", "ownKeys") || function(u) {
    var o = Ko.f(Jo(u)), l = Xo.f;
    return l ? Qo(o, l(u)) : o;
  };
});
var fa2 = E((ac, pa) => {
  var ca2 = be(), $o = la(), Yo = zt2(), Zo = Me();
  pa.exports = function(a, u, o) {
    for (var l = $o(u), v = Zo.f, b = Yo.f, y = 0; y < l.length; y++) {
      var I = l[y];
      !ca2(a, I) && !(o && ca2(o, I)) && v(a, I, b(u, I));
    }
  };
});
var ma = E((nc, da2) => {
  var eh = me(), th = le(), rh = /#|\.prototype\./, We = function(a, u) {
    var o = sh[ih(a)];
    return o == nh ? true : o == ah ? false : th(u) ? eh(u) : !!u;
  }, ih = We.normalize = function(a) {
    return String(a).replace(rh, ".").toLowerCase();
  }, sh = We.data = {}, ah = We.NATIVE = "N", nh = We.POLYFILL = "P";
  da2.exports = We;
});
var ga = E((uc, va2) => {
  var ur = oe(), uh = zt2().f, oh = Jt2(), hh = Ms2(), lh = st(), ch = fa2(), ph = ma();
  va2.exports = function(a, u) {
    var o = a.target, l = a.global, v = a.stat, b, y, I, T, x, R;
    if (l ? y = ur : v ? y = ur[o] || lh(o, {}) : y = (ur[o] || {}).prototype, y) for (I in u) {
      if (x = u[I], a.dontCallGetSet ? (R = uh(y, I), T = R && R.value) : T = y[I], b = ph(l ? I : o + (v ? "." : "#") + I, a.forced), !b && T !== void 0) {
        if (typeof x == typeof T) continue;
        ch(x, T);
      }
      (a.sham || T && T.sham) && oh(x, "sham", true), hh(y, I, x, a);
    }
  };
});
var xa2 = E(() => {
  var fh = ga(), or2 = oe();
  fh({ global: true, forced: or2.globalThis !== or2 }, { globalThis: or2 });
});
var Ca2 = E((lc, Aa2) => {
  var ya2 = sr2(), dh = Me();
  Aa2.exports = function(a, u, o) {
    return o.get && ya2(o.get, u, { getter: true }), o.set && ya2(o.set, u, { setter: true }), dh.f(a, u, o);
  };
});
var ba2 = E((cc, Ea2) => {
  "use strict";
  var mh = nt();
  Ea2.exports = function() {
    var a = mh(this), u = "";
    return a.hasIndices && (u += "d"), a.global && (u += "g"), a.ignoreCase && (u += "i"), a.multiline && (u += "m"), a.dotAll && (u += "s"), a.unicode && (u += "u"), a.unicodeSets && (u += "v"), a.sticky && (u += "y"), u;
  };
});
xa2();
var vh = oe();
var gh = xe();
var xh = Ca2();
var yh = ba2();
var Ah = me();
var _a2 = vh.RegExp;
var Sa2 = _a2.prototype;
var Ch = gh && Ah(function() {
  var a = true;
  try {
    _a2(".", "d");
  } catch {
    a = false;
  }
  var u = {}, o = "", l = a ? "dgimsy" : "gimsy", v = function(T, x) {
    Object.defineProperty(u, T, { get: function() {
      return o += x, true;
    } });
  }, b = { dotAll: "s", global: "g", ignoreCase: "i", multiline: "m", sticky: "y" };
  a && (b.hasIndices = "d");
  for (var y in b) v(y, b[y]);
  var I = Object.getOwnPropertyDescriptor(Sa2, "flags").get.call(u);
  return I !== l || o !== l;
});
Ch && xh(Sa2, "flags", { configurable: true, get: yh });
var pr2 = Object.defineProperty;
var Eh = Object.getOwnPropertyDescriptor;
var fr2 = Object.getOwnPropertyNames;
var bh = Object.prototype.hasOwnProperty;
var wa2 = (a, u) => function() {
  return a && (u = (0, a[fr2(a)[0]])(a = 0)), u;
};
var Q = (a, u) => function() {
  return u || (0, a[fr2(a)[0]])((u = { exports: {} }).exports, u), u.exports;
};
var _h = (a, u) => {
  for (var o in u) pr2(a, o, { get: u[o], enumerable: true });
};
var Sh = (a, u, o, l) => {
  if (u && typeof u == "object" || typeof u == "function") for (let v of fr2(u)) !bh.call(a, v) && v !== o && pr2(a, v, { get: () => u[v], enumerable: !(l = Eh(u, v)) || l.enumerable });
  return a;
};
var wh = (a) => Sh(pr2({}, "__esModule", { value: true }), a);
var J = wa2({ "<define:process>"() {
} });
var dr2 = Q({ "src/common/parser-create-error.js"(a, u) {
  "use strict";
  J();
  function o(l, v) {
    let b = new SyntaxError(l + " (" + v.start.line + ":" + v.start.column + ")");
    return b.loc = v, b;
  }
  u.exports = o;
} });
var ka2 = Q({ "src/utils/try-combinations.js"(a, u) {
  "use strict";
  J();
  function o() {
    let l;
    for (var v = arguments.length, b = new Array(v), y = 0; y < v; y++) b[y] = arguments[y];
    for (let [I, T] of b.entries()) try {
      return { result: T() };
    } catch (x) {
      I === 0 && (l = x);
    }
    return { error: l };
  }
  u.exports = o;
} });
var Fa2 = {};
_h(Fa2, { EOL: () => cr, arch: () => kh, cpus: () => Oa2, default: () => qa2, endianness: () => Ba2, freemem: () => Da, getNetworkInterfaces: () => ja2, hostname: () => Ia2, loadavg: () => Ta2, networkInterfaces: () => Ra2, platform: () => Fh, release: () => Va2, tmpDir: () => hr, tmpdir: () => lr2, totalmem: () => Na2, type: () => La2, uptime: () => Pa2 });
function Ba2() {
  if (typeof pt2 > "u") {
    var a = new ArrayBuffer(2), u = new Uint8Array(a), o = new Uint16Array(a);
    if (u[0] = 1, u[1] = 2, o[0] === 258) pt2 = "BE";
    else if (o[0] === 513) pt2 = "LE";
    else throw new Error("unable to figure out endianess");
  }
  return pt2;
}
function Ia2() {
  return typeof globalThis.location < "u" ? globalThis.location.hostname : "";
}
function Ta2() {
  return [];
}
function Pa2() {
  return 0;
}
function Da() {
  return Number.MAX_VALUE;
}
function Na2() {
  return Number.MAX_VALUE;
}
function Oa2() {
  return [];
}
function La2() {
  return "Browser";
}
function Va2() {
  return typeof globalThis.navigator < "u" ? globalThis.navigator.appVersion : "";
}
function Ra2() {
}
function ja2() {
}
function kh() {
  return "javascript";
}
function Fh() {
  return "browser";
}
function hr() {
  return "/tmp";
}
var pt2;
var lr2;
var cr;
var qa2;
var Bh = wa2({ "node-modules-polyfills:os"() {
  J(), lr2 = hr, cr = `
`, qa2 = { EOL: cr, tmpdir: lr2, tmpDir: hr, networkInterfaces: Ra2, getNetworkInterfaces: ja2, release: Va2, type: La2, cpus: Oa2, totalmem: Na2, freemem: Da, uptime: Pa2, loadavg: Ta2, hostname: Ia2, endianness: Ba2 };
} });
var Ih = Q({ "node-modules-polyfills-commonjs:os"(a, u) {
  J();
  var o = (Bh(), wh(Fa2));
  if (o && o.default) {
    u.exports = o.default;
    for (let l in o) u.exports[l] = o[l];
  } else o && (u.exports = o);
} });
var Th = Q({ "node_modules/detect-newline/index.js"(a, u) {
  "use strict";
  J();
  var o = (l) => {
    if (typeof l != "string") throw new TypeError("Expected a string");
    let v = l.match(/(?:\r?\n)/g) || [];
    if (v.length === 0) return;
    let b = v.filter((I) => I === `\r
`).length, y = v.length - b;
    return b > y ? `\r
` : `
`;
  };
  u.exports = o, u.exports.graceful = (l) => typeof l == "string" && o(l) || `
`;
} });
var Ph = Q({ "node_modules/jest-docblock/build/index.js"(a) {
  "use strict";
  J(), Object.defineProperty(a, "__esModule", { value: true }), a.extract = g, a.parse = G, a.parseWithComments = f, a.print = B, a.strip = w;
  function u() {
    let k = Ih();
    return u = function() {
      return k;
    }, k;
  }
  function o() {
    let k = l(Th());
    return o = function() {
      return k;
    }, k;
  }
  function l(k) {
    return k && k.__esModule ? k : { default: k };
  }
  var v = /\*\/$/, b = /^\/\*\*?/, y = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, I = /(^|\s+)\/\/([^\r\n]*)/g, T = /^(\r?\n)+/, x = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g, R = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g, U = /(\r?\n|^) *\* ?/g, D = [];
  function g(k) {
    let X = k.match(y);
    return X ? X[0].trimLeft() : "";
  }
  function w(k) {
    let X = k.match(y);
    return X && X[0] ? k.substring(X[0].length) : k;
  }
  function G(k) {
    return f(k).pragmas;
  }
  function f(k) {
    let X = (0, o().default)(k) || u().EOL;
    k = k.replace(b, "").replace(v, "").replace(U, "$1");
    let O = "";
    for (; O !== k; ) O = k, k = k.replace(x, `${X}$1 $2${X}`);
    k = k.replace(T, "").trimRight();
    let i = /* @__PURE__ */ Object.create(null), S = k.replace(R, "").replace(T, "").trimRight(), F;
    for (; F = R.exec(k); ) {
      let j = F[2].replace(I, "");
      typeof i[F[1]] == "string" || Array.isArray(i[F[1]]) ? i[F[1]] = D.concat(i[F[1]], j) : i[F[1]] = j;
    }
    return { comments: S, pragmas: i };
  }
  function B(k) {
    let { comments: X = "", pragmas: O = {} } = k, i = (0, o().default)(X) || u().EOL, S = "/**", F = " *", j = " */", Z = Object.keys(O), ne2 = Z.map((ie) => V(ie, O[ie])).reduce((ie, Ne) => ie.concat(Ne), []).map((ie) => `${F} ${ie}${i}`).join("");
    if (!X) {
      if (Z.length === 0) return "";
      if (Z.length === 1 && !Array.isArray(O[Z[0]])) {
        let ie = O[Z[0]];
        return `${S} ${V(Z[0], ie)[0]}${j}`;
      }
    }
    let ee = X.split(i).map((ie) => `${F} ${ie}`).join(i) + i;
    return S + i + (X ? ee : "") + (X && Z.length ? F + i : "") + ne2 + j;
  }
  function V(k, X) {
    return D.concat(X).map((O) => `@${k} ${O}`.trim());
  }
} });
var Dh = Q({ "src/common/end-of-line.js"(a, u) {
  "use strict";
  J();
  function o(y) {
    let I = y.indexOf("\r");
    return I >= 0 ? y.charAt(I + 1) === `
` ? "crlf" : "cr" : "lf";
  }
  function l(y) {
    switch (y) {
      case "cr":
        return "\r";
      case "crlf":
        return `\r
`;
      default:
        return `
`;
    }
  }
  function v(y, I) {
    let T;
    switch (I) {
      case `
`:
        T = /\n/g;
        break;
      case "\r":
        T = /\r/g;
        break;
      case `\r
`:
        T = /\r\n/g;
        break;
      default:
        throw new Error(`Unexpected "eol" ${JSON.stringify(I)}.`);
    }
    let x = y.match(T);
    return x ? x.length : 0;
  }
  function b(y) {
    return y.replace(/\r\n?/g, `
`);
  }
  u.exports = { guessEndOfLine: o, convertEndOfLineToChars: l, countEndOfLineChars: v, normalizeEndOfLine: b };
} });
var Nh = Q({ "src/language-js/utils/get-shebang.js"(a, u) {
  "use strict";
  J();
  function o(l) {
    if (!l.startsWith("#!")) return "";
    let v = l.indexOf(`
`);
    return v === -1 ? l : l.slice(0, v);
  }
  u.exports = o;
} });
var Oh = Q({ "src/language-js/pragma.js"(a, u) {
  "use strict";
  J();
  var { parseWithComments: o, strip: l, extract: v, print: b } = Ph(), { normalizeEndOfLine: y } = Dh(), I = Nh();
  function T(U) {
    let D = I(U);
    D && (U = U.slice(D.length + 1));
    let g = v(U), { pragmas: w, comments: G } = o(g);
    return { shebang: D, text: U, pragmas: w, comments: G };
  }
  function x(U) {
    let D = Object.keys(T(U).pragmas);
    return D.includes("prettier") || D.includes("format");
  }
  function R(U) {
    let { shebang: D, text: g, pragmas: w, comments: G } = T(U), f = l(g), B = b({ pragmas: Object.assign({ format: "" }, w), comments: G.trimStart() });
    return (D ? `${D}
` : "") + y(B) + (f.startsWith(`
`) ? `
` : `

`) + f;
  }
  u.exports = { hasPragma: x, insertPragma: R };
} });
var Lh = Q({ "src/utils/is-non-empty-array.js"(a, u) {
  "use strict";
  J();
  function o(l) {
    return Array.isArray(l) && l.length > 0;
  }
  u.exports = o;
} });
var Ma2 = Q({ "src/language-js/loc.js"(a, u) {
  "use strict";
  J();
  var o = Lh();
  function l(T) {
    var x, R;
    let U = T.range ? T.range[0] : T.start, D = (x = (R = T.declaration) === null || R === void 0 ? void 0 : R.decorators) !== null && x !== void 0 ? x : T.decorators;
    return o(D) ? Math.min(l(D[0]), U) : U;
  }
  function v(T) {
    return T.range ? T.range[1] : T.end;
  }
  function b(T, x) {
    let R = l(T);
    return Number.isInteger(R) && R === l(x);
  }
  function y(T, x) {
    let R = v(T);
    return Number.isInteger(R) && R === v(x);
  }
  function I(T, x) {
    return b(T, x) && y(T, x);
  }
  u.exports = { locStart: l, locEnd: v, hasSameLocStart: b, hasSameLoc: I };
} });
var Ua2 = Q({ "src/language-js/parse/utils/create-parser.js"(a, u) {
  "use strict";
  J();
  var { hasPragma: o } = Oh(), { locStart: l, locEnd: v } = Ma2();
  function b(y) {
    return y = typeof y == "function" ? { parse: y } : y, Object.assign({ astFormat: "estree", hasPragma: o, locStart: l, locEnd: v }, y);
  }
  u.exports = b;
} });
var Vh = Q({ "src/language-js/utils/is-ts-keyword-type.js"(a, u) {
  "use strict";
  J();
  function o(l) {
    let { type: v } = l;
    return v.startsWith("TS") && v.endsWith("Keyword");
  }
  u.exports = o;
} });
var Rh = Q({ "src/language-js/utils/is-block-comment.js"(a, u) {
  "use strict";
  J();
  var o = /* @__PURE__ */ new Set(["Block", "CommentBlock", "MultiLine"]), l = (v) => o.has(v == null ? void 0 : v.type);
  u.exports = l;
} });
var jh = Q({ "src/language-js/utils/is-type-cast-comment.js"(a, u) {
  "use strict";
  J();
  var o = Rh();
  function l(v) {
    return o(v) && v.value[0] === "*" && /@(?:type|satisfies)\b/.test(v.value);
  }
  u.exports = l;
} });
var qh = Q({ "src/utils/get-last.js"(a, u) {
  "use strict";
  J();
  var o = (l) => l[l.length - 1];
  u.exports = o;
} });
var Mh = Q({ "src/language-js/parse/postprocess/visit-node.js"(a, u) {
  "use strict";
  J();
  function o(l, v) {
    if (Array.isArray(l)) {
      for (let b = 0; b < l.length; b++) l[b] = o(l[b], v);
      return l;
    }
    if (l && typeof l == "object" && typeof l.type == "string") {
      let b = Object.keys(l);
      for (let y = 0; y < b.length; y++) l[b[y]] = o(l[b[y]], v);
      return v(l) || l;
    }
    return l;
  }
  u.exports = o;
} });
var Uh = Q({ "src/language-js/parse/postprocess/throw-syntax-error.js"(a, u) {
  "use strict";
  J();
  var o = dr2();
  function l(v, b) {
    let { start: y, end: I } = v.loc;
    throw o(b, { start: { line: y.line, column: y.column + 1 }, end: { line: I.line, column: I.column + 1 } });
  }
  u.exports = l;
} });
var Wa2 = Q({ "src/language-js/parse/postprocess/index.js"(a, u) {
  "use strict";
  J();
  var { locStart: o, locEnd: l } = Ma2(), v = Vh(), b = jh(), y = qh(), I = Mh(), T = Uh();
  function x(g, w) {
    if (w.parser !== "typescript" && w.parser !== "flow" && w.parser !== "acorn" && w.parser !== "espree" && w.parser !== "meriyah") {
      let f = /* @__PURE__ */ new Set();
      g = I(g, (B) => {
        B.leadingComments && B.leadingComments.some(b) && f.add(o(B));
      }), g = I(g, (B) => {
        if (B.type === "ParenthesizedExpression") {
          let { expression: V } = B;
          if (V.type === "TypeCastExpression") return V.range = B.range, V;
          let k = o(B);
          if (!f.has(k)) return V.extra = Object.assign(Object.assign({}, V.extra), {}, { parenthesized: true }), V;
        }
      });
    }
    return g = I(g, (f) => {
      switch (f.type) {
        case "ChainExpression":
          return R(f.expression);
        case "LogicalExpression": {
          if (U(f)) return D(f);
          break;
        }
        case "VariableDeclaration": {
          let B = y(f.declarations);
          B && B.init && G(f, B);
          break;
        }
        case "TSParenthesizedType":
          return v(f.typeAnnotation) || f.typeAnnotation.type === "TSThisType" || (f.typeAnnotation.range = [o(f), l(f)]), f.typeAnnotation;
        case "TSTypeParameter":
          if (typeof f.name == "string") {
            let B = o(f);
            f.name = { type: "Identifier", name: f.name, range: [B, B + f.name.length] };
          }
          break;
        case "ObjectExpression":
          if (w.parser === "typescript") {
            let B = f.properties.find((V) => V.type === "Property" && V.value.type === "TSEmptyBodyFunctionExpression");
            B && T(B.value, "Unexpected token.");
          }
          break;
        case "SequenceExpression": {
          let B = y(f.expressions);
          f.range = [o(f), Math.min(l(B), l(f))];
          break;
        }
        case "TopicReference":
          w.__isUsingHackPipeline = true;
          break;
        case "ExportAllDeclaration": {
          let { exported: B } = f;
          if (w.parser === "meriyah" && B && B.type === "Identifier") {
            let V = w.originalText.slice(o(B), l(B));
            (V.startsWith('"') || V.startsWith("'")) && (f.exported = Object.assign(Object.assign({}, f.exported), {}, { type: "Literal", value: f.exported.name, raw: V }));
          }
          break;
        }
        case "PropertyDefinition":
          if (w.parser === "meriyah" && f.static && !f.computed && !f.key) {
            let B = "static", V = o(f);
            Object.assign(f, { static: false, key: { type: "Identifier", name: B, range: [V, V + B.length] } });
          }
          break;
      }
    }), g;
    function G(f, B) {
      w.originalText[l(B)] !== ";" && (f.range = [o(f), l(B)]);
    }
  }
  function R(g) {
    switch (g.type) {
      case "CallExpression":
        g.type = "OptionalCallExpression", g.callee = R(g.callee);
        break;
      case "MemberExpression":
        g.type = "OptionalMemberExpression", g.object = R(g.object);
        break;
      case "TSNonNullExpression":
        g.expression = R(g.expression);
        break;
    }
    return g;
  }
  function U(g) {
    return g.type === "LogicalExpression" && g.right.type === "LogicalExpression" && g.operator === g.right.operator;
  }
  function D(g) {
    return U(g) ? D({ type: "LogicalExpression", operator: g.operator, left: D({ type: "LogicalExpression", operator: g.operator, left: g.left, right: g.right.left, range: [o(g.left), l(g.right.left)] }), right: g.right.right, range: [o(g), l(g)] }) : g;
  }
  u.exports = x;
} });
var ft2 = Q({ "node_modules/acorn/dist/acorn.js"(a, u) {
  J(), function(o, l) {
    typeof a == "object" && typeof u < "u" ? l(a) : typeof define == "function" && define.amd ? define(["exports"], l) : (o = typeof globalThis < "u" ? globalThis : o || self, l(o.acorn = {}));
  }(a, function(o) {
    "use strict";
    var l = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 357, 0, 62, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], v = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1070, 4050, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 46, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 482, 44, 11, 6, 17, 0, 322, 29, 19, 43, 1269, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4152, 8, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], b = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", y = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", I = { 3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile", 5: "class enum extends super const export import", 6: "enum", strict: "implements interface let package private protected public static yield", strictBind: "eval arguments" }, T = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", x = { 5: T, "5module": T + " export import", 6: T + " const class extends export import super" }, R = /^in(stanceof)?$/, U = new RegExp("[" + y + "]"), D = new RegExp("[" + y + b + "]");
    function g(e, t) {
      for (var r = 65536, s = 0; s < t.length; s += 2) {
        if (r += t[s], r > e) return false;
        if (r += t[s + 1], r >= e) return true;
      }
    }
    function w(e, t) {
      return e < 65 ? e === 36 : e < 91 ? true : e < 97 ? e === 95 : e < 123 ? true : e <= 65535 ? e >= 170 && U.test(String.fromCharCode(e)) : t === false ? false : g(e, v);
    }
    function G(e, t) {
      return e < 48 ? e === 36 : e < 58 ? true : e < 65 ? false : e < 91 ? true : e < 97 ? e === 95 : e < 123 ? true : e <= 65535 ? e >= 170 && D.test(String.fromCharCode(e)) : t === false ? false : g(e, v) || g(e, l);
    }
    var f = function(t, r) {
      r === void 0 && (r = {}), this.label = t, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop || null, this.updateContext = null;
    };
    function B(e, t) {
      return new f(e, { beforeExpr: true, binop: t });
    }
    var V = { beforeExpr: true }, k = { startsExpr: true }, X = {};
    function O(e, t) {
      return t === void 0 && (t = {}), t.keyword = e, X[e] = new f(e, t);
    }
    var i = { num: new f("num", k), regexp: new f("regexp", k), string: new f("string", k), name: new f("name", k), privateId: new f("privateId", k), eof: new f("eof"), bracketL: new f("[", { beforeExpr: true, startsExpr: true }), bracketR: new f("]"), braceL: new f("{", { beforeExpr: true, startsExpr: true }), braceR: new f("}"), parenL: new f("(", { beforeExpr: true, startsExpr: true }), parenR: new f(")"), comma: new f(",", V), semi: new f(";", V), colon: new f(":", V), dot: new f("."), question: new f("?", V), questionDot: new f("?."), arrow: new f("=>", V), template: new f("template"), invalidTemplate: new f("invalidTemplate"), ellipsis: new f("...", V), backQuote: new f("`", k), dollarBraceL: new f("${", { beforeExpr: true, startsExpr: true }), eq: new f("=", { beforeExpr: true, isAssign: true }), assign: new f("_=", { beforeExpr: true, isAssign: true }), incDec: new f("++/--", { prefix: true, postfix: true, startsExpr: true }), prefix: new f("!/~", { beforeExpr: true, prefix: true, startsExpr: true }), logicalOR: B("||", 1), logicalAND: B("&&", 2), bitwiseOR: B("|", 3), bitwiseXOR: B("^", 4), bitwiseAND: B("&", 5), equality: B("==/!=/===/!==", 6), relational: B("</>/<=/>=", 7), bitShift: B("<</>>/>>>", 8), plusMin: new f("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }), modulo: B("%", 10), star: B("*", 10), slash: B("/", 10), starstar: new f("**", { beforeExpr: true }), coalesce: B("??", 1), _break: O("break"), _case: O("case", V), _catch: O("catch"), _continue: O("continue"), _debugger: O("debugger"), _default: O("default", V), _do: O("do", { isLoop: true, beforeExpr: true }), _else: O("else", V), _finally: O("finally"), _for: O("for", { isLoop: true }), _function: O("function", k), _if: O("if"), _return: O("return", V), _switch: O("switch"), _throw: O("throw", V), _try: O("try"), _var: O("var"), _const: O("const"), _while: O("while", { isLoop: true }), _with: O("with"), _new: O("new", { beforeExpr: true, startsExpr: true }), _this: O("this", k), _super: O("super", k), _class: O("class", k), _extends: O("extends", V), _export: O("export"), _import: O("import", k), _null: O("null", k), _true: O("true", k), _false: O("false", k), _in: O("in", { beforeExpr: true, binop: 7 }), _instanceof: O("instanceof", { beforeExpr: true, binop: 7 }), _typeof: O("typeof", { beforeExpr: true, prefix: true, startsExpr: true }), _void: O("void", { beforeExpr: true, prefix: true, startsExpr: true }), _delete: O("delete", { beforeExpr: true, prefix: true, startsExpr: true }) }, S = /\r\n?|\n|\u2028|\u2029/, F = new RegExp(S.source, "g");
    function j(e) {
      return e === 10 || e === 13 || e === 8232 || e === 8233;
    }
    function Z(e, t, r) {
      r === void 0 && (r = e.length);
      for (var s = t; s < r; s++) {
        var n = e.charCodeAt(s);
        if (j(n)) return s < r - 1 && n === 13 && e.charCodeAt(s + 1) === 10 ? s + 2 : s + 1;
      }
      return -1;
    }
    var ne2 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, ee = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ie = Object.prototype, Ne = ie.hasOwnProperty, p = ie.toString, P = Object.hasOwn || function(e, t) {
      return Ne.call(e, t);
    }, _ = Array.isArray || function(e) {
      return p.call(e) === "[object Array]";
    };
    function d(e) {
      return new RegExp("^(?:" + e.replace(/ /g, "|") + ")$");
    }
    function C(e) {
      return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
    }
    var K = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, H = function(t, r) {
      this.line = t, this.column = r;
    };
    H.prototype.offset = function(t) {
      return new H(this.line, this.column + t);
    };
    var te2 = function(t, r, s) {
      this.start = r, this.end = s, t.sourceFile !== null && (this.source = t.sourceFile);
    };
    function ae(e, t) {
      for (var r = 1, s = 0; ; ) {
        var n = Z(e, s, t);
        if (n < 0) return new H(r, t - s);
        ++r, s = n;
      }
    }
    var fe = { ecmaVersion: null, sourceType: "script", onInsertedSemicolon: null, onTrailingComma: null, allowReserved: null, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowAwaitOutsideFunction: null, allowSuperOutsideMethod: null, allowHashBang: false, locations: false, onToken: null, onComment: null, ranges: false, program: null, sourceFile: null, directSourceFile: null, preserveParens: false }, Ae = false;
    function dt(e) {
      var t = {};
      for (var r in fe) t[r] = e && P(e, r) ? e[r] : fe[r];
      if (t.ecmaVersion === "latest" ? t.ecmaVersion = 1e8 : t.ecmaVersion == null ? (!Ae && typeof console == "object" && console.warn && (Ae = true, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), t.ecmaVersion = 11) : t.ecmaVersion >= 2015 && (t.ecmaVersion -= 2009), t.allowReserved == null && (t.allowReserved = t.ecmaVersion < 5), e.allowHashBang == null && (t.allowHashBang = t.ecmaVersion >= 14), _(t.onToken)) {
        var s = t.onToken;
        t.onToken = function(n) {
          return s.push(n);
        };
      }
      return _(t.onComment) && (t.onComment = mt2(t, t.onComment)), t;
    }
    function mt2(e, t) {
      return function(r, s, n, h, c, m) {
        var A = { type: r ? "Block" : "Line", value: s, start: n, end: h };
        e.locations && (A.loc = new te2(this, c, m)), e.ranges && (A.range = [n, h]), t.push(A);
      };
    }
    var _e = 1, Ce = 2, Oe = 4, ze = 8, mr2 = 16, vr = 32, vt2 = 64, gr2 = 128, Le = 256, gt = _e | Ce | Le;
    function xt(e, t) {
      return Ce | (e ? Oe : 0) | (t ? ze : 0);
    }
    var Ge = 0, yt2 = 1, ve = 2, xr2 = 3, yr = 4, Ar = 5, Y = function(t, r, s) {
      this.options = t = dt(t), this.sourceFile = t.sourceFile, this.keywords = d(x[t.ecmaVersion >= 6 ? 6 : t.sourceType === "module" ? "5module" : 5]);
      var n = "";
      t.allowReserved !== true && (n = I[t.ecmaVersion >= 6 ? 6 : t.ecmaVersion === 5 ? 5 : 3], t.sourceType === "module" && (n += " await")), this.reservedWords = d(n);
      var h = (n ? n + " " : "") + I.strict;
      this.reservedWordsStrict = d(h), this.reservedWordsStrictBind = d(h + " " + I.strictBind), this.input = String(r), this.containsEsc = false, s ? (this.pos = s, this.lineStart = this.input.lastIndexOf(`
`, s - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(S).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = i.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = true, this.inModule = t.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = false, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && t.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(_e), this.regexpState = null, this.privateNameStack = [];
    }, de = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
    Y.prototype.parse = function() {
      var t = this.options.program || this.startNode();
      return this.nextToken(), this.parseTopLevel(t);
    }, de.inFunction.get = function() {
      return (this.currentVarScope().flags & Ce) > 0;
    }, de.inGenerator.get = function() {
      return (this.currentVarScope().flags & ze) > 0 && !this.currentVarScope().inClassFieldInit;
    }, de.inAsync.get = function() {
      return (this.currentVarScope().flags & Oe) > 0 && !this.currentVarScope().inClassFieldInit;
    }, de.canAwait.get = function() {
      for (var e = this.scopeStack.length - 1; e >= 0; e--) {
        var t = this.scopeStack[e];
        if (t.inClassFieldInit || t.flags & Le) return false;
        if (t.flags & Ce) return (t.flags & Oe) > 0;
      }
      return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
    }, de.allowSuper.get = function() {
      var e = this.currentThisScope(), t = e.flags, r = e.inClassFieldInit;
      return (t & vt2) > 0 || r || this.options.allowSuperOutsideMethod;
    }, de.allowDirectSuper.get = function() {
      return (this.currentThisScope().flags & gr2) > 0;
    }, de.treatFunctionsAsVar.get = function() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }, de.allowNewDotTarget.get = function() {
      var e = this.currentThisScope(), t = e.flags, r = e.inClassFieldInit;
      return (t & (Ce | Le)) > 0 || r;
    }, de.inClassStaticBlock.get = function() {
      return (this.currentVarScope().flags & Le) > 0;
    }, Y.extend = function() {
      for (var t = [], r = arguments.length; r--; ) t[r] = arguments[r];
      for (var s = this, n = 0; n < t.length; n++) s = t[n](s);
      return s;
    }, Y.parse = function(t, r) {
      return new this(r, t).parse();
    }, Y.parseExpressionAt = function(t, r, s) {
      var n = new this(s, t, r);
      return n.nextToken(), n.parseExpression();
    }, Y.tokenizer = function(t, r) {
      return new this(r, t);
    }, Object.defineProperties(Y.prototype, de);
    var se = Y.prototype, Ga2 = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
    se.strictDirective = function(e) {
      if (this.options.ecmaVersion < 5) return false;
      for (; ; ) {
        ee.lastIndex = e, e += ee.exec(this.input)[0].length;
        var t = Ga2.exec(this.input.slice(e));
        if (!t) return false;
        if ((t[1] || t[2]) === "use strict") {
          ee.lastIndex = e + t[0].length;
          var r = ee.exec(this.input), s = r.index + r[0].length, n = this.input.charAt(s);
          return n === ";" || n === "}" || S.test(r[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(n) || n === "!" && this.input.charAt(s + 1) === "=");
        }
        e += t[0].length, ee.lastIndex = e, e += ee.exec(this.input)[0].length, this.input[e] === ";" && e++;
      }
    }, se.eat = function(e) {
      return this.type === e ? (this.next(), true) : false;
    }, se.isContextual = function(e) {
      return this.type === i.name && this.value === e && !this.containsEsc;
    }, se.eatContextual = function(e) {
      return this.isContextual(e) ? (this.next(), true) : false;
    }, se.expectContextual = function(e) {
      this.eatContextual(e) || this.unexpected();
    }, se.canInsertSemicolon = function() {
      return this.type === i.eof || this.type === i.braceR || S.test(this.input.slice(this.lastTokEnd, this.start));
    }, se.insertSemicolon = function() {
      if (this.canInsertSemicolon()) return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), true;
    }, se.semicolon = function() {
      !this.eat(i.semi) && !this.insertSemicolon() && this.unexpected();
    }, se.afterTrailingComma = function(e, t) {
      if (this.type === e) return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), t || this.next(), true;
    }, se.expect = function(e) {
      this.eat(e) || this.unexpected();
    }, se.unexpected = function(e) {
      this.raise(e != null ? e : this.start, "Unexpected token");
    };
    var He = function() {
      this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
    };
    se.checkPatternErrors = function(e, t) {
      if (e) {
        e.trailingComma > -1 && this.raiseRecoverable(e.trailingComma, "Comma is not permitted after the rest element");
        var r = t ? e.parenthesizedAssign : e.parenthesizedBind;
        r > -1 && this.raiseRecoverable(r, t ? "Assigning to rvalue" : "Parenthesized pattern");
      }
    }, se.checkExpressionErrors = function(e, t) {
      if (!e) return false;
      var r = e.shorthandAssign, s = e.doubleProto;
      if (!t) return r >= 0 || s >= 0;
      r >= 0 && this.raise(r, "Shorthand property assignments are valid only in destructuring patterns"), s >= 0 && this.raiseRecoverable(s, "Redefinition of __proto__ property");
    }, se.checkYieldAwaitInDefaultParams = function() {
      this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
    }, se.isSimpleAssignTarget = function(e) {
      return e.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(e.expression) : e.type === "Identifier" || e.type === "MemberExpression";
    };
    var L = Y.prototype;
    L.parseTopLevel = function(e) {
      var t = /* @__PURE__ */ Object.create(null);
      for (e.body || (e.body = []); this.type !== i.eof; ) {
        var r = this.parseStatement(null, true, t);
        e.body.push(r);
      }
      if (this.inModule) for (var s = 0, n = Object.keys(this.undefinedExports); s < n.length; s += 1) {
        var h = n[s];
        this.raiseRecoverable(this.undefinedExports[h].start, "Export '" + h + "' is not defined");
      }
      return this.adaptDirectivePrologue(e.body), this.next(), e.sourceType = this.options.sourceType, this.finishNode(e, "Program");
    };
    var At2 = { kind: "loop" }, Ha2 = { kind: "switch" };
    L.isLet = function(e) {
      if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return false;
      ee.lastIndex = this.pos;
      var t = ee.exec(this.input), r = this.pos + t[0].length, s = this.input.charCodeAt(r);
      if (s === 91 || s === 92 || s > 55295 && s < 56320) return true;
      if (e) return false;
      if (s === 123) return true;
      if (w(s, true)) {
        for (var n = r + 1; G(s = this.input.charCodeAt(n), true); ) ++n;
        if (s === 92 || s > 55295 && s < 56320) return true;
        var h = this.input.slice(r, n);
        if (!R.test(h)) return true;
      }
      return false;
    }, L.isAsyncFunction = function() {
      if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return false;
      ee.lastIndex = this.pos;
      var e = ee.exec(this.input), t = this.pos + e[0].length, r;
      return !S.test(this.input.slice(this.pos, t)) && this.input.slice(t, t + 8) === "function" && (t + 8 === this.input.length || !(G(r = this.input.charCodeAt(t + 8)) || r > 55295 && r < 56320));
    }, L.parseStatement = function(e, t, r) {
      var s = this.type, n = this.startNode(), h;
      switch (this.isLet(e) && (s = i._var, h = "let"), s) {
        case i._break:
        case i._continue:
          return this.parseBreakContinueStatement(n, s.keyword);
        case i._debugger:
          return this.parseDebuggerStatement(n);
        case i._do:
          return this.parseDoStatement(n);
        case i._for:
          return this.parseForStatement(n);
        case i._function:
          return e && (this.strict || e !== "if" && e !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(n, false, !e);
        case i._class:
          return e && this.unexpected(), this.parseClass(n, true);
        case i._if:
          return this.parseIfStatement(n);
        case i._return:
          return this.parseReturnStatement(n);
        case i._switch:
          return this.parseSwitchStatement(n);
        case i._throw:
          return this.parseThrowStatement(n);
        case i._try:
          return this.parseTryStatement(n);
        case i._const:
        case i._var:
          return h = h || this.value, e && h !== "var" && this.unexpected(), this.parseVarStatement(n, h);
        case i._while:
          return this.parseWhileStatement(n);
        case i._with:
          return this.parseWithStatement(n);
        case i.braceL:
          return this.parseBlock(true, n);
        case i.semi:
          return this.parseEmptyStatement(n);
        case i._export:
        case i._import:
          if (this.options.ecmaVersion > 10 && s === i._import) {
            ee.lastIndex = this.pos;
            var c = ee.exec(this.input), m = this.pos + c[0].length, A = this.input.charCodeAt(m);
            if (A === 40 || A === 46) return this.parseExpressionStatement(n, this.parseExpression());
          }
          return this.options.allowImportExportEverywhere || (t || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), s === i._import ? this.parseImport(n) : this.parseExport(n, r);
        default:
          if (this.isAsyncFunction()) return e && this.unexpected(), this.next(), this.parseFunctionStatement(n, true, !e);
          var q = this.value, W = this.parseExpression();
          return s === i.name && W.type === "Identifier" && this.eat(i.colon) ? this.parseLabeledStatement(n, q, W, e) : this.parseExpressionStatement(n, W);
      }
    }, L.parseBreakContinueStatement = function(e, t) {
      var r = t === "break";
      this.next(), this.eat(i.semi) || this.insertSemicolon() ? e.label = null : this.type !== i.name ? this.unexpected() : (e.label = this.parseIdent(), this.semicolon());
      for (var s = 0; s < this.labels.length; ++s) {
        var n = this.labels[s];
        if ((e.label == null || n.name === e.label.name) && (n.kind != null && (r || n.kind === "loop") || e.label && r)) break;
      }
      return s === this.labels.length && this.raise(e.start, "Unsyntactic " + t), this.finishNode(e, r ? "BreakStatement" : "ContinueStatement");
    }, L.parseDebuggerStatement = function(e) {
      return this.next(), this.semicolon(), this.finishNode(e, "DebuggerStatement");
    }, L.parseDoStatement = function(e) {
      return this.next(), this.labels.push(At2), e.body = this.parseStatement("do"), this.labels.pop(), this.expect(i._while), e.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(i.semi) : this.semicolon(), this.finishNode(e, "DoWhileStatement");
    }, L.parseForStatement = function(e) {
      this.next();
      var t = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
      if (this.labels.push(At2), this.enterScope(0), this.expect(i.parenL), this.type === i.semi) return t > -1 && this.unexpected(t), this.parseFor(e, null);
      var r = this.isLet();
      if (this.type === i._var || this.type === i._const || r) {
        var s = this.startNode(), n = r ? "let" : this.value;
        return this.next(), this.parseVar(s, true, n), this.finishNode(s, "VariableDeclaration"), (this.type === i._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && s.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === i._in ? t > -1 && this.unexpected(t) : e.await = t > -1), this.parseForIn(e, s)) : (t > -1 && this.unexpected(t), this.parseFor(e, s));
      }
      var h = this.isContextual("let"), c = false, m = new He(), A = this.parseExpression(t > -1 ? "await" : true, m);
      return this.type === i._in || (c = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === i._in ? t > -1 && this.unexpected(t) : e.await = t > -1), h && c && this.raise(A.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(A, false, m), this.checkLValPattern(A), this.parseForIn(e, A)) : (this.checkExpressionErrors(m, true), t > -1 && this.unexpected(t), this.parseFor(e, A));
    }, L.parseFunctionStatement = function(e, t, r) {
      return this.next(), this.parseFunction(e, Ve | (r ? 0 : Ct2), false, t);
    }, L.parseIfStatement = function(e) {
      return this.next(), e.test = this.parseParenExpression(), e.consequent = this.parseStatement("if"), e.alternate = this.eat(i._else) ? this.parseStatement("if") : null, this.finishNode(e, "IfStatement");
    }, L.parseReturnStatement = function(e) {
      return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(i.semi) || this.insertSemicolon() ? e.argument = null : (e.argument = this.parseExpression(), this.semicolon()), this.finishNode(e, "ReturnStatement");
    }, L.parseSwitchStatement = function(e) {
      this.next(), e.discriminant = this.parseParenExpression(), e.cases = [], this.expect(i.braceL), this.labels.push(Ha2), this.enterScope(0);
      for (var t, r = false; this.type !== i.braceR; ) if (this.type === i._case || this.type === i._default) {
        var s = this.type === i._case;
        t && this.finishNode(t, "SwitchCase"), e.cases.push(t = this.startNode()), t.consequent = [], this.next(), s ? t.test = this.parseExpression() : (r && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r = true, t.test = null), this.expect(i.colon);
      } else t || this.unexpected(), t.consequent.push(this.parseStatement(null));
      return this.exitScope(), t && this.finishNode(t, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(e, "SwitchStatement");
    }, L.parseThrowStatement = function(e) {
      return this.next(), S.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), e.argument = this.parseExpression(), this.semicolon(), this.finishNode(e, "ThrowStatement");
    };
    var Ka2 = [];
    L.parseTryStatement = function(e) {
      if (this.next(), e.block = this.parseBlock(), e.handler = null, this.type === i._catch) {
        var t = this.startNode();
        if (this.next(), this.eat(i.parenL)) {
          t.param = this.parseBindingAtom();
          var r = t.param.type === "Identifier";
          this.enterScope(r ? vr : 0), this.checkLValPattern(t.param, r ? yr : ve), this.expect(i.parenR);
        } else this.options.ecmaVersion < 10 && this.unexpected(), t.param = null, this.enterScope(0);
        t.body = this.parseBlock(false), this.exitScope(), e.handler = this.finishNode(t, "CatchClause");
      }
      return e.finalizer = this.eat(i._finally) ? this.parseBlock() : null, !e.handler && !e.finalizer && this.raise(e.start, "Missing catch or finally clause"), this.finishNode(e, "TryStatement");
    }, L.parseVarStatement = function(e, t) {
      return this.next(), this.parseVar(e, false, t), this.semicolon(), this.finishNode(e, "VariableDeclaration");
    }, L.parseWhileStatement = function(e) {
      return this.next(), e.test = this.parseParenExpression(), this.labels.push(At2), e.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(e, "WhileStatement");
    }, L.parseWithStatement = function(e) {
      return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), e.object = this.parseParenExpression(), e.body = this.parseStatement("with"), this.finishNode(e, "WithStatement");
    }, L.parseEmptyStatement = function(e) {
      return this.next(), this.finishNode(e, "EmptyStatement");
    }, L.parseLabeledStatement = function(e, t, r, s) {
      for (var n = 0, h = this.labels; n < h.length; n += 1) {
        var c = h[n];
        c.name === t && this.raise(r.start, "Label '" + t + "' is already declared");
      }
      for (var m = this.type.isLoop ? "loop" : this.type === i._switch ? "switch" : null, A = this.labels.length - 1; A >= 0; A--) {
        var q = this.labels[A];
        if (q.statementStart === e.start) q.statementStart = this.start, q.kind = m;
        else break;
      }
      return this.labels.push({ name: t, kind: m, statementStart: this.start }), e.body = this.parseStatement(s ? s.indexOf("label") === -1 ? s + "label" : s : "label"), this.labels.pop(), e.label = r, this.finishNode(e, "LabeledStatement");
    }, L.parseExpressionStatement = function(e, t) {
      return e.expression = t, this.semicolon(), this.finishNode(e, "ExpressionStatement");
    }, L.parseBlock = function(e, t, r) {
      for (e === void 0 && (e = true), t === void 0 && (t = this.startNode()), t.body = [], this.expect(i.braceL), e && this.enterScope(0); this.type !== i.braceR; ) {
        var s = this.parseStatement(null);
        t.body.push(s);
      }
      return r && (this.strict = false), this.next(), e && this.exitScope(), this.finishNode(t, "BlockStatement");
    }, L.parseFor = function(e, t) {
      return e.init = t, this.expect(i.semi), e.test = this.type === i.semi ? null : this.parseExpression(), this.expect(i.semi), e.update = this.type === i.parenR ? null : this.parseExpression(), this.expect(i.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, "ForStatement");
    }, L.parseForIn = function(e, t) {
      var r = this.type === i._in;
      return this.next(), t.type === "VariableDeclaration" && t.declarations[0].init != null && (!r || this.options.ecmaVersion < 8 || this.strict || t.kind !== "var" || t.declarations[0].id.type !== "Identifier") && this.raise(t.start, (r ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"), e.left = t, e.right = r ? this.parseExpression() : this.parseMaybeAssign(), this.expect(i.parenR), e.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(e, r ? "ForInStatement" : "ForOfStatement");
    }, L.parseVar = function(e, t, r) {
      for (e.declarations = [], e.kind = r; ; ) {
        var s = this.startNode();
        if (this.parseVarId(s, r), this.eat(i.eq) ? s.init = this.parseMaybeAssign(t) : r === "const" && !(this.type === i._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : s.id.type !== "Identifier" && !(t && (this.type === i._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : s.init = null, e.declarations.push(this.finishNode(s, "VariableDeclarator")), !this.eat(i.comma)) break;
      }
      return e;
    }, L.parseVarId = function(e, t) {
      e.id = this.parseBindingAtom(), this.checkLValPattern(e.id, t === "var" ? yt2 : ve, false);
    };
    var Ve = 1, Ct2 = 2, Cr = 4;
    L.parseFunction = function(e, t, r, s, n) {
      this.initFunction(e), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !s) && (this.type === i.star && t & Ct2 && this.unexpected(), e.generator = this.eat(i.star)), this.options.ecmaVersion >= 8 && (e.async = !!s), t & Ve && (e.id = t & Cr && this.type !== i.name ? null : this.parseIdent(), e.id && !(t & Ct2) && this.checkLValSimple(e.id, this.strict || e.generator || e.async ? this.treatFunctionsAsVar ? yt2 : ve : xr2));
      var h = this.yieldPos, c = this.awaitPos, m = this.awaitIdentPos;
      return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(xt(e.async, e.generator)), t & Ve || (e.id = this.type === i.name ? this.parseIdent() : null), this.parseFunctionParams(e), this.parseFunctionBody(e, r, false, n), this.yieldPos = h, this.awaitPos = c, this.awaitIdentPos = m, this.finishNode(e, t & Ve ? "FunctionDeclaration" : "FunctionExpression");
    }, L.parseFunctionParams = function(e) {
      this.expect(i.parenL), e.params = this.parseBindingList(i.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
    }, L.parseClass = function(e, t) {
      this.next();
      var r = this.strict;
      this.strict = true, this.parseClassId(e, t), this.parseClassSuper(e);
      var s = this.enterClassBody(), n = this.startNode(), h = false;
      for (n.body = [], this.expect(i.braceL); this.type !== i.braceR; ) {
        var c = this.parseClassElement(e.superClass !== null);
        c && (n.body.push(c), c.type === "MethodDefinition" && c.kind === "constructor" ? (h && this.raise(c.start, "Duplicate constructor in the same class"), h = true) : c.key && c.key.type === "PrivateIdentifier" && Xa2(s, c) && this.raiseRecoverable(c.key.start, "Identifier '#" + c.key.name + "' has already been declared"));
      }
      return this.strict = r, this.next(), e.body = this.finishNode(n, "ClassBody"), this.exitClassBody(), this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression");
    }, L.parseClassElement = function(e) {
      if (this.eat(i.semi)) return null;
      var t = this.options.ecmaVersion, r = this.startNode(), s = "", n = false, h = false, c = "method", m = false;
      if (this.eatContextual("static")) {
        if (t >= 13 && this.eat(i.braceL)) return this.parseClassStaticBlock(r), r;
        this.isClassElementNameStart() || this.type === i.star ? m = true : s = "static";
      }
      if (r.static = m, !s && t >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === i.star) && !this.canInsertSemicolon() ? h = true : s = "async"), !s && (t >= 9 || !h) && this.eat(i.star) && (n = true), !s && !h && !n) {
        var A = this.value;
        (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? c = A : s = A);
      }
      if (s ? (r.computed = false, r.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), r.key.name = s, this.finishNode(r.key, "Identifier")) : this.parseClassElementName(r), t < 13 || this.type === i.parenL || c !== "method" || n || h) {
        var q = !r.static && Ke2(r, "constructor"), W = q && e;
        q && c !== "method" && this.raise(r.key.start, "Constructor can't have get/set modifier"), r.kind = q ? "constructor" : c, this.parseClassMethod(r, n, h, W);
      } else this.parseClassField(r);
      return r;
    }, L.isClassElementNameStart = function() {
      return this.type === i.name || this.type === i.privateId || this.type === i.num || this.type === i.string || this.type === i.bracketL || this.type.keyword;
    }, L.parseClassElementName = function(e) {
      this.type === i.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), e.computed = false, e.key = this.parsePrivateIdent()) : this.parsePropertyName(e);
    }, L.parseClassMethod = function(e, t, r, s) {
      var n = e.key;
      e.kind === "constructor" ? (t && this.raise(n.start, "Constructor can't be a generator"), r && this.raise(n.start, "Constructor can't be an async method")) : e.static && Ke2(e, "prototype") && this.raise(n.start, "Classes may not have a static property named prototype");
      var h = e.value = this.parseMethod(t, r, s);
      return e.kind === "get" && h.params.length !== 0 && this.raiseRecoverable(h.start, "getter should have no params"), e.kind === "set" && h.params.length !== 1 && this.raiseRecoverable(h.start, "setter should have exactly one param"), e.kind === "set" && h.params[0].type === "RestElement" && this.raiseRecoverable(h.params[0].start, "Setter cannot use rest params"), this.finishNode(e, "MethodDefinition");
    }, L.parseClassField = function(e) {
      if (Ke2(e, "constructor") ? this.raise(e.key.start, "Classes can't have a field named 'constructor'") : e.static && Ke2(e, "prototype") && this.raise(e.key.start, "Classes can't have a static field named 'prototype'"), this.eat(i.eq)) {
        var t = this.currentThisScope(), r = t.inClassFieldInit;
        t.inClassFieldInit = true, e.value = this.parseMaybeAssign(), t.inClassFieldInit = r;
      } else e.value = null;
      return this.semicolon(), this.finishNode(e, "PropertyDefinition");
    }, L.parseClassStaticBlock = function(e) {
      e.body = [];
      var t = this.labels;
      for (this.labels = [], this.enterScope(Le | vt2); this.type !== i.braceR; ) {
        var r = this.parseStatement(null);
        e.body.push(r);
      }
      return this.next(), this.exitScope(), this.labels = t, this.finishNode(e, "StaticBlock");
    }, L.parseClassId = function(e, t) {
      this.type === i.name ? (e.id = this.parseIdent(), t && this.checkLValSimple(e.id, ve, false)) : (t === true && this.unexpected(), e.id = null);
    }, L.parseClassSuper = function(e) {
      e.superClass = this.eat(i._extends) ? this.parseExprSubscripts(false) : null;
    }, L.enterClassBody = function() {
      var e = { declared: /* @__PURE__ */ Object.create(null), used: [] };
      return this.privateNameStack.push(e), e.declared;
    }, L.exitClassBody = function() {
      for (var e = this.privateNameStack.pop(), t = e.declared, r = e.used, s = this.privateNameStack.length, n = s === 0 ? null : this.privateNameStack[s - 1], h = 0; h < r.length; ++h) {
        var c = r[h];
        P(t, c.name) || (n ? n.used.push(c) : this.raiseRecoverable(c.start, "Private field '#" + c.name + "' must be declared in an enclosing class"));
      }
    };
    function Xa2(e, t) {
      var r = t.key.name, s = e[r], n = "true";
      return t.type === "MethodDefinition" && (t.kind === "get" || t.kind === "set") && (n = (t.static ? "s" : "i") + t.kind), s === "iget" && n === "iset" || s === "iset" && n === "iget" || s === "sget" && n === "sset" || s === "sset" && n === "sget" ? (e[r] = "true", false) : s ? true : (e[r] = n, false);
    }
    function Ke2(e, t) {
      var r = e.computed, s = e.key;
      return !r && (s.type === "Identifier" && s.name === t || s.type === "Literal" && s.value === t);
    }
    L.parseExport = function(e, t) {
      if (this.next(), this.eat(i.star)) return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (e.exported = this.parseModuleExportName(), this.checkExport(t, e.exported, this.lastTokStart)) : e.exported = null), this.expectContextual("from"), this.type !== i.string && this.unexpected(), e.source = this.parseExprAtom(), this.semicolon(), this.finishNode(e, "ExportAllDeclaration");
      if (this.eat(i._default)) {
        this.checkExport(t, "default", this.lastTokStart);
        var r;
        if (this.type === i._function || (r = this.isAsyncFunction())) {
          var s = this.startNode();
          this.next(), r && this.next(), e.declaration = this.parseFunction(s, Ve | Cr, false, r);
        } else if (this.type === i._class) {
          var n = this.startNode();
          e.declaration = this.parseClass(n, "nullableID");
        } else e.declaration = this.parseMaybeAssign(), this.semicolon();
        return this.finishNode(e, "ExportDefaultDeclaration");
      }
      if (this.shouldParseExportStatement()) e.declaration = this.parseStatement(null), e.declaration.type === "VariableDeclaration" ? this.checkVariableExport(t, e.declaration.declarations) : this.checkExport(t, e.declaration.id, e.declaration.id.start), e.specifiers = [], e.source = null;
      else {
        if (e.declaration = null, e.specifiers = this.parseExportSpecifiers(t), this.eatContextual("from")) this.type !== i.string && this.unexpected(), e.source = this.parseExprAtom();
        else {
          for (var h = 0, c = e.specifiers; h < c.length; h += 1) {
            var m = c[h];
            this.checkUnreserved(m.local), this.checkLocalExport(m.local), m.local.type === "Literal" && this.raise(m.local.start, "A string literal cannot be used as an exported binding without `from`.");
          }
          e.source = null;
        }
        this.semicolon();
      }
      return this.finishNode(e, "ExportNamedDeclaration");
    }, L.checkExport = function(e, t, r) {
      e && (typeof t != "string" && (t = t.type === "Identifier" ? t.name : t.value), P(e, t) && this.raiseRecoverable(r, "Duplicate export '" + t + "'"), e[t] = true);
    }, L.checkPatternExport = function(e, t) {
      var r = t.type;
      if (r === "Identifier") this.checkExport(e, t, t.start);
      else if (r === "ObjectPattern") for (var s = 0, n = t.properties; s < n.length; s += 1) {
        var h = n[s];
        this.checkPatternExport(e, h);
      }
      else if (r === "ArrayPattern") for (var c = 0, m = t.elements; c < m.length; c += 1) {
        var A = m[c];
        A && this.checkPatternExport(e, A);
      }
      else r === "Property" ? this.checkPatternExport(e, t.value) : r === "AssignmentPattern" ? this.checkPatternExport(e, t.left) : r === "RestElement" ? this.checkPatternExport(e, t.argument) : r === "ParenthesizedExpression" && this.checkPatternExport(e, t.expression);
    }, L.checkVariableExport = function(e, t) {
      if (e) for (var r = 0, s = t; r < s.length; r += 1) {
        var n = s[r];
        this.checkPatternExport(e, n.id);
      }
    }, L.shouldParseExportStatement = function() {
      return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
    }, L.parseExportSpecifiers = function(e) {
      var t = [], r = true;
      for (this.expect(i.braceL); !this.eat(i.braceR); ) {
        if (r) r = false;
        else if (this.expect(i.comma), this.afterTrailingComma(i.braceR)) break;
        var s = this.startNode();
        s.local = this.parseModuleExportName(), s.exported = this.eatContextual("as") ? this.parseModuleExportName() : s.local, this.checkExport(e, s.exported, s.exported.start), t.push(this.finishNode(s, "ExportSpecifier"));
      }
      return t;
    }, L.parseImport = function(e) {
      return this.next(), this.type === i.string ? (e.specifiers = Ka2, e.source = this.parseExprAtom()) : (e.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), e.source = this.type === i.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(e, "ImportDeclaration");
    }, L.parseImportSpecifiers = function() {
      var e = [], t = true;
      if (this.type === i.name) {
        var r = this.startNode();
        if (r.local = this.parseIdent(), this.checkLValSimple(r.local, ve), e.push(this.finishNode(r, "ImportDefaultSpecifier")), !this.eat(i.comma)) return e;
      }
      if (this.type === i.star) {
        var s = this.startNode();
        return this.next(), this.expectContextual("as"), s.local = this.parseIdent(), this.checkLValSimple(s.local, ve), e.push(this.finishNode(s, "ImportNamespaceSpecifier")), e;
      }
      for (this.expect(i.braceL); !this.eat(i.braceR); ) {
        if (t) t = false;
        else if (this.expect(i.comma), this.afterTrailingComma(i.braceR)) break;
        var n = this.startNode();
        n.imported = this.parseModuleExportName(), this.eatContextual("as") ? n.local = this.parseIdent() : (this.checkUnreserved(n.imported), n.local = n.imported), this.checkLValSimple(n.local, ve), e.push(this.finishNode(n, "ImportSpecifier"));
      }
      return e;
    }, L.parseModuleExportName = function() {
      if (this.options.ecmaVersion >= 13 && this.type === i.string) {
        var e = this.parseLiteral(this.value);
        return K.test(e.value) && this.raise(e.start, "An export name cannot include a lone surrogate."), e;
      }
      return this.parseIdent(true);
    }, L.adaptDirectivePrologue = function(e) {
      for (var t = 0; t < e.length && this.isDirectiveCandidate(e[t]); ++t) e[t].directive = e[t].expression.raw.slice(1, -1);
    }, L.isDirectiveCandidate = function(e) {
      return this.options.ecmaVersion >= 5 && e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && (this.input[e.start] === '"' || this.input[e.start] === "'");
    };
    var he = Y.prototype;
    he.toAssignable = function(e, t, r) {
      if (this.options.ecmaVersion >= 6 && e) switch (e.type) {
        case "Identifier":
          this.inAsync && e.name === "await" && this.raise(e.start, "Cannot use 'await' as identifier inside an async function");
          break;
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
          break;
        case "ObjectExpression":
          e.type = "ObjectPattern", r && this.checkPatternErrors(r, true);
          for (var s = 0, n = e.properties; s < n.length; s += 1) {
            var h = n[s];
            this.toAssignable(h, t), h.type === "RestElement" && (h.argument.type === "ArrayPattern" || h.argument.type === "ObjectPattern") && this.raise(h.argument.start, "Unexpected token");
          }
          break;
        case "Property":
          e.kind !== "init" && this.raise(e.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(e.value, t);
          break;
        case "ArrayExpression":
          e.type = "ArrayPattern", r && this.checkPatternErrors(r, true), this.toAssignableList(e.elements, t);
          break;
        case "SpreadElement":
          e.type = "RestElement", this.toAssignable(e.argument, t), e.argument.type === "AssignmentPattern" && this.raise(e.argument.start, "Rest elements cannot have a default value");
          break;
        case "AssignmentExpression":
          e.operator !== "=" && this.raise(e.left.end, "Only '=' operator can be used for specifying default value."), e.type = "AssignmentPattern", delete e.operator, this.toAssignable(e.left, t);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(e.expression, t, r);
          break;
        case "ChainExpression":
          this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          if (!t) break;
        default:
          this.raise(e.start, "Assigning to rvalue");
      }
      else r && this.checkPatternErrors(r, true);
      return e;
    }, he.toAssignableList = function(e, t) {
      for (var r = e.length, s = 0; s < r; s++) {
        var n = e[s];
        n && this.toAssignable(n, t);
      }
      if (r) {
        var h = e[r - 1];
        this.options.ecmaVersion === 6 && t && h && h.type === "RestElement" && h.argument.type !== "Identifier" && this.unexpected(h.argument.start);
      }
      return e;
    }, he.parseSpread = function(e) {
      var t = this.startNode();
      return this.next(), t.argument = this.parseMaybeAssign(false, e), this.finishNode(t, "SpreadElement");
    }, he.parseRestBinding = function() {
      var e = this.startNode();
      return this.next(), this.options.ecmaVersion === 6 && this.type !== i.name && this.unexpected(), e.argument = this.parseBindingAtom(), this.finishNode(e, "RestElement");
    }, he.parseBindingAtom = function() {
      if (this.options.ecmaVersion >= 6) switch (this.type) {
        case i.bracketL:
          var e = this.startNode();
          return this.next(), e.elements = this.parseBindingList(i.bracketR, true, true), this.finishNode(e, "ArrayPattern");
        case i.braceL:
          return this.parseObj(true);
      }
      return this.parseIdent();
    }, he.parseBindingList = function(e, t, r) {
      for (var s = [], n = true; !this.eat(e); ) if (n ? n = false : this.expect(i.comma), t && this.type === i.comma) s.push(null);
      else {
        if (r && this.afterTrailingComma(e)) break;
        if (this.type === i.ellipsis) {
          var h = this.parseRestBinding();
          this.parseBindingListItem(h), s.push(h), this.type === i.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(e);
          break;
        } else {
          var c = this.parseMaybeDefault(this.start, this.startLoc);
          this.parseBindingListItem(c), s.push(c);
        }
      }
      return s;
    }, he.parseBindingListItem = function(e) {
      return e;
    }, he.parseMaybeDefault = function(e, t, r) {
      if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(i.eq)) return r;
      var s = this.startNodeAt(e, t);
      return s.left = r, s.right = this.parseMaybeAssign(), this.finishNode(s, "AssignmentPattern");
    }, he.checkLValSimple = function(e, t, r) {
      t === void 0 && (t = Ge);
      var s = t !== Ge;
      switch (e.type) {
        case "Identifier":
          this.strict && this.reservedWordsStrictBind.test(e.name) && this.raiseRecoverable(e.start, (s ? "Binding " : "Assigning to ") + e.name + " in strict mode"), s && (t === ve && e.name === "let" && this.raiseRecoverable(e.start, "let is disallowed as a lexically bound name"), r && (P(r, e.name) && this.raiseRecoverable(e.start, "Argument name clash"), r[e.name] = true), t !== Ar && this.declareName(e.name, t, e.start));
          break;
        case "ChainExpression":
          this.raiseRecoverable(e.start, "Optional chaining cannot appear in left-hand side");
          break;
        case "MemberExpression":
          s && this.raiseRecoverable(e.start, "Binding member expression");
          break;
        case "ParenthesizedExpression":
          return s && this.raiseRecoverable(e.start, "Binding parenthesized expression"), this.checkLValSimple(e.expression, t, r);
        default:
          this.raise(e.start, (s ? "Binding" : "Assigning to") + " rvalue");
      }
    }, he.checkLValPattern = function(e, t, r) {
      switch (t === void 0 && (t = Ge), e.type) {
        case "ObjectPattern":
          for (var s = 0, n = e.properties; s < n.length; s += 1) {
            var h = n[s];
            this.checkLValInnerPattern(h, t, r);
          }
          break;
        case "ArrayPattern":
          for (var c = 0, m = e.elements; c < m.length; c += 1) {
            var A = m[c];
            A && this.checkLValInnerPattern(A, t, r);
          }
          break;
        default:
          this.checkLValSimple(e, t, r);
      }
    }, he.checkLValInnerPattern = function(e, t, r) {
      switch (t === void 0 && (t = Ge), e.type) {
        case "Property":
          this.checkLValInnerPattern(e.value, t, r);
          break;
        case "AssignmentPattern":
          this.checkLValPattern(e.left, t, r);
          break;
        case "RestElement":
          this.checkLValPattern(e.argument, t, r);
          break;
        default:
          this.checkLValPattern(e, t, r);
      }
    };
    var ue = function(t, r, s, n, h) {
      this.token = t, this.isExpr = !!r, this.preserveSpace = !!s, this.override = n, this.generator = !!h;
    }, $2 = { b_stat: new ue("{", false), b_expr: new ue("{", true), b_tmpl: new ue("${", false), p_stat: new ue("(", false), p_expr: new ue("(", true), q_tmpl: new ue("`", true, true, function(e) {
      return e.tryReadTemplateToken();
    }), f_stat: new ue("function", false), f_expr: new ue("function", true), f_expr_gen: new ue("function", true, false, null, true), f_gen: new ue("function", false, false, null, true) }, Fe = Y.prototype;
    Fe.initialContext = function() {
      return [$2.b_stat];
    }, Fe.curContext = function() {
      return this.context[this.context.length - 1];
    }, Fe.braceIsBlock = function(e) {
      var t = this.curContext();
      return t === $2.f_expr || t === $2.f_stat ? true : e === i.colon && (t === $2.b_stat || t === $2.b_expr) ? !t.isExpr : e === i._return || e === i.name && this.exprAllowed ? S.test(this.input.slice(this.lastTokEnd, this.start)) : e === i._else || e === i.semi || e === i.eof || e === i.parenR || e === i.arrow ? true : e === i.braceL ? t === $2.b_stat : e === i._var || e === i._const || e === i.name ? false : !this.exprAllowed;
    }, Fe.inGeneratorContext = function() {
      for (var e = this.context.length - 1; e >= 1; e--) {
        var t = this.context[e];
        if (t.token === "function") return t.generator;
      }
      return false;
    }, Fe.updateContext = function(e) {
      var t, r = this.type;
      r.keyword && e === i.dot ? this.exprAllowed = false : (t = r.updateContext) ? t.call(this, e) : this.exprAllowed = r.beforeExpr;
    }, Fe.overrideContext = function(e) {
      this.curContext() !== e && (this.context[this.context.length - 1] = e);
    }, i.parenR.updateContext = i.braceR.updateContext = function() {
      if (this.context.length === 1) {
        this.exprAllowed = true;
        return;
      }
      var e = this.context.pop();
      e === $2.b_stat && this.curContext().token === "function" && (e = this.context.pop()), this.exprAllowed = !e.isExpr;
    }, i.braceL.updateContext = function(e) {
      this.context.push(this.braceIsBlock(e) ? $2.b_stat : $2.b_expr), this.exprAllowed = true;
    }, i.dollarBraceL.updateContext = function() {
      this.context.push($2.b_tmpl), this.exprAllowed = true;
    }, i.parenL.updateContext = function(e) {
      var t = e === i._if || e === i._for || e === i._with || e === i._while;
      this.context.push(t ? $2.p_stat : $2.p_expr), this.exprAllowed = true;
    }, i.incDec.updateContext = function() {
    }, i._function.updateContext = i._class.updateContext = function(e) {
      e.beforeExpr && e !== i._else && !(e === i.semi && this.curContext() !== $2.p_stat) && !(e === i._return && S.test(this.input.slice(this.lastTokEnd, this.start))) && !((e === i.colon || e === i.braceL) && this.curContext() === $2.b_stat) ? this.context.push($2.f_expr) : this.context.push($2.f_stat), this.exprAllowed = false;
    }, i.backQuote.updateContext = function() {
      this.curContext() === $2.q_tmpl ? this.context.pop() : this.context.push($2.q_tmpl), this.exprAllowed = false;
    }, i.star.updateContext = function(e) {
      if (e === i._function) {
        var t = this.context.length - 1;
        this.context[t] === $2.f_expr ? this.context[t] = $2.f_expr_gen : this.context[t] = $2.f_gen;
      }
      this.exprAllowed = true;
    }, i.name.updateContext = function(e) {
      var t = false;
      this.options.ecmaVersion >= 6 && e !== i.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (t = true), this.exprAllowed = t;
    };
    var M = Y.prototype;
    M.checkPropClash = function(e, t, r) {
      if (!(this.options.ecmaVersion >= 9 && e.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (e.computed || e.method || e.shorthand))) {
        var s = e.key, n;
        switch (s.type) {
          case "Identifier":
            n = s.name;
            break;
          case "Literal":
            n = String(s.value);
            break;
          default:
            return;
        }
        var h = e.kind;
        if (this.options.ecmaVersion >= 6) {
          n === "__proto__" && h === "init" && (t.proto && (r ? r.doubleProto < 0 && (r.doubleProto = s.start) : this.raiseRecoverable(s.start, "Redefinition of __proto__ property")), t.proto = true);
          return;
        }
        n = "$" + n;
        var c = t[n];
        if (c) {
          var m;
          h === "init" ? m = this.strict && c.init || c.get || c.set : m = c.init || c[h], m && this.raiseRecoverable(s.start, "Redefinition of property");
        } else c = t[n] = { init: false, get: false, set: false };
        c[h] = true;
      }
    }, M.parseExpression = function(e, t) {
      var r = this.start, s = this.startLoc, n = this.parseMaybeAssign(e, t);
      if (this.type === i.comma) {
        var h = this.startNodeAt(r, s);
        for (h.expressions = [n]; this.eat(i.comma); ) h.expressions.push(this.parseMaybeAssign(e, t));
        return this.finishNode(h, "SequenceExpression");
      }
      return n;
    }, M.parseMaybeAssign = function(e, t, r) {
      if (this.isContextual("yield")) {
        if (this.inGenerator) return this.parseYield(e);
        this.exprAllowed = false;
      }
      var s = false, n = -1, h = -1, c = -1;
      t ? (n = t.parenthesizedAssign, h = t.trailingComma, c = t.doubleProto, t.parenthesizedAssign = t.trailingComma = -1) : (t = new He(), s = true);
      var m = this.start, A = this.startLoc;
      (this.type === i.parenL || this.type === i.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = e === "await");
      var q = this.parseMaybeConditional(e, t);
      if (r && (q = r.call(this, q, m, A)), this.type.isAssign) {
        var W = this.startNodeAt(m, A);
        return W.operator = this.value, this.type === i.eq && (q = this.toAssignable(q, false, t)), s || (t.parenthesizedAssign = t.trailingComma = t.doubleProto = -1), t.shorthandAssign >= q.start && (t.shorthandAssign = -1), this.type === i.eq ? this.checkLValPattern(q) : this.checkLValSimple(q), W.left = q, this.next(), W.right = this.parseMaybeAssign(e), c > -1 && (t.doubleProto = c), this.finishNode(W, "AssignmentExpression");
      } else s && this.checkExpressionErrors(t, true);
      return n > -1 && (t.parenthesizedAssign = n), h > -1 && (t.trailingComma = h), q;
    }, M.parseMaybeConditional = function(e, t) {
      var r = this.start, s = this.startLoc, n = this.parseExprOps(e, t);
      if (this.checkExpressionErrors(t)) return n;
      if (this.eat(i.question)) {
        var h = this.startNodeAt(r, s);
        return h.test = n, h.consequent = this.parseMaybeAssign(), this.expect(i.colon), h.alternate = this.parseMaybeAssign(e), this.finishNode(h, "ConditionalExpression");
      }
      return n;
    }, M.parseExprOps = function(e, t) {
      var r = this.start, s = this.startLoc, n = this.parseMaybeUnary(t, false, false, e);
      return this.checkExpressionErrors(t) || n.start === r && n.type === "ArrowFunctionExpression" ? n : this.parseExprOp(n, r, s, -1, e);
    }, M.parseExprOp = function(e, t, r, s, n) {
      var h = this.type.binop;
      if (h != null && (!n || this.type !== i._in) && h > s) {
        var c = this.type === i.logicalOR || this.type === i.logicalAND, m = this.type === i.coalesce;
        m && (h = i.logicalAND.binop);
        var A = this.value;
        this.next();
        var q = this.start, W = this.startLoc, re = this.parseExprOp(this.parseMaybeUnary(null, false, false, n), q, W, h, n), Se = this.buildBinary(t, r, e, re, A, c || m);
        return (c && this.type === i.coalesce || m && (this.type === i.logicalOR || this.type === i.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(Se, t, r, s, n);
      }
      return e;
    }, M.buildBinary = function(e, t, r, s, n, h) {
      s.type === "PrivateIdentifier" && this.raise(s.start, "Private identifier can only be left side of binary expression");
      var c = this.startNodeAt(e, t);
      return c.left = r, c.operator = n, c.right = s, this.finishNode(c, h ? "LogicalExpression" : "BinaryExpression");
    }, M.parseMaybeUnary = function(e, t, r, s) {
      var n = this.start, h = this.startLoc, c;
      if (this.isContextual("await") && this.canAwait) c = this.parseAwait(s), t = true;
      else if (this.type.prefix) {
        var m = this.startNode(), A = this.type === i.incDec;
        m.operator = this.value, m.prefix = true, this.next(), m.argument = this.parseMaybeUnary(null, true, A, s), this.checkExpressionErrors(e, true), A ? this.checkLValSimple(m.argument) : this.strict && m.operator === "delete" && m.argument.type === "Identifier" ? this.raiseRecoverable(m.start, "Deleting local variable in strict mode") : m.operator === "delete" && Er(m.argument) ? this.raiseRecoverable(m.start, "Private fields can not be deleted") : t = true, c = this.finishNode(m, A ? "UpdateExpression" : "UnaryExpression");
      } else if (!t && this.type === i.privateId) (s || this.privateNameStack.length === 0) && this.unexpected(), c = this.parsePrivateIdent(), this.type !== i._in && this.unexpected();
      else {
        if (c = this.parseExprSubscripts(e, s), this.checkExpressionErrors(e)) return c;
        for (; this.type.postfix && !this.canInsertSemicolon(); ) {
          var q = this.startNodeAt(n, h);
          q.operator = this.value, q.prefix = false, q.argument = c, this.checkLValSimple(c), this.next(), c = this.finishNode(q, "UpdateExpression");
        }
      }
      if (!r && this.eat(i.starstar)) if (t) this.unexpected(this.lastTokStart);
      else return this.buildBinary(n, h, c, this.parseMaybeUnary(null, false, false, s), "**", false);
      else return c;
    };
    function Er(e) {
      return e.type === "MemberExpression" && e.property.type === "PrivateIdentifier" || e.type === "ChainExpression" && Er(e.expression);
    }
    M.parseExprSubscripts = function(e, t) {
      var r = this.start, s = this.startLoc, n = this.parseExprAtom(e, t);
      if (n.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") return n;
      var h = this.parseSubscripts(n, r, s, false, t);
      return e && h.type === "MemberExpression" && (e.parenthesizedAssign >= h.start && (e.parenthesizedAssign = -1), e.parenthesizedBind >= h.start && (e.parenthesizedBind = -1), e.trailingComma >= h.start && (e.trailingComma = -1)), h;
    }, M.parseSubscripts = function(e, t, r, s, n) {
      for (var h = this.options.ecmaVersion >= 8 && e.type === "Identifier" && e.name === "async" && this.lastTokEnd === e.end && !this.canInsertSemicolon() && e.end - e.start === 5 && this.potentialArrowAt === e.start, c = false; ; ) {
        var m = this.parseSubscript(e, t, r, s, h, c, n);
        if (m.optional && (c = true), m === e || m.type === "ArrowFunctionExpression") {
          if (c) {
            var A = this.startNodeAt(t, r);
            A.expression = m, m = this.finishNode(A, "ChainExpression");
          }
          return m;
        }
        e = m;
      }
    }, M.parseSubscript = function(e, t, r, s, n, h, c) {
      var m = this.options.ecmaVersion >= 11, A = m && this.eat(i.questionDot);
      s && A && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
      var q = this.eat(i.bracketL);
      if (q || A && this.type !== i.parenL && this.type !== i.backQuote || this.eat(i.dot)) {
        var W = this.startNodeAt(t, r);
        W.object = e, q ? (W.property = this.parseExpression(), this.expect(i.bracketR)) : this.type === i.privateId && e.type !== "Super" ? W.property = this.parsePrivateIdent() : W.property = this.parseIdent(this.options.allowReserved !== "never"), W.computed = !!q, m && (W.optional = A), e = this.finishNode(W, "MemberExpression");
      } else if (!s && this.eat(i.parenL)) {
        var re = new He(), Se = this.yieldPos, qe2 = this.awaitPos, Be = this.awaitIdentPos;
        this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
        var $e = this.parseExprList(i.parenR, this.options.ecmaVersion >= 8, false, re);
        if (n && !A && !this.canInsertSemicolon() && this.eat(i.arrow)) return this.checkPatternErrors(re, false), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = Se, this.awaitPos = qe2, this.awaitIdentPos = Be, this.parseArrowExpression(this.startNodeAt(t, r), $e, true, c);
        this.checkExpressionErrors(re, true), this.yieldPos = Se || this.yieldPos, this.awaitPos = qe2 || this.awaitPos, this.awaitIdentPos = Be || this.awaitIdentPos;
        var Ie = this.startNodeAt(t, r);
        Ie.callee = e, Ie.arguments = $e, m && (Ie.optional = A), e = this.finishNode(Ie, "CallExpression");
      } else if (this.type === i.backQuote) {
        (A || h) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
        var Te2 = this.startNodeAt(t, r);
        Te2.tag = e, Te2.quasi = this.parseTemplate({ isTagged: true }), e = this.finishNode(Te2, "TaggedTemplateExpression");
      }
      return e;
    }, M.parseExprAtom = function(e, t) {
      this.type === i.slash && this.readRegexp();
      var r, s = this.potentialArrowAt === this.start;
      switch (this.type) {
        case i._super:
          return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), r = this.startNode(), this.next(), this.type === i.parenL && !this.allowDirectSuper && this.raise(r.start, "super() call outside constructor of a subclass"), this.type !== i.dot && this.type !== i.bracketL && this.type !== i.parenL && this.unexpected(), this.finishNode(r, "Super");
        case i._this:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case i.name:
          var n = this.start, h = this.startLoc, c = this.containsEsc, m = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !c && m.name === "async" && !this.canInsertSemicolon() && this.eat(i._function)) return this.overrideContext($2.f_expr), this.parseFunction(this.startNodeAt(n, h), 0, false, true, t);
          if (s && !this.canInsertSemicolon()) {
            if (this.eat(i.arrow)) return this.parseArrowExpression(this.startNodeAt(n, h), [m], false, t);
            if (this.options.ecmaVersion >= 8 && m.name === "async" && this.type === i.name && !c && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) return m = this.parseIdent(false), (this.canInsertSemicolon() || !this.eat(i.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(n, h), [m], true, t);
          }
          return m;
        case i.regexp:
          var A = this.value;
          return r = this.parseLiteral(A.value), r.regex = { pattern: A.pattern, flags: A.flags }, r;
        case i.num:
        case i.string:
          return this.parseLiteral(this.value);
        case i._null:
        case i._true:
        case i._false:
          return r = this.startNode(), r.value = this.type === i._null ? null : this.type === i._true, r.raw = this.type.keyword, this.next(), this.finishNode(r, "Literal");
        case i.parenL:
          var q = this.start, W = this.parseParenAndDistinguishExpression(s, t);
          return e && (e.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(W) && (e.parenthesizedAssign = q), e.parenthesizedBind < 0 && (e.parenthesizedBind = q)), W;
        case i.bracketL:
          return r = this.startNode(), this.next(), r.elements = this.parseExprList(i.bracketR, true, true, e), this.finishNode(r, "ArrayExpression");
        case i.braceL:
          return this.overrideContext($2.b_expr), this.parseObj(false, e);
        case i._function:
          return r = this.startNode(), this.next(), this.parseFunction(r, 0);
        case i._class:
          return this.parseClass(this.startNode(), false);
        case i._new:
          return this.parseNew();
        case i.backQuote:
          return this.parseTemplate();
        case i._import:
          return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected();
        default:
          this.unexpected();
      }
    }, M.parseExprImport = function() {
      var e = this.startNode();
      this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
      var t = this.parseIdent(true);
      switch (this.type) {
        case i.parenL:
          return this.parseDynamicImport(e);
        case i.dot:
          return e.meta = t, this.parseImportMeta(e);
        default:
          this.unexpected();
      }
    }, M.parseDynamicImport = function(e) {
      if (this.next(), e.source = this.parseMaybeAssign(), !this.eat(i.parenR)) {
        var t = this.start;
        this.eat(i.comma) && this.eat(i.parenR) ? this.raiseRecoverable(t, "Trailing comma is not allowed in import()") : this.unexpected(t);
      }
      return this.finishNode(e, "ImportExpression");
    }, M.parseImportMeta = function(e) {
      this.next();
      var t = this.containsEsc;
      return e.property = this.parseIdent(true), e.property.name !== "meta" && this.raiseRecoverable(e.property.start, "The only valid meta property for import is 'import.meta'"), t && this.raiseRecoverable(e.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(e.start, "Cannot use 'import.meta' outside a module"), this.finishNode(e, "MetaProperty");
    }, M.parseLiteral = function(e) {
      var t = this.startNode();
      return t.value = e, t.raw = this.input.slice(this.start, this.end), t.raw.charCodeAt(t.raw.length - 1) === 110 && (t.bigint = t.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(t, "Literal");
    }, M.parseParenExpression = function() {
      this.expect(i.parenL);
      var e = this.parseExpression();
      return this.expect(i.parenR), e;
    }, M.parseParenAndDistinguishExpression = function(e, t) {
      var r = this.start, s = this.startLoc, n, h = this.options.ecmaVersion >= 8;
      if (this.options.ecmaVersion >= 6) {
        this.next();
        var c = this.start, m = this.startLoc, A = [], q = true, W = false, re = new He(), Se = this.yieldPos, qe2 = this.awaitPos, Be;
        for (this.yieldPos = 0, this.awaitPos = 0; this.type !== i.parenR; ) if (q ? q = false : this.expect(i.comma), h && this.afterTrailingComma(i.parenR, true)) {
          W = true;
          break;
        } else if (this.type === i.ellipsis) {
          Be = this.start, A.push(this.parseParenItem(this.parseRestBinding())), this.type === i.comma && this.raise(this.start, "Comma is not permitted after the rest element");
          break;
        } else A.push(this.parseMaybeAssign(false, re, this.parseParenItem));
        var $e = this.lastTokEnd, Ie = this.lastTokEndLoc;
        if (this.expect(i.parenR), e && !this.canInsertSemicolon() && this.eat(i.arrow)) return this.checkPatternErrors(re, false), this.checkYieldAwaitInDefaultParams(), this.yieldPos = Se, this.awaitPos = qe2, this.parseParenArrowList(r, s, A, t);
        (!A.length || W) && this.unexpected(this.lastTokStart), Be && this.unexpected(Be), this.checkExpressionErrors(re, true), this.yieldPos = Se || this.yieldPos, this.awaitPos = qe2 || this.awaitPos, A.length > 1 ? (n = this.startNodeAt(c, m), n.expressions = A, this.finishNodeAt(n, "SequenceExpression", $e, Ie)) : n = A[0];
      } else n = this.parseParenExpression();
      if (this.options.preserveParens) {
        var Te2 = this.startNodeAt(r, s);
        return Te2.expression = n, this.finishNode(Te2, "ParenthesizedExpression");
      } else return n;
    }, M.parseParenItem = function(e) {
      return e;
    }, M.parseParenArrowList = function(e, t, r, s) {
      return this.parseArrowExpression(this.startNodeAt(e, t), r, false, s);
    };
    var Ja2 = [];
    M.parseNew = function() {
      this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
      var e = this.startNode(), t = this.parseIdent(true);
      if (this.options.ecmaVersion >= 6 && this.eat(i.dot)) {
        e.meta = t;
        var r = this.containsEsc;
        return e.property = this.parseIdent(true), e.property.name !== "target" && this.raiseRecoverable(e.property.start, "The only valid meta property for new is 'new.target'"), r && this.raiseRecoverable(e.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(e.start, "'new.target' can only be used in functions and class static block"), this.finishNode(e, "MetaProperty");
      }
      var s = this.start, n = this.startLoc, h = this.type === i._import;
      return e.callee = this.parseSubscripts(this.parseExprAtom(), s, n, true, false), h && e.callee.type === "ImportExpression" && this.raise(s, "Cannot use new with import()"), this.eat(i.parenL) ? e.arguments = this.parseExprList(i.parenR, this.options.ecmaVersion >= 8, false) : e.arguments = Ja2, this.finishNode(e, "NewExpression");
    }, M.parseTemplateElement = function(e) {
      var t = e.isTagged, r = this.startNode();
      return this.type === i.invalidTemplate ? (t || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r.value = { raw: this.value, cooked: null }) : r.value = { raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`), cooked: this.value }, this.next(), r.tail = this.type === i.backQuote, this.finishNode(r, "TemplateElement");
    }, M.parseTemplate = function(e) {
      e === void 0 && (e = {});
      var t = e.isTagged;
      t === void 0 && (t = false);
      var r = this.startNode();
      this.next(), r.expressions = [];
      var s = this.parseTemplateElement({ isTagged: t });
      for (r.quasis = [s]; !s.tail; ) this.type === i.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(i.dollarBraceL), r.expressions.push(this.parseExpression()), this.expect(i.braceR), r.quasis.push(s = this.parseTemplateElement({ isTagged: t }));
      return this.next(), this.finishNode(r, "TemplateLiteral");
    }, M.isAsyncProp = function(e) {
      return !e.computed && e.key.type === "Identifier" && e.key.name === "async" && (this.type === i.name || this.type === i.num || this.type === i.string || this.type === i.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === i.star) && !S.test(this.input.slice(this.lastTokEnd, this.start));
    }, M.parseObj = function(e, t) {
      var r = this.startNode(), s = true, n = {};
      for (r.properties = [], this.next(); !this.eat(i.braceR); ) {
        if (s) s = false;
        else if (this.expect(i.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(i.braceR)) break;
        var h = this.parseProperty(e, t);
        e || this.checkPropClash(h, n, t), r.properties.push(h);
      }
      return this.finishNode(r, e ? "ObjectPattern" : "ObjectExpression");
    }, M.parseProperty = function(e, t) {
      var r = this.startNode(), s, n, h, c;
      if (this.options.ecmaVersion >= 9 && this.eat(i.ellipsis)) return e ? (r.argument = this.parseIdent(false), this.type === i.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(r, "RestElement")) : (r.argument = this.parseMaybeAssign(false, t), this.type === i.comma && t && t.trailingComma < 0 && (t.trailingComma = this.start), this.finishNode(r, "SpreadElement"));
      this.options.ecmaVersion >= 6 && (r.method = false, r.shorthand = false, (e || t) && (h = this.start, c = this.startLoc), e || (s = this.eat(i.star)));
      var m = this.containsEsc;
      return this.parsePropertyName(r), !e && !m && this.options.ecmaVersion >= 8 && !s && this.isAsyncProp(r) ? (n = true, s = this.options.ecmaVersion >= 9 && this.eat(i.star), this.parsePropertyName(r, t)) : n = false, this.parsePropertyValue(r, e, s, n, h, c, t, m), this.finishNode(r, "Property");
    }, M.parsePropertyValue = function(e, t, r, s, n, h, c, m) {
      if ((r || s) && this.type === i.colon && this.unexpected(), this.eat(i.colon)) e.value = t ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, c), e.kind = "init";
      else if (this.options.ecmaVersion >= 6 && this.type === i.parenL) t && this.unexpected(), e.kind = "init", e.method = true, e.value = this.parseMethod(r, s);
      else if (!t && !m && this.options.ecmaVersion >= 5 && !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.type !== i.comma && this.type !== i.braceR && this.type !== i.eq) {
        (r || s) && this.unexpected(), e.kind = e.key.name, this.parsePropertyName(e), e.value = this.parseMethod(false);
        var A = e.kind === "get" ? 0 : 1;
        if (e.value.params.length !== A) {
          var q = e.value.start;
          e.kind === "get" ? this.raiseRecoverable(q, "getter should have no params") : this.raiseRecoverable(q, "setter should have exactly one param");
        } else e.kind === "set" && e.value.params[0].type === "RestElement" && this.raiseRecoverable(e.value.params[0].start, "Setter cannot use rest params");
      } else this.options.ecmaVersion >= 6 && !e.computed && e.key.type === "Identifier" ? ((r || s) && this.unexpected(), this.checkUnreserved(e.key), e.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = n), e.kind = "init", t ? e.value = this.parseMaybeDefault(n, h, this.copyNode(e.key)) : this.type === i.eq && c ? (c.shorthandAssign < 0 && (c.shorthandAssign = this.start), e.value = this.parseMaybeDefault(n, h, this.copyNode(e.key))) : e.value = this.copyNode(e.key), e.shorthand = true) : this.unexpected();
    }, M.parsePropertyName = function(e) {
      if (this.options.ecmaVersion >= 6) {
        if (this.eat(i.bracketL)) return e.computed = true, e.key = this.parseMaybeAssign(), this.expect(i.bracketR), e.key;
        e.computed = false;
      }
      return e.key = this.type === i.num || this.type === i.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
    }, M.initFunction = function(e) {
      e.id = null, this.options.ecmaVersion >= 6 && (e.generator = e.expression = false), this.options.ecmaVersion >= 8 && (e.async = false);
    }, M.parseMethod = function(e, t, r) {
      var s = this.startNode(), n = this.yieldPos, h = this.awaitPos, c = this.awaitIdentPos;
      return this.initFunction(s), this.options.ecmaVersion >= 6 && (s.generator = e), this.options.ecmaVersion >= 8 && (s.async = !!t), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(xt(t, s.generator) | vt2 | (r ? gr2 : 0)), this.expect(i.parenL), s.params = this.parseBindingList(i.parenR, false, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(s, false, true, false), this.yieldPos = n, this.awaitPos = h, this.awaitIdentPos = c, this.finishNode(s, "FunctionExpression");
    }, M.parseArrowExpression = function(e, t, r, s) {
      var n = this.yieldPos, h = this.awaitPos, c = this.awaitIdentPos;
      return this.enterScope(xt(r, false) | mr2), this.initFunction(e), this.options.ecmaVersion >= 8 && (e.async = !!r), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, e.params = this.toAssignableList(t, true), this.parseFunctionBody(e, true, false, s), this.yieldPos = n, this.awaitPos = h, this.awaitIdentPos = c, this.finishNode(e, "ArrowFunctionExpression");
    }, M.parseFunctionBody = function(e, t, r, s) {
      var n = t && this.type !== i.braceL, h = this.strict, c = false;
      if (n) e.body = this.parseMaybeAssign(s), e.expression = true, this.checkParams(e, false);
      else {
        var m = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(e.params);
        (!h || m) && (c = this.strictDirective(this.end), c && m && this.raiseRecoverable(e.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
        var A = this.labels;
        this.labels = [], c && (this.strict = true), this.checkParams(e, !h && !c && !t && !r && this.isSimpleParamList(e.params)), this.strict && e.id && this.checkLValSimple(e.id, Ar), e.body = this.parseBlock(false, void 0, c && !h), e.expression = false, this.adaptDirectivePrologue(e.body.body), this.labels = A;
      }
      this.exitScope();
    }, M.isSimpleParamList = function(e) {
      for (var t = 0, r = e; t < r.length; t += 1) {
        var s = r[t];
        if (s.type !== "Identifier") return false;
      }
      return true;
    }, M.checkParams = function(e, t) {
      for (var r = /* @__PURE__ */ Object.create(null), s = 0, n = e.params; s < n.length; s += 1) {
        var h = n[s];
        this.checkLValInnerPattern(h, yt2, t ? null : r);
      }
    }, M.parseExprList = function(e, t, r, s) {
      for (var n = [], h = true; !this.eat(e); ) {
        if (h) h = false;
        else if (this.expect(i.comma), t && this.afterTrailingComma(e)) break;
        var c = void 0;
        r && this.type === i.comma ? c = null : this.type === i.ellipsis ? (c = this.parseSpread(s), s && this.type === i.comma && s.trailingComma < 0 && (s.trailingComma = this.start)) : c = this.parseMaybeAssign(false, s), n.push(c);
      }
      return n;
    }, M.checkUnreserved = function(e) {
      var t = e.start, r = e.end, s = e.name;
      if (this.inGenerator && s === "yield" && this.raiseRecoverable(t, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && s === "await" && this.raiseRecoverable(t, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && s === "arguments" && this.raiseRecoverable(t, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (s === "arguments" || s === "await") && this.raise(t, "Cannot use " + s + " in class static initialization block"), this.keywords.test(s) && this.raise(t, "Unexpected keyword '" + s + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(t, r).indexOf("\\") !== -1)) {
        var n = this.strict ? this.reservedWordsStrict : this.reservedWords;
        n.test(s) && (!this.inAsync && s === "await" && this.raiseRecoverable(t, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(t, "The keyword '" + s + "' is reserved"));
      }
    }, M.parseIdent = function(e, t) {
      var r = this.startNode();
      return this.type === i.name ? r.name = this.value : this.type.keyword ? (r.name = this.type.keyword, (r.name === "class" || r.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(!!e), this.finishNode(r, "Identifier"), e || (this.checkUnreserved(r), r.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = r.start)), r;
    }, M.parsePrivateIdent = function() {
      var e = this.startNode();
      return this.type === i.privateId ? e.name = this.value : this.unexpected(), this.next(), this.finishNode(e, "PrivateIdentifier"), this.privateNameStack.length === 0 ? this.raise(e.start, "Private field '#" + e.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(e), e;
    }, M.parseYield = function(e) {
      this.yieldPos || (this.yieldPos = this.start);
      var t = this.startNode();
      return this.next(), this.type === i.semi || this.canInsertSemicolon() || this.type !== i.star && !this.type.startsExpr ? (t.delegate = false, t.argument = null) : (t.delegate = this.eat(i.star), t.argument = this.parseMaybeAssign(e)), this.finishNode(t, "YieldExpression");
    }, M.parseAwait = function(e) {
      this.awaitPos || (this.awaitPos = this.start);
      var t = this.startNode();
      return this.next(), t.argument = this.parseMaybeUnary(null, true, false, e), this.finishNode(t, "AwaitExpression");
    };
    var Xe = Y.prototype;
    Xe.raise = function(e, t) {
      var r = ae(this.input, e);
      t += " (" + r.line + ":" + r.column + ")";
      var s = new SyntaxError(t);
      throw s.pos = e, s.loc = r, s.raisedAt = this.pos, s;
    }, Xe.raiseRecoverable = Xe.raise, Xe.curPosition = function() {
      if (this.options.locations) return new H(this.curLine, this.pos - this.lineStart);
    };
    var Ee = Y.prototype, Qa2 = function(t) {
      this.flags = t, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = false;
    };
    Ee.enterScope = function(e) {
      this.scopeStack.push(new Qa2(e));
    }, Ee.exitScope = function() {
      this.scopeStack.pop();
    }, Ee.treatFunctionsAsVarInScope = function(e) {
      return e.flags & Ce || !this.inModule && e.flags & _e;
    }, Ee.declareName = function(e, t, r) {
      var s = false;
      if (t === ve) {
        var n = this.currentScope();
        s = n.lexical.indexOf(e) > -1 || n.functions.indexOf(e) > -1 || n.var.indexOf(e) > -1, n.lexical.push(e), this.inModule && n.flags & _e && delete this.undefinedExports[e];
      } else if (t === yr) {
        var h = this.currentScope();
        h.lexical.push(e);
      } else if (t === xr2) {
        var c = this.currentScope();
        this.treatFunctionsAsVar ? s = c.lexical.indexOf(e) > -1 : s = c.lexical.indexOf(e) > -1 || c.var.indexOf(e) > -1, c.functions.push(e);
      } else for (var m = this.scopeStack.length - 1; m >= 0; --m) {
        var A = this.scopeStack[m];
        if (A.lexical.indexOf(e) > -1 && !(A.flags & vr && A.lexical[0] === e) || !this.treatFunctionsAsVarInScope(A) && A.functions.indexOf(e) > -1) {
          s = true;
          break;
        }
        if (A.var.push(e), this.inModule && A.flags & _e && delete this.undefinedExports[e], A.flags & gt) break;
      }
      s && this.raiseRecoverable(r, "Identifier '" + e + "' has already been declared");
    }, Ee.checkLocalExport = function(e) {
      this.scopeStack[0].lexical.indexOf(e.name) === -1 && this.scopeStack[0].var.indexOf(e.name) === -1 && (this.undefinedExports[e.name] = e);
    }, Ee.currentScope = function() {
      return this.scopeStack[this.scopeStack.length - 1];
    }, Ee.currentVarScope = function() {
      for (var e = this.scopeStack.length - 1; ; e--) {
        var t = this.scopeStack[e];
        if (t.flags & gt) return t;
      }
    }, Ee.currentThisScope = function() {
      for (var e = this.scopeStack.length - 1; ; e--) {
        var t = this.scopeStack[e];
        if (t.flags & gt && !(t.flags & mr2)) return t;
      }
    };
    var Re = function(t, r, s) {
      this.type = "", this.start = r, this.end = 0, t.options.locations && (this.loc = new te2(t, s)), t.options.directSourceFile && (this.sourceFile = t.options.directSourceFile), t.options.ranges && (this.range = [r, 0]);
    }, je = Y.prototype;
    je.startNode = function() {
      return new Re(this, this.start, this.startLoc);
    }, je.startNodeAt = function(e, t) {
      return new Re(this, e, t);
    };
    function br2(e, t, r, s) {
      return e.type = t, e.end = r, this.options.locations && (e.loc.end = s), this.options.ranges && (e.range[1] = r), e;
    }
    je.finishNode = function(e, t) {
      return br2.call(this, e, t, this.lastTokEnd, this.lastTokEndLoc);
    }, je.finishNodeAt = function(e, t, r, s) {
      return br2.call(this, e, t, r, s);
    }, je.copyNode = function(e) {
      var t = new Re(this, e.start, this.startLoc);
      for (var r in e) t[r] = e[r];
      return t;
    };
    var _r2 = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Sr = _r2 + " Extended_Pictographic", wr2 = Sr, kr2 = wr2 + " EBase EComp EMod EPres ExtPict", $a2 = kr2, Ya2 = { 9: _r2, 10: Sr, 11: wr2, 12: kr2, 13: $a2 }, Fr2 = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Br2 = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", Ir2 = Br2 + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", Tr2 = Ir2 + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Pr2 = Tr2 + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", Za2 = Pr2 + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", en = { 9: Br2, 10: Ir2, 11: Tr2, 12: Pr2, 13: Za2 }, Dr2 = {};
    function tn2(e) {
      var t = Dr2[e] = { binary: d(Ya2[e] + " " + Fr2), nonBinary: { General_Category: d(Fr2), Script: d(en[e]) } };
      t.nonBinary.Script_Extensions = t.nonBinary.Script, t.nonBinary.gc = t.nonBinary.General_Category, t.nonBinary.sc = t.nonBinary.Script, t.nonBinary.scx = t.nonBinary.Script_Extensions;
    }
    for (var Et2 = 0, Nr2 = [9, 10, 11, 12, 13]; Et2 < Nr2.length; Et2 += 1) {
      var rn2 = Nr2[Et2];
      tn2(rn2);
    }
    var N = Y.prototype, ge = function(t) {
      this.parser = t, this.validFlags = "gim" + (t.options.ecmaVersion >= 6 ? "uy" : "") + (t.options.ecmaVersion >= 9 ? "s" : "") + (t.options.ecmaVersion >= 13 ? "d" : ""), this.unicodeProperties = Dr2[t.options.ecmaVersion >= 13 ? 13 : t.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = false, this.switchN = false, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = false, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
    };
    ge.prototype.reset = function(t, r, s) {
      var n = s.indexOf("u") !== -1;
      this.start = t | 0, this.source = r + "", this.flags = s, this.switchU = n && this.parser.options.ecmaVersion >= 6, this.switchN = n && this.parser.options.ecmaVersion >= 9;
    }, ge.prototype.raise = function(t) {
      this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + t);
    }, ge.prototype.at = function(t, r) {
      r === void 0 && (r = false);
      var s = this.source, n = s.length;
      if (t >= n) return -1;
      var h = s.charCodeAt(t);
      if (!(r || this.switchU) || h <= 55295 || h >= 57344 || t + 1 >= n) return h;
      var c = s.charCodeAt(t + 1);
      return c >= 56320 && c <= 57343 ? (h << 10) + c - 56613888 : h;
    }, ge.prototype.nextIndex = function(t, r) {
      r === void 0 && (r = false);
      var s = this.source, n = s.length;
      if (t >= n) return n;
      var h = s.charCodeAt(t), c;
      return !(r || this.switchU) || h <= 55295 || h >= 57344 || t + 1 >= n || (c = s.charCodeAt(t + 1)) < 56320 || c > 57343 ? t + 1 : t + 2;
    }, ge.prototype.current = function(t) {
      return t === void 0 && (t = false), this.at(this.pos, t);
    }, ge.prototype.lookahead = function(t) {
      return t === void 0 && (t = false), this.at(this.nextIndex(this.pos, t), t);
    }, ge.prototype.advance = function(t) {
      t === void 0 && (t = false), this.pos = this.nextIndex(this.pos, t);
    }, ge.prototype.eat = function(t, r) {
      return r === void 0 && (r = false), this.current(r) === t ? (this.advance(r), true) : false;
    }, N.validateRegExpFlags = function(e) {
      for (var t = e.validFlags, r = e.flags, s = 0; s < r.length; s++) {
        var n = r.charAt(s);
        t.indexOf(n) === -1 && this.raise(e.start, "Invalid regular expression flag"), r.indexOf(n, s + 1) > -1 && this.raise(e.start, "Duplicate regular expression flag");
      }
    }, N.validateRegExpPattern = function(e) {
      this.regexp_pattern(e), !e.switchN && this.options.ecmaVersion >= 9 && e.groupNames.length > 0 && (e.switchN = true, this.regexp_pattern(e));
    }, N.regexp_pattern = function(e) {
      e.pos = 0, e.lastIntValue = 0, e.lastStringValue = "", e.lastAssertionIsQuantifiable = false, e.numCapturingParens = 0, e.maxBackReference = 0, e.groupNames.length = 0, e.backReferenceNames.length = 0, this.regexp_disjunction(e), e.pos !== e.source.length && (e.eat(41) && e.raise("Unmatched ')'"), (e.eat(93) || e.eat(125)) && e.raise("Lone quantifier brackets")), e.maxBackReference > e.numCapturingParens && e.raise("Invalid escape");
      for (var t = 0, r = e.backReferenceNames; t < r.length; t += 1) {
        var s = r[t];
        e.groupNames.indexOf(s) === -1 && e.raise("Invalid named capture referenced");
      }
    }, N.regexp_disjunction = function(e) {
      for (this.regexp_alternative(e); e.eat(124); ) this.regexp_alternative(e);
      this.regexp_eatQuantifier(e, true) && e.raise("Nothing to repeat"), e.eat(123) && e.raise("Lone quantifier brackets");
    }, N.regexp_alternative = function(e) {
      for (; e.pos < e.source.length && this.regexp_eatTerm(e); ) ;
    }, N.regexp_eatTerm = function(e) {
      return this.regexp_eatAssertion(e) ? (e.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(e) && e.switchU && e.raise("Invalid quantifier"), true) : (e.switchU ? this.regexp_eatAtom(e) : this.regexp_eatExtendedAtom(e)) ? (this.regexp_eatQuantifier(e), true) : false;
    }, N.regexp_eatAssertion = function(e) {
      var t = e.pos;
      if (e.lastAssertionIsQuantifiable = false, e.eat(94) || e.eat(36)) return true;
      if (e.eat(92)) {
        if (e.eat(66) || e.eat(98)) return true;
        e.pos = t;
      }
      if (e.eat(40) && e.eat(63)) {
        var r = false;
        if (this.options.ecmaVersion >= 9 && (r = e.eat(60)), e.eat(61) || e.eat(33)) return this.regexp_disjunction(e), e.eat(41) || e.raise("Unterminated group"), e.lastAssertionIsQuantifiable = !r, true;
      }
      return e.pos = t, false;
    }, N.regexp_eatQuantifier = function(e, t) {
      return t === void 0 && (t = false), this.regexp_eatQuantifierPrefix(e, t) ? (e.eat(63), true) : false;
    }, N.regexp_eatQuantifierPrefix = function(e, t) {
      return e.eat(42) || e.eat(43) || e.eat(63) || this.regexp_eatBracedQuantifier(e, t);
    }, N.regexp_eatBracedQuantifier = function(e, t) {
      var r = e.pos;
      if (e.eat(123)) {
        var s = 0, n = -1;
        if (this.regexp_eatDecimalDigits(e) && (s = e.lastIntValue, e.eat(44) && this.regexp_eatDecimalDigits(e) && (n = e.lastIntValue), e.eat(125))) return n !== -1 && n < s && !t && e.raise("numbers out of order in {} quantifier"), true;
        e.switchU && !t && e.raise("Incomplete quantifier"), e.pos = r;
      }
      return false;
    }, N.regexp_eatAtom = function(e) {
      return this.regexp_eatPatternCharacters(e) || e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e);
    }, N.regexp_eatReverseSolidusAtomEscape = function(e) {
      var t = e.pos;
      if (e.eat(92)) {
        if (this.regexp_eatAtomEscape(e)) return true;
        e.pos = t;
      }
      return false;
    }, N.regexp_eatUncapturingGroup = function(e) {
      var t = e.pos;
      if (e.eat(40)) {
        if (e.eat(63) && e.eat(58)) {
          if (this.regexp_disjunction(e), e.eat(41)) return true;
          e.raise("Unterminated group");
        }
        e.pos = t;
      }
      return false;
    }, N.regexp_eatCapturingGroup = function(e) {
      if (e.eat(40)) {
        if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(e) : e.current() === 63 && e.raise("Invalid group"), this.regexp_disjunction(e), e.eat(41)) return e.numCapturingParens += 1, true;
        e.raise("Unterminated group");
      }
      return false;
    }, N.regexp_eatExtendedAtom = function(e) {
      return e.eat(46) || this.regexp_eatReverseSolidusAtomEscape(e) || this.regexp_eatCharacterClass(e) || this.regexp_eatUncapturingGroup(e) || this.regexp_eatCapturingGroup(e) || this.regexp_eatInvalidBracedQuantifier(e) || this.regexp_eatExtendedPatternCharacter(e);
    }, N.regexp_eatInvalidBracedQuantifier = function(e) {
      return this.regexp_eatBracedQuantifier(e, true) && e.raise("Nothing to repeat"), false;
    }, N.regexp_eatSyntaxCharacter = function(e) {
      var t = e.current();
      return Or2(t) ? (e.lastIntValue = t, e.advance(), true) : false;
    };
    function Or2(e) {
      return e === 36 || e >= 40 && e <= 43 || e === 46 || e === 63 || e >= 91 && e <= 94 || e >= 123 && e <= 125;
    }
    N.regexp_eatPatternCharacters = function(e) {
      for (var t = e.pos, r = 0; (r = e.current()) !== -1 && !Or2(r); ) e.advance();
      return e.pos !== t;
    }, N.regexp_eatExtendedPatternCharacter = function(e) {
      var t = e.current();
      return t !== -1 && t !== 36 && !(t >= 40 && t <= 43) && t !== 46 && t !== 63 && t !== 91 && t !== 94 && t !== 124 ? (e.advance(), true) : false;
    }, N.regexp_groupSpecifier = function(e) {
      if (e.eat(63)) {
        if (this.regexp_eatGroupName(e)) {
          e.groupNames.indexOf(e.lastStringValue) !== -1 && e.raise("Duplicate capture group name"), e.groupNames.push(e.lastStringValue);
          return;
        }
        e.raise("Invalid group");
      }
    }, N.regexp_eatGroupName = function(e) {
      if (e.lastStringValue = "", e.eat(60)) {
        if (this.regexp_eatRegExpIdentifierName(e) && e.eat(62)) return true;
        e.raise("Invalid capture group name");
      }
      return false;
    }, N.regexp_eatRegExpIdentifierName = function(e) {
      if (e.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(e)) {
        for (e.lastStringValue += C(e.lastIntValue); this.regexp_eatRegExpIdentifierPart(e); ) e.lastStringValue += C(e.lastIntValue);
        return true;
      }
      return false;
    }, N.regexp_eatRegExpIdentifierStart = function(e) {
      var t = e.pos, r = this.options.ecmaVersion >= 11, s = e.current(r);
      return e.advance(r), s === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, r) && (s = e.lastIntValue), sn2(s) ? (e.lastIntValue = s, true) : (e.pos = t, false);
    };
    function sn2(e) {
      return w(e, true) || e === 36 || e === 95;
    }
    N.regexp_eatRegExpIdentifierPart = function(e) {
      var t = e.pos, r = this.options.ecmaVersion >= 11, s = e.current(r);
      return e.advance(r), s === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(e, r) && (s = e.lastIntValue), an(s) ? (e.lastIntValue = s, true) : (e.pos = t, false);
    };
    function an(e) {
      return G(e, true) || e === 36 || e === 95 || e === 8204 || e === 8205;
    }
    N.regexp_eatAtomEscape = function(e) {
      return this.regexp_eatBackReference(e) || this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e) || e.switchN && this.regexp_eatKGroupName(e) ? true : (e.switchU && (e.current() === 99 && e.raise("Invalid unicode escape"), e.raise("Invalid escape")), false);
    }, N.regexp_eatBackReference = function(e) {
      var t = e.pos;
      if (this.regexp_eatDecimalEscape(e)) {
        var r = e.lastIntValue;
        if (e.switchU) return r > e.maxBackReference && (e.maxBackReference = r), true;
        if (r <= e.numCapturingParens) return true;
        e.pos = t;
      }
      return false;
    }, N.regexp_eatKGroupName = function(e) {
      if (e.eat(107)) {
        if (this.regexp_eatGroupName(e)) return e.backReferenceNames.push(e.lastStringValue), true;
        e.raise("Invalid named reference");
      }
      return false;
    }, N.regexp_eatCharacterEscape = function(e) {
      return this.regexp_eatControlEscape(e) || this.regexp_eatCControlLetter(e) || this.regexp_eatZero(e) || this.regexp_eatHexEscapeSequence(e) || this.regexp_eatRegExpUnicodeEscapeSequence(e, false) || !e.switchU && this.regexp_eatLegacyOctalEscapeSequence(e) || this.regexp_eatIdentityEscape(e);
    }, N.regexp_eatCControlLetter = function(e) {
      var t = e.pos;
      if (e.eat(99)) {
        if (this.regexp_eatControlLetter(e)) return true;
        e.pos = t;
      }
      return false;
    }, N.regexp_eatZero = function(e) {
      return e.current() === 48 && !Je(e.lookahead()) ? (e.lastIntValue = 0, e.advance(), true) : false;
    }, N.regexp_eatControlEscape = function(e) {
      var t = e.current();
      return t === 116 ? (e.lastIntValue = 9, e.advance(), true) : t === 110 ? (e.lastIntValue = 10, e.advance(), true) : t === 118 ? (e.lastIntValue = 11, e.advance(), true) : t === 102 ? (e.lastIntValue = 12, e.advance(), true) : t === 114 ? (e.lastIntValue = 13, e.advance(), true) : false;
    }, N.regexp_eatControlLetter = function(e) {
      var t = e.current();
      return Lr2(t) ? (e.lastIntValue = t % 32, e.advance(), true) : false;
    };
    function Lr2(e) {
      return e >= 65 && e <= 90 || e >= 97 && e <= 122;
    }
    N.regexp_eatRegExpUnicodeEscapeSequence = function(e, t) {
      t === void 0 && (t = false);
      var r = e.pos, s = t || e.switchU;
      if (e.eat(117)) {
        if (this.regexp_eatFixedHexDigits(e, 4)) {
          var n = e.lastIntValue;
          if (s && n >= 55296 && n <= 56319) {
            var h = e.pos;
            if (e.eat(92) && e.eat(117) && this.regexp_eatFixedHexDigits(e, 4)) {
              var c = e.lastIntValue;
              if (c >= 56320 && c <= 57343) return e.lastIntValue = (n - 55296) * 1024 + (c - 56320) + 65536, true;
            }
            e.pos = h, e.lastIntValue = n;
          }
          return true;
        }
        if (s && e.eat(123) && this.regexp_eatHexDigits(e) && e.eat(125) && nn(e.lastIntValue)) return true;
        s && e.raise("Invalid unicode escape"), e.pos = r;
      }
      return false;
    };
    function nn(e) {
      return e >= 0 && e <= 1114111;
    }
    N.regexp_eatIdentityEscape = function(e) {
      if (e.switchU) return this.regexp_eatSyntaxCharacter(e) ? true : e.eat(47) ? (e.lastIntValue = 47, true) : false;
      var t = e.current();
      return t !== 99 && (!e.switchN || t !== 107) ? (e.lastIntValue = t, e.advance(), true) : false;
    }, N.regexp_eatDecimalEscape = function(e) {
      e.lastIntValue = 0;
      var t = e.current();
      if (t >= 49 && t <= 57) {
        do
          e.lastIntValue = 10 * e.lastIntValue + (t - 48), e.advance();
        while ((t = e.current()) >= 48 && t <= 57);
        return true;
      }
      return false;
    }, N.regexp_eatCharacterClassEscape = function(e) {
      var t = e.current();
      if (un2(t)) return e.lastIntValue = -1, e.advance(), true;
      if (e.switchU && this.options.ecmaVersion >= 9 && (t === 80 || t === 112)) {
        if (e.lastIntValue = -1, e.advance(), e.eat(123) && this.regexp_eatUnicodePropertyValueExpression(e) && e.eat(125)) return true;
        e.raise("Invalid property name");
      }
      return false;
    };
    function un2(e) {
      return e === 100 || e === 68 || e === 115 || e === 83 || e === 119 || e === 87;
    }
    N.regexp_eatUnicodePropertyValueExpression = function(e) {
      var t = e.pos;
      if (this.regexp_eatUnicodePropertyName(e) && e.eat(61)) {
        var r = e.lastStringValue;
        if (this.regexp_eatUnicodePropertyValue(e)) {
          var s = e.lastStringValue;
          return this.regexp_validateUnicodePropertyNameAndValue(e, r, s), true;
        }
      }
      if (e.pos = t, this.regexp_eatLoneUnicodePropertyNameOrValue(e)) {
        var n = e.lastStringValue;
        return this.regexp_validateUnicodePropertyNameOrValue(e, n), true;
      }
      return false;
    }, N.regexp_validateUnicodePropertyNameAndValue = function(e, t, r) {
      P(e.unicodeProperties.nonBinary, t) || e.raise("Invalid property name"), e.unicodeProperties.nonBinary[t].test(r) || e.raise("Invalid property value");
    }, N.regexp_validateUnicodePropertyNameOrValue = function(e, t) {
      e.unicodeProperties.binary.test(t) || e.raise("Invalid property name");
    }, N.regexp_eatUnicodePropertyName = function(e) {
      var t = 0;
      for (e.lastStringValue = ""; Vr(t = e.current()); ) e.lastStringValue += C(t), e.advance();
      return e.lastStringValue !== "";
    };
    function Vr(e) {
      return Lr2(e) || e === 95;
    }
    N.regexp_eatUnicodePropertyValue = function(e) {
      var t = 0;
      for (e.lastStringValue = ""; on(t = e.current()); ) e.lastStringValue += C(t), e.advance();
      return e.lastStringValue !== "";
    };
    function on(e) {
      return Vr(e) || Je(e);
    }
    N.regexp_eatLoneUnicodePropertyNameOrValue = function(e) {
      return this.regexp_eatUnicodePropertyValue(e);
    }, N.regexp_eatCharacterClass = function(e) {
      if (e.eat(91)) {
        if (e.eat(94), this.regexp_classRanges(e), e.eat(93)) return true;
        e.raise("Unterminated character class");
      }
      return false;
    }, N.regexp_classRanges = function(e) {
      for (; this.regexp_eatClassAtom(e); ) {
        var t = e.lastIntValue;
        if (e.eat(45) && this.regexp_eatClassAtom(e)) {
          var r = e.lastIntValue;
          e.switchU && (t === -1 || r === -1) && e.raise("Invalid character class"), t !== -1 && r !== -1 && t > r && e.raise("Range out of order in character class");
        }
      }
    }, N.regexp_eatClassAtom = function(e) {
      var t = e.pos;
      if (e.eat(92)) {
        if (this.regexp_eatClassEscape(e)) return true;
        if (e.switchU) {
          var r = e.current();
          (r === 99 || qr(r)) && e.raise("Invalid class escape"), e.raise("Invalid escape");
        }
        e.pos = t;
      }
      var s = e.current();
      return s !== 93 ? (e.lastIntValue = s, e.advance(), true) : false;
    }, N.regexp_eatClassEscape = function(e) {
      var t = e.pos;
      if (e.eat(98)) return e.lastIntValue = 8, true;
      if (e.switchU && e.eat(45)) return e.lastIntValue = 45, true;
      if (!e.switchU && e.eat(99)) {
        if (this.regexp_eatClassControlLetter(e)) return true;
        e.pos = t;
      }
      return this.regexp_eatCharacterClassEscape(e) || this.regexp_eatCharacterEscape(e);
    }, N.regexp_eatClassControlLetter = function(e) {
      var t = e.current();
      return Je(t) || t === 95 ? (e.lastIntValue = t % 32, e.advance(), true) : false;
    }, N.regexp_eatHexEscapeSequence = function(e) {
      var t = e.pos;
      if (e.eat(120)) {
        if (this.regexp_eatFixedHexDigits(e, 2)) return true;
        e.switchU && e.raise("Invalid escape"), e.pos = t;
      }
      return false;
    }, N.regexp_eatDecimalDigits = function(e) {
      var t = e.pos, r = 0;
      for (e.lastIntValue = 0; Je(r = e.current()); ) e.lastIntValue = 10 * e.lastIntValue + (r - 48), e.advance();
      return e.pos !== t;
    };
    function Je(e) {
      return e >= 48 && e <= 57;
    }
    N.regexp_eatHexDigits = function(e) {
      var t = e.pos, r = 0;
      for (e.lastIntValue = 0; Rr(r = e.current()); ) e.lastIntValue = 16 * e.lastIntValue + jr2(r), e.advance();
      return e.pos !== t;
    };
    function Rr(e) {
      return e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102;
    }
    function jr2(e) {
      return e >= 65 && e <= 70 ? 10 + (e - 65) : e >= 97 && e <= 102 ? 10 + (e - 97) : e - 48;
    }
    N.regexp_eatLegacyOctalEscapeSequence = function(e) {
      if (this.regexp_eatOctalDigit(e)) {
        var t = e.lastIntValue;
        if (this.regexp_eatOctalDigit(e)) {
          var r = e.lastIntValue;
          t <= 3 && this.regexp_eatOctalDigit(e) ? e.lastIntValue = t * 64 + r * 8 + e.lastIntValue : e.lastIntValue = t * 8 + r;
        } else e.lastIntValue = t;
        return true;
      }
      return false;
    }, N.regexp_eatOctalDigit = function(e) {
      var t = e.current();
      return qr(t) ? (e.lastIntValue = t - 48, e.advance(), true) : (e.lastIntValue = 0, false);
    };
    function qr(e) {
      return e >= 48 && e <= 55;
    }
    N.regexp_eatFixedHexDigits = function(e, t) {
      var r = e.pos;
      e.lastIntValue = 0;
      for (var s = 0; s < t; ++s) {
        var n = e.current();
        if (!Rr(n)) return e.pos = r, false;
        e.lastIntValue = 16 * e.lastIntValue + jr2(n), e.advance();
      }
      return true;
    };
    var Qe = function(t) {
      this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, t.options.locations && (this.loc = new te2(t, t.startLoc, t.endLoc)), t.options.ranges && (this.range = [t.start, t.end]);
    }, z = Y.prototype;
    z.next = function(e) {
      !e && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Qe(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
    }, z.getToken = function() {
      return this.next(), new Qe(this);
    }, typeof Symbol < "u" && (z[Symbol.iterator] = function() {
      var e = this;
      return { next: function() {
        var t = e.getToken();
        return { done: t.type === i.eof, value: t };
      } };
    }), z.nextToken = function() {
      var e = this.curContext();
      if ((!e || !e.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length) return this.finishToken(i.eof);
      if (e.override) return e.override(this);
      this.readToken(this.fullCharCodeAtPos());
    }, z.readToken = function(e) {
      return w(e, this.options.ecmaVersion >= 6) || e === 92 ? this.readWord() : this.getTokenFromCode(e);
    }, z.fullCharCodeAtPos = function() {
      var e = this.input.charCodeAt(this.pos);
      if (e <= 55295 || e >= 56320) return e;
      var t = this.input.charCodeAt(this.pos + 1);
      return t <= 56319 || t >= 57344 ? e : (e << 10) + t - 56613888;
    }, z.skipBlockComment = function() {
      var e = this.options.onComment && this.curPosition(), t = this.pos, r = this.input.indexOf("*/", this.pos += 2);
      if (r === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations) for (var s = void 0, n = t; (s = Z(this.input, n, this.pos)) > -1; ) ++this.curLine, n = this.lineStart = s;
      this.options.onComment && this.options.onComment(true, this.input.slice(t + 2, r), t, this.pos, e, this.curPosition());
    }, z.skipLineComment = function(e) {
      for (var t = this.pos, r = this.options.onComment && this.curPosition(), s = this.input.charCodeAt(this.pos += e); this.pos < this.input.length && !j(s); ) s = this.input.charCodeAt(++this.pos);
      this.options.onComment && this.options.onComment(false, this.input.slice(t + e, this.pos), t, this.pos, r, this.curPosition());
    }, z.skipSpace = function() {
      e: for (; this.pos < this.input.length; ) {
        var e = this.input.charCodeAt(this.pos);
        switch (e) {
          case 32:
          case 160:
            ++this.pos;
            break;
          case 13:
            this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
            break;
          case 47:
            switch (this.input.charCodeAt(this.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;
              case 47:
                this.skipLineComment(2);
                break;
              default:
                break e;
            }
            break;
          default:
            if (e > 8 && e < 14 || e >= 5760 && ne2.test(String.fromCharCode(e))) ++this.pos;
            else break e;
        }
      }
    }, z.finishToken = function(e, t) {
      this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
      var r = this.type;
      this.type = e, this.value = t, this.updateContext(r);
    }, z.readToken_dot = function() {
      var e = this.input.charCodeAt(this.pos + 1);
      if (e >= 48 && e <= 57) return this.readNumber(true);
      var t = this.input.charCodeAt(this.pos + 2);
      return this.options.ecmaVersion >= 6 && e === 46 && t === 46 ? (this.pos += 3, this.finishToken(i.ellipsis)) : (++this.pos, this.finishToken(i.dot));
    }, z.readToken_slash = function() {
      var e = this.input.charCodeAt(this.pos + 1);
      return this.exprAllowed ? (++this.pos, this.readRegexp()) : e === 61 ? this.finishOp(i.assign, 2) : this.finishOp(i.slash, 1);
    }, z.readToken_mult_modulo_exp = function(e) {
      var t = this.input.charCodeAt(this.pos + 1), r = 1, s = e === 42 ? i.star : i.modulo;
      return this.options.ecmaVersion >= 7 && e === 42 && t === 42 && (++r, s = i.starstar, t = this.input.charCodeAt(this.pos + 2)), t === 61 ? this.finishOp(i.assign, r + 1) : this.finishOp(s, r);
    }, z.readToken_pipe_amp = function(e) {
      var t = this.input.charCodeAt(this.pos + 1);
      if (t === e) {
        if (this.options.ecmaVersion >= 12) {
          var r = this.input.charCodeAt(this.pos + 2);
          if (r === 61) return this.finishOp(i.assign, 3);
        }
        return this.finishOp(e === 124 ? i.logicalOR : i.logicalAND, 2);
      }
      return t === 61 ? this.finishOp(i.assign, 2) : this.finishOp(e === 124 ? i.bitwiseOR : i.bitwiseAND, 1);
    }, z.readToken_caret = function() {
      var e = this.input.charCodeAt(this.pos + 1);
      return e === 61 ? this.finishOp(i.assign, 2) : this.finishOp(i.bitwiseXOR, 1);
    }, z.readToken_plus_min = function(e) {
      var t = this.input.charCodeAt(this.pos + 1);
      return t === e ? t === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || S.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(i.incDec, 2) : t === 61 ? this.finishOp(i.assign, 2) : this.finishOp(i.plusMin, 1);
    }, z.readToken_lt_gt = function(e) {
      var t = this.input.charCodeAt(this.pos + 1), r = 1;
      return t === e ? (r = e === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.finishOp(i.assign, r + 1) : this.finishOp(i.bitShift, r)) : t === 33 && e === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (t === 61 && (r = 2), this.finishOp(i.relational, r));
    }, z.readToken_eq_excl = function(e) {
      var t = this.input.charCodeAt(this.pos + 1);
      return t === 61 ? this.finishOp(i.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : e === 61 && t === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(i.arrow)) : this.finishOp(e === 61 ? i.eq : i.prefix, 1);
    }, z.readToken_question = function() {
      var e = this.options.ecmaVersion;
      if (e >= 11) {
        var t = this.input.charCodeAt(this.pos + 1);
        if (t === 46) {
          var r = this.input.charCodeAt(this.pos + 2);
          if (r < 48 || r > 57) return this.finishOp(i.questionDot, 2);
        }
        if (t === 63) {
          if (e >= 12) {
            var s = this.input.charCodeAt(this.pos + 2);
            if (s === 61) return this.finishOp(i.assign, 3);
          }
          return this.finishOp(i.coalesce, 2);
        }
      }
      return this.finishOp(i.question, 1);
    }, z.readToken_numberSign = function() {
      var e = this.options.ecmaVersion, t = 35;
      if (e >= 13 && (++this.pos, t = this.fullCharCodeAtPos(), w(t, true) || t === 92)) return this.finishToken(i.privateId, this.readWord1());
      this.raise(this.pos, "Unexpected character '" + C(t) + "'");
    }, z.getTokenFromCode = function(e) {
      switch (e) {
        case 46:
          return this.readToken_dot();
        case 40:
          return ++this.pos, this.finishToken(i.parenL);
        case 41:
          return ++this.pos, this.finishToken(i.parenR);
        case 59:
          return ++this.pos, this.finishToken(i.semi);
        case 44:
          return ++this.pos, this.finishToken(i.comma);
        case 91:
          return ++this.pos, this.finishToken(i.bracketL);
        case 93:
          return ++this.pos, this.finishToken(i.bracketR);
        case 123:
          return ++this.pos, this.finishToken(i.braceL);
        case 125:
          return ++this.pos, this.finishToken(i.braceR);
        case 58:
          return ++this.pos, this.finishToken(i.colon);
        case 96:
          if (this.options.ecmaVersion < 6) break;
          return ++this.pos, this.finishToken(i.backQuote);
        case 48:
          var t = this.input.charCodeAt(this.pos + 1);
          if (t === 120 || t === 88) return this.readRadixNumber(16);
          if (this.options.ecmaVersion >= 6) {
            if (t === 111 || t === 79) return this.readRadixNumber(8);
            if (t === 98 || t === 66) return this.readRadixNumber(2);
          }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          return this.readNumber(false);
        case 34:
        case 39:
          return this.readString(e);
        case 47:
          return this.readToken_slash();
        case 37:
        case 42:
          return this.readToken_mult_modulo_exp(e);
        case 124:
        case 38:
          return this.readToken_pipe_amp(e);
        case 94:
          return this.readToken_caret();
        case 43:
        case 45:
          return this.readToken_plus_min(e);
        case 60:
        case 62:
          return this.readToken_lt_gt(e);
        case 61:
        case 33:
          return this.readToken_eq_excl(e);
        case 63:
          return this.readToken_question();
        case 126:
          return this.finishOp(i.prefix, 1);
        case 35:
          return this.readToken_numberSign();
      }
      this.raise(this.pos, "Unexpected character '" + C(e) + "'");
    }, z.finishOp = function(e, t) {
      var r = this.input.slice(this.pos, this.pos + t);
      return this.pos += t, this.finishToken(e, r);
    }, z.readRegexp = function() {
      for (var e, t, r = this.pos; ; ) {
        this.pos >= this.input.length && this.raise(r, "Unterminated regular expression");
        var s = this.input.charAt(this.pos);
        if (S.test(s) && this.raise(r, "Unterminated regular expression"), e) e = false;
        else {
          if (s === "[") t = true;
          else if (s === "]" && t) t = false;
          else if (s === "/" && !t) break;
          e = s === "\\";
        }
        ++this.pos;
      }
      var n = this.input.slice(r, this.pos);
      ++this.pos;
      var h = this.pos, c = this.readWord1();
      this.containsEsc && this.unexpected(h);
      var m = this.regexpState || (this.regexpState = new ge(this));
      m.reset(r, n, c), this.validateRegExpFlags(m), this.validateRegExpPattern(m);
      var A = null;
      try {
        A = new RegExp(n, c);
      } catch {
      }
      return this.finishToken(i.regexp, { pattern: n, flags: c, value: A });
    }, z.readInt = function(e, t, r) {
      for (var s = this.options.ecmaVersion >= 12 && t === void 0, n = r && this.input.charCodeAt(this.pos) === 48, h = this.pos, c = 0, m = 0, A = 0, q = t == null ? 1 / 0 : t; A < q; ++A, ++this.pos) {
        var W = this.input.charCodeAt(this.pos), re = void 0;
        if (s && W === 95) {
          n && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), m === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), A === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), m = W;
          continue;
        }
        if (W >= 97 ? re = W - 97 + 10 : W >= 65 ? re = W - 65 + 10 : W >= 48 && W <= 57 ? re = W - 48 : re = 1 / 0, re >= e) break;
        m = W, c = c * e + re;
      }
      return s && m === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === h || t != null && this.pos - h !== t ? null : c;
    };
    function hn(e, t) {
      return t ? parseInt(e, 8) : parseFloat(e.replace(/_/g, ""));
    }
    function Mr(e) {
      return typeof BigInt != "function" ? null : BigInt(e.replace(/_/g, ""));
    }
    z.readRadixNumber = function(e) {
      var t = this.pos;
      this.pos += 2;
      var r = this.readInt(e);
      return r == null && this.raise(this.start + 2, "Expected number in radix " + e), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (r = Mr(this.input.slice(t, this.pos)), ++this.pos) : w(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(i.num, r);
    }, z.readNumber = function(e) {
      var t = this.pos;
      !e && this.readInt(10, void 0, true) === null && this.raise(t, "Invalid number");
      var r = this.pos - t >= 2 && this.input.charCodeAt(t) === 48;
      r && this.strict && this.raise(t, "Invalid number");
      var s = this.input.charCodeAt(this.pos);
      if (!r && !e && this.options.ecmaVersion >= 11 && s === 110) {
        var n = Mr(this.input.slice(t, this.pos));
        return ++this.pos, w(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(i.num, n);
      }
      r && /[89]/.test(this.input.slice(t, this.pos)) && (r = false), s === 46 && !r && (++this.pos, this.readInt(10), s = this.input.charCodeAt(this.pos)), (s === 69 || s === 101) && !r && (s = this.input.charCodeAt(++this.pos), (s === 43 || s === 45) && ++this.pos, this.readInt(10) === null && this.raise(t, "Invalid number")), w(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
      var h = hn(this.input.slice(t, this.pos), r);
      return this.finishToken(i.num, h);
    }, z.readCodePoint = function() {
      var e = this.input.charCodeAt(this.pos), t;
      if (e === 123) {
        this.options.ecmaVersion < 6 && this.unexpected();
        var r = ++this.pos;
        t = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, t > 1114111 && this.invalidStringToken(r, "Code point out of bounds");
      } else t = this.readHexChar(4);
      return t;
    }, z.readString = function(e) {
      for (var t = "", r = ++this.pos; ; ) {
        this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
        var s = this.input.charCodeAt(this.pos);
        if (s === e) break;
        s === 92 ? (t += this.input.slice(r, this.pos), t += this.readEscapedChar(false), r = this.pos) : s === 8232 || s === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (j(s) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
      }
      return t += this.input.slice(r, this.pos++), this.finishToken(i.string, t);
    };
    var Ur = {};
    z.tryReadTemplateToken = function() {
      this.inTemplateElement = true;
      try {
        this.readTmplToken();
      } catch (e) {
        if (e === Ur) this.readInvalidTemplateToken();
        else throw e;
      }
      this.inTemplateElement = false;
    }, z.invalidStringToken = function(e, t) {
      if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw Ur;
      this.raise(e, t);
    }, z.readTmplToken = function() {
      for (var e = "", t = this.pos; ; ) {
        this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
        var r = this.input.charCodeAt(this.pos);
        if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123) return this.pos === this.start && (this.type === i.template || this.type === i.invalidTemplate) ? r === 36 ? (this.pos += 2, this.finishToken(i.dollarBraceL)) : (++this.pos, this.finishToken(i.backQuote)) : (e += this.input.slice(t, this.pos), this.finishToken(i.template, e));
        if (r === 92) e += this.input.slice(t, this.pos), e += this.readEscapedChar(true), t = this.pos;
        else if (j(r)) {
          switch (e += this.input.slice(t, this.pos), ++this.pos, r) {
            case 13:
              this.input.charCodeAt(this.pos) === 10 && ++this.pos;
            case 10:
              e += `
`;
              break;
            default:
              e += String.fromCharCode(r);
              break;
          }
          this.options.locations && (++this.curLine, this.lineStart = this.pos), t = this.pos;
        } else ++this.pos;
      }
    }, z.readInvalidTemplateToken = function() {
      for (; this.pos < this.input.length; this.pos++) switch (this.input[this.pos]) {
        case "\\":
          ++this.pos;
          break;
        case "$":
          if (this.input[this.pos + 1] !== "{") break;
        case "`":
          return this.finishToken(i.invalidTemplate, this.input.slice(this.start, this.pos));
      }
      this.raise(this.start, "Unterminated template");
    }, z.readEscapedChar = function(e) {
      var t = this.input.charCodeAt(++this.pos);
      switch (++this.pos, t) {
        case 110:
          return `
`;
        case 114:
          return "\r";
        case 120:
          return String.fromCharCode(this.readHexChar(2));
        case 117:
          return C(this.readCodePoint());
        case 116:
          return "	";
        case 98:
          return "\b";
        case 118:
          return "\v";
        case 102:
          return "\f";
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
        case 56:
        case 57:
          if (this.strict && this.invalidStringToken(this.pos - 1, "Invalid escape sequence"), e) {
            var r = this.pos - 1;
            return this.invalidStringToken(r, "Invalid escape sequence in template string"), null;
          }
        default:
          if (t >= 48 && t <= 55) {
            var s = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], n = parseInt(s, 8);
            return n > 255 && (s = s.slice(0, -1), n = parseInt(s, 8)), this.pos += s.length - 1, t = this.input.charCodeAt(this.pos), (s !== "0" || t === 56 || t === 57) && (this.strict || e) && this.invalidStringToken(this.pos - 1 - s.length, e ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(n);
          }
          return j(t) ? "" : String.fromCharCode(t);
      }
    }, z.readHexChar = function(e) {
      var t = this.pos, r = this.readInt(16, e);
      return r === null && this.invalidStringToken(t, "Bad character escape sequence"), r;
    }, z.readWord1 = function() {
      this.containsEsc = false;
      for (var e = "", t = true, r = this.pos, s = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
        var n = this.fullCharCodeAtPos();
        if (G(n, s)) this.pos += n <= 65535 ? 1 : 2;
        else if (n === 92) {
          this.containsEsc = true, e += this.input.slice(r, this.pos);
          var h = this.pos;
          this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
          var c = this.readCodePoint();
          (t ? w : G)(c, s) || this.invalidStringToken(h, "Invalid Unicode escape"), e += C(c), r = this.pos;
        } else break;
        t = false;
      }
      return e + this.input.slice(r, this.pos);
    }, z.readWord = function() {
      var e = this.readWord1(), t = i.name;
      return this.keywords.test(e) && (t = X[e]), this.finishToken(t, e);
    };
    var Wr2 = "8.8.1";
    Y.acorn = { Parser: Y, version: Wr2, defaultOptions: fe, Position: H, SourceLocation: te2, getLineInfo: ae, Node: Re, TokenType: f, tokTypes: i, keywordTypes: X, TokContext: ue, tokContexts: $2, isIdentifierChar: G, isIdentifierStart: w, Token: Qe, isNewLine: j, lineBreak: S, lineBreakG: F, nonASCIIwhitespace: ne2 };
    function ln(e, t) {
      return Y.parse(e, t);
    }
    function cn(e, t, r) {
      return Y.parseExpressionAt(e, t, r);
    }
    function pn2(e, t) {
      return Y.tokenizer(e, t);
    }
    o.Node = Re, o.Parser = Y, o.Position = H, o.SourceLocation = te2, o.TokContext = ue, o.Token = Qe, o.TokenType = f, o.defaultOptions = fe, o.getLineInfo = ae, o.isIdentifierChar = G, o.isIdentifierStart = w, o.isNewLine = j, o.keywordTypes = X, o.lineBreak = S, o.lineBreakG = F, o.nonASCIIwhitespace = ne2, o.parse = ln, o.parseExpressionAt = cn, o.tokContexts = $2, o.tokTypes = i, o.tokenizer = pn2, o.version = Wr2, Object.defineProperty(o, "__esModule", { value: true });
  });
} });
var Wh = Q({ "node_modules/acorn-jsx/xhtml.js"(a, u) {
  J(), u.exports = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" };
} });
var za2 = Q({ "node_modules/acorn-jsx/index.js"(a, u) {
  "use strict";
  J();
  var o = Wh(), l = /^[\da-fA-F]+$/, v = /^\d+$/, b = /* @__PURE__ */ new WeakMap();
  function y(x) {
    x = x.Parser.acorn || x;
    let R = b.get(x);
    if (!R) {
      let U = x.tokTypes, D = x.TokContext, g = x.TokenType, w = new D("<tag", false), G = new D("</tag", false), f = new D("<tag>...</tag>", true, true), B = { tc_oTag: w, tc_cTag: G, tc_expr: f }, V = { jsxName: new g("jsxName"), jsxText: new g("jsxText", { beforeExpr: true }), jsxTagStart: new g("jsxTagStart", { startsExpr: true }), jsxTagEnd: new g("jsxTagEnd") };
      V.jsxTagStart.updateContext = function() {
        this.context.push(f), this.context.push(w), this.exprAllowed = false;
      }, V.jsxTagEnd.updateContext = function(k) {
        let X = this.context.pop();
        X === w && k === U.slash || X === G ? (this.context.pop(), this.exprAllowed = this.curContext() === f) : this.exprAllowed = true;
      }, R = { tokContexts: B, tokTypes: V }, b.set(x, R);
    }
    return R;
  }
  function I(x) {
    if (!x) return x;
    if (x.type === "JSXIdentifier") return x.name;
    if (x.type === "JSXNamespacedName") return x.namespace.name + ":" + x.name.name;
    if (x.type === "JSXMemberExpression") return I(x.object) + "." + I(x.property);
  }
  u.exports = function(x) {
    return x = x || {}, function(R) {
      return T({ allowNamespaces: x.allowNamespaces !== false, allowNamespacedObjects: !!x.allowNamespacedObjects }, R);
    };
  }, Object.defineProperty(u.exports, "tokTypes", { get: function() {
    return y(ft2()).tokTypes;
  }, configurable: true, enumerable: true });
  function T(x, R) {
    let U = R.acorn || ft2(), D = y(U), g = U.tokTypes, w = D.tokTypes, G = U.tokContexts, f = D.tokContexts.tc_oTag, B = D.tokContexts.tc_cTag, V = D.tokContexts.tc_expr, k = U.isNewLine, X = U.isIdentifierStart, O = U.isIdentifierChar;
    return class extends R {
      static get acornJsx() {
        return D;
      }
      jsx_readToken() {
        let i = "", S = this.pos;
        for (; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
          let F = this.input.charCodeAt(this.pos);
          switch (F) {
            case 60:
            case 123:
              return this.pos === this.start ? F === 60 && this.exprAllowed ? (++this.pos, this.finishToken(w.jsxTagStart)) : this.getTokenFromCode(F) : (i += this.input.slice(S, this.pos), this.finishToken(w.jsxText, i));
            case 38:
              i += this.input.slice(S, this.pos), i += this.jsx_readEntity(), S = this.pos;
              break;
            case 62:
            case 125:
              this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (F === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?');
            default:
              k(F) ? (i += this.input.slice(S, this.pos), i += this.jsx_readNewLine(true), S = this.pos) : ++this.pos;
          }
        }
      }
      jsx_readNewLine(i) {
        let S = this.input.charCodeAt(this.pos), F;
        return ++this.pos, S === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, F = i ? `
` : `\r
`) : F = String.fromCharCode(S), this.options.locations && (++this.curLine, this.lineStart = this.pos), F;
      }
      jsx_readString(i) {
        let S = "", F = ++this.pos;
        for (; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          let j = this.input.charCodeAt(this.pos);
          if (j === i) break;
          j === 38 ? (S += this.input.slice(F, this.pos), S += this.jsx_readEntity(), F = this.pos) : k(j) ? (S += this.input.slice(F, this.pos), S += this.jsx_readNewLine(false), F = this.pos) : ++this.pos;
        }
        return S += this.input.slice(F, this.pos++), this.finishToken(g.string, S);
      }
      jsx_readEntity() {
        let i = "", S = 0, F, j = this.input[this.pos];
        j !== "&" && this.raise(this.pos, "Entity must start with an ampersand");
        let Z = ++this.pos;
        for (; this.pos < this.input.length && S++ < 10; ) {
          if (j = this.input[this.pos++], j === ";") {
            i[0] === "#" ? i[1] === "x" ? (i = i.substr(2), l.test(i) && (F = String.fromCharCode(parseInt(i, 16)))) : (i = i.substr(1), v.test(i) && (F = String.fromCharCode(parseInt(i, 10)))) : F = o[i];
            break;
          }
          i += j;
        }
        return F || (this.pos = Z, "&");
      }
      jsx_readWord() {
        let i, S = this.pos;
        do
          i = this.input.charCodeAt(++this.pos);
        while (O(i) || i === 45);
        return this.finishToken(w.jsxName, this.input.slice(S, this.pos));
      }
      jsx_parseIdentifier() {
        let i = this.startNode();
        return this.type === w.jsxName ? i.name = this.value : this.type.keyword ? i.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(i, "JSXIdentifier");
      }
      jsx_parseNamespacedName() {
        let i = this.start, S = this.startLoc, F = this.jsx_parseIdentifier();
        if (!x.allowNamespaces || !this.eat(g.colon)) return F;
        var j = this.startNodeAt(i, S);
        return j.namespace = F, j.name = this.jsx_parseIdentifier(), this.finishNode(j, "JSXNamespacedName");
      }
      jsx_parseElementName() {
        if (this.type === w.jsxTagEnd) return "";
        let i = this.start, S = this.startLoc, F = this.jsx_parseNamespacedName();
        for (this.type === g.dot && F.type === "JSXNamespacedName" && !x.allowNamespacedObjects && this.unexpected(); this.eat(g.dot); ) {
          let j = this.startNodeAt(i, S);
          j.object = F, j.property = this.jsx_parseIdentifier(), F = this.finishNode(j, "JSXMemberExpression");
        }
        return F;
      }
      jsx_parseAttributeValue() {
        switch (this.type) {
          case g.braceL:
            let i = this.jsx_parseExpressionContainer();
            return i.expression.type === "JSXEmptyExpression" && this.raise(i.start, "JSX attributes must only be assigned a non-empty expression"), i;
          case w.jsxTagStart:
          case g.string:
            return this.parseExprAtom();
          default:
            this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
        }
      }
      jsx_parseEmptyExpression() {
        let i = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
        return this.finishNodeAt(i, "JSXEmptyExpression", this.start, this.startLoc);
      }
      jsx_parseExpressionContainer() {
        let i = this.startNode();
        return this.next(), i.expression = this.type === g.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(g.braceR), this.finishNode(i, "JSXExpressionContainer");
      }
      jsx_parseAttribute() {
        let i = this.startNode();
        return this.eat(g.braceL) ? (this.expect(g.ellipsis), i.argument = this.parseMaybeAssign(), this.expect(g.braceR), this.finishNode(i, "JSXSpreadAttribute")) : (i.name = this.jsx_parseNamespacedName(), i.value = this.eat(g.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(i, "JSXAttribute"));
      }
      jsx_parseOpeningElementAt(i, S) {
        let F = this.startNodeAt(i, S);
        F.attributes = [];
        let j = this.jsx_parseElementName();
        for (j && (F.name = j); this.type !== g.slash && this.type !== w.jsxTagEnd; ) F.attributes.push(this.jsx_parseAttribute());
        return F.selfClosing = this.eat(g.slash), this.expect(w.jsxTagEnd), this.finishNode(F, j ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      jsx_parseClosingElementAt(i, S) {
        let F = this.startNodeAt(i, S), j = this.jsx_parseElementName();
        return j && (F.name = j), this.expect(w.jsxTagEnd), this.finishNode(F, j ? "JSXClosingElement" : "JSXClosingFragment");
      }
      jsx_parseElementAt(i, S) {
        let F = this.startNodeAt(i, S), j = [], Z = this.jsx_parseOpeningElementAt(i, S), ne2 = null;
        if (!Z.selfClosing) {
          e: for (; ; ) switch (this.type) {
            case w.jsxTagStart:
              if (i = this.start, S = this.startLoc, this.next(), this.eat(g.slash)) {
                ne2 = this.jsx_parseClosingElementAt(i, S);
                break e;
              }
              j.push(this.jsx_parseElementAt(i, S));
              break;
            case w.jsxText:
              j.push(this.parseExprAtom());
              break;
            case g.braceL:
              j.push(this.jsx_parseExpressionContainer());
              break;
            default:
              this.unexpected();
          }
          I(ne2.name) !== I(Z.name) && this.raise(ne2.start, "Expected corresponding JSX closing tag for <" + I(Z.name) + ">");
        }
        let ee = Z.name ? "Element" : "Fragment";
        return F["opening" + ee] = Z, F["closing" + ee] = ne2, F.children = j, this.type === g.relational && this.value === "<" && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(F, "JSX" + ee);
      }
      jsx_parseText() {
        let i = this.parseLiteral(this.value);
        return i.type = "JSXText", i;
      }
      jsx_parseElement() {
        let i = this.start, S = this.startLoc;
        return this.next(), this.jsx_parseElementAt(i, S);
      }
      parseExprAtom(i) {
        return this.type === w.jsxText ? this.jsx_parseText() : this.type === w.jsxTagStart ? this.jsx_parseElement() : super.parseExprAtom(i);
      }
      readToken(i) {
        let S = this.curContext();
        if (S === V) return this.jsx_readToken();
        if (S === f || S === B) {
          if (X(i)) return this.jsx_readWord();
          if (i == 62) return ++this.pos, this.finishToken(w.jsxTagEnd);
          if ((i === 34 || i === 39) && S == f) return this.jsx_readString(i);
        }
        return i === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(w.jsxTagStart)) : super.readToken(i);
      }
      updateContext(i) {
        if (this.type == g.braceL) {
          var S = this.curContext();
          S == f ? this.context.push(G.b_expr) : S == V ? this.context.push(G.b_tmpl) : super.updateContext(i), this.exprAllowed = true;
        } else if (this.type === g.slash && i === w.jsxTagStart) this.context.length -= 2, this.context.push(B), this.exprAllowed = false;
        else return super.updateContext(i);
      }
    };
  }
} });
var zh = Q({ "src/language-js/parse/acorn.js"(a, u) {
  "use strict";
  J();
  var o = dr2(), l = ka2(), v = Ua2(), b = Wa2(), y = { ecmaVersion: "latest", sourceType: "module", allowReserved: true, allowReturnOutsideFunction: true, allowImportExportEverywhere: true, allowAwaitOutsideFunction: true, allowSuperOutsideMethod: true, allowHashBang: true, locations: true, ranges: true };
  function I(D) {
    let { message: g, loc: w } = D;
    if (!w) return D;
    let { line: G, column: f } = w;
    return o(g.replace(/ \(\d+:\d+\)$/, ""), { start: { line: G, column: f + 1 } });
  }
  var T, x = () => {
    if (!T) {
      let { Parser: D } = ft2(), g = za2();
      T = D.extend(g());
    }
    return T;
  };
  function R(D, g) {
    let w = x(), G = [], f = [], B = w.parse(D, Object.assign(Object.assign({}, y), {}, { sourceType: g, onComment: G, onToken: f }));
    return B.comments = G, B.tokens = f, B;
  }
  function U(D, g) {
    let w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, { result: G, error: f } = l(() => R(D, "module"), () => R(D, "script"));
    if (!G) throw I(f);
    return w.originalText = D, b(G, w);
  }
  u.exports = v(U);
} });
var Gh = Q({ "src/language-js/parse/utils/replace-hashbang.js"(a, u) {
  "use strict";
  J();
  function o(l) {
    return l.charAt(0) === "#" && l.charAt(1) === "!" ? "//" + l.slice(2) : l;
  }
  u.exports = o;
} });
var Hh = Q({ "node_modules/espree/dist/espree.cjs"(a) {
  "use strict";
  J(), Object.defineProperty(a, "__esModule", { value: true });
  var u = ft2(), o = za2(), l;
  function v(p) {
    return p && typeof p == "object" && "default" in p ? p : { default: p };
  }
  function b(p) {
    if (p && p.__esModule) return p;
    var P = /* @__PURE__ */ Object.create(null);
    return p && Object.keys(p).forEach(function(_) {
      if (_ !== "default") {
        var d = Object.getOwnPropertyDescriptor(p, _);
        Object.defineProperty(P, _, d.get ? d : { enumerable: true, get: function() {
          return p[_];
        } });
      }
    }), P.default = p, Object.freeze(P);
  }
  var y = b(u), I = v(o), T = b(l), x = { Boolean: "Boolean", EOF: "<end>", Identifier: "Identifier", PrivateIdentifier: "PrivateIdentifier", Keyword: "Keyword", Null: "Null", Numeric: "Numeric", Punctuator: "Punctuator", String: "String", RegularExpression: "RegularExpression", Template: "Template", JSXIdentifier: "JSXIdentifier", JSXText: "JSXText" };
  function R(p, P) {
    let _ = p[0], d = p[p.length - 1], C = { type: x.Template, value: P.slice(_.start, d.end) };
    return _.loc && (C.loc = { start: _.loc.start, end: d.loc.end }), _.range && (C.start = _.range[0], C.end = d.range[1], C.range = [C.start, C.end]), C;
  }
  function U(p, P) {
    this._acornTokTypes = p, this._tokens = [], this._curlyBrace = null, this._code = P;
  }
  U.prototype = { constructor: U, translate(p, P) {
    let _ = p.type, d = this._acornTokTypes;
    if (_ === d.name) p.type = x.Identifier, p.value === "static" && (p.type = x.Keyword), P.ecmaVersion > 5 && (p.value === "yield" || p.value === "let") && (p.type = x.Keyword);
    else if (_ === d.privateId) p.type = x.PrivateIdentifier;
    else if (_ === d.semi || _ === d.comma || _ === d.parenL || _ === d.parenR || _ === d.braceL || _ === d.braceR || _ === d.dot || _ === d.bracketL || _ === d.colon || _ === d.question || _ === d.bracketR || _ === d.ellipsis || _ === d.arrow || _ === d.jsxTagStart || _ === d.incDec || _ === d.starstar || _ === d.jsxTagEnd || _ === d.prefix || _ === d.questionDot || _.binop && !_.keyword || _.isAssign) p.type = x.Punctuator, p.value = this._code.slice(p.start, p.end);
    else if (_ === d.jsxName) p.type = x.JSXIdentifier;
    else if (_.label === "jsxText" || _ === d.jsxAttrValueToken) p.type = x.JSXText;
    else if (_.keyword) _.keyword === "true" || _.keyword === "false" ? p.type = x.Boolean : _.keyword === "null" ? p.type = x.Null : p.type = x.Keyword;
    else if (_ === d.num) p.type = x.Numeric, p.value = this._code.slice(p.start, p.end);
    else if (_ === d.string) P.jsxAttrValueToken ? (P.jsxAttrValueToken = false, p.type = x.JSXText) : p.type = x.String, p.value = this._code.slice(p.start, p.end);
    else if (_ === d.regexp) {
      p.type = x.RegularExpression;
      let C = p.value;
      p.regex = { flags: C.flags, pattern: C.pattern }, p.value = `/${C.pattern}/${C.flags}`;
    }
    return p;
  }, onToken(p, P) {
    let _ = this, d = this._acornTokTypes, C = P.tokens, K = this._tokens;
    function H() {
      C.push(R(_._tokens, _._code)), _._tokens = [];
    }
    if (p.type === d.eof) {
      this._curlyBrace && C.push(this.translate(this._curlyBrace, P));
      return;
    }
    if (p.type === d.backQuote) {
      this._curlyBrace && (C.push(this.translate(this._curlyBrace, P)), this._curlyBrace = null), K.push(p), K.length > 1 && H();
      return;
    }
    if (p.type === d.dollarBraceL) {
      K.push(p), H();
      return;
    }
    if (p.type === d.braceR) {
      this._curlyBrace && C.push(this.translate(this._curlyBrace, P)), this._curlyBrace = p;
      return;
    }
    if (p.type === d.template || p.type === d.invalidTemplate) {
      this._curlyBrace && (K.push(this._curlyBrace), this._curlyBrace = null), K.push(p);
      return;
    }
    this._curlyBrace && (C.push(this.translate(this._curlyBrace, P)), this._curlyBrace = null), C.push(this.translate(p, P));
  } };
  var D = [3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
  function g() {
    return D[D.length - 1];
  }
  function w() {
    return [...D];
  }
  function G() {
    let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5, P = p === "latest" ? g() : p;
    if (typeof P != "number") throw new Error(`ecmaVersion must be a number or "latest". Received value of type ${typeof p} instead.`);
    if (P >= 2015 && (P -= 2009), !D.includes(P)) throw new Error("Invalid ecmaVersion.");
    return P;
  }
  function f() {
    let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "script";
    if (p === "script" || p === "module") return p;
    if (p === "commonjs") return "script";
    throw new Error("Invalid sourceType.");
  }
  function B(p) {
    let P = G(p.ecmaVersion), _ = f(p.sourceType), d = p.range === true, C = p.loc === true;
    if (P !== 3 && p.allowReserved) throw new Error("`allowReserved` is only supported when ecmaVersion is 3");
    if (typeof p.allowReserved < "u" && typeof p.allowReserved != "boolean") throw new Error("`allowReserved`, when present, must be `true` or `false`");
    let K = P === 3 ? p.allowReserved || "never" : false, H = p.ecmaFeatures || {}, te2 = p.sourceType === "commonjs" || Boolean(H.globalReturn);
    if (_ === "module" && P < 6) throw new Error("sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.");
    return Object.assign({}, p, { ecmaVersion: P, sourceType: _, ranges: d, locations: C, allowReserved: K, allowReturnOutsideFunction: te2 });
  }
  var V = Symbol("espree's internal state"), k = Symbol("espree's esprimaFinishNode");
  function X(p, P, _, d, C, K, H) {
    let te2;
    p ? te2 = "Block" : H.slice(_, _ + 2) === "#!" ? te2 = "Hashbang" : te2 = "Line";
    let ae = { type: te2, value: P };
    return typeof _ == "number" && (ae.start = _, ae.end = d, ae.range = [_, d]), typeof C == "object" && (ae.loc = { start: C, end: K }), ae;
  }
  var O = () => (p) => {
    let P = Object.assign({}, p.acorn.tokTypes);
    return p.acornJsx && Object.assign(P, p.acornJsx.tokTypes), class extends p {
      constructor(d, C) {
        (typeof d != "object" || d === null) && (d = {}), typeof C != "string" && !(C instanceof String) && (C = String(C));
        let K = d.sourceType, H = B(d), te2 = H.ecmaFeatures || {}, ae = H.tokens === true ? new U(P, C) : null, fe = { originalSourceType: K || H.sourceType, tokens: ae ? [] : null, comments: H.comment === true ? [] : null, impliedStrict: te2.impliedStrict === true && H.ecmaVersion >= 5, ecmaVersion: H.ecmaVersion, jsxAttrValueToken: false, lastToken: null, templateElements: [] };
        super({ ecmaVersion: H.ecmaVersion, sourceType: H.sourceType, ranges: H.ranges, locations: H.locations, allowReserved: H.allowReserved, allowReturnOutsideFunction: H.allowReturnOutsideFunction, onToken: (Ae) => {
          ae && ae.onToken(Ae, fe), Ae.type !== P.eof && (fe.lastToken = Ae);
        }, onComment: (Ae, dt, mt2, _e, Ce, Oe) => {
          if (fe.comments) {
            let ze = X(Ae, dt, mt2, _e, Ce, Oe, C);
            fe.comments.push(ze);
          }
        } }, C), this[V] = fe;
      }
      tokenize() {
        do
          this.next();
        while (this.type !== P.eof);
        this.next();
        let d = this[V], C = d.tokens;
        return d.comments && (C.comments = d.comments), C;
      }
      finishNode() {
        let d = super.finishNode(...arguments);
        return this[k](d);
      }
      finishNodeAt() {
        let d = super.finishNodeAt(...arguments);
        return this[k](d);
      }
      parse() {
        let d = this[V], C = super.parse();
        if (C.sourceType = d.originalSourceType, d.comments && (C.comments = d.comments), d.tokens && (C.tokens = d.tokens), C.body.length) {
          let [K] = C.body;
          C.range && (C.range[0] = K.range[0]), C.loc && (C.loc.start = K.loc.start), C.start = K.start;
        }
        return d.lastToken && (C.range && (C.range[1] = d.lastToken.range[1]), C.loc && (C.loc.end = d.lastToken.loc.end), C.end = d.lastToken.end), this[V].templateElements.forEach((K) => {
          let te2 = K.tail ? 1 : 2;
          K.start += -1, K.end += te2, K.range && (K.range[0] += -1, K.range[1] += te2), K.loc && (K.loc.start.column += -1, K.loc.end.column += te2);
        }), C;
      }
      parseTopLevel(d) {
        return this[V].impliedStrict && (this.strict = true), super.parseTopLevel(d);
      }
      raise(d, C) {
        let K = p.acorn.getLineInfo(this.input, d), H = new SyntaxError(C);
        throw H.index = d, H.lineNumber = K.line, H.column = K.column + 1, H;
      }
      raiseRecoverable(d, C) {
        this.raise(d, C);
      }
      unexpected(d) {
        let C = "Unexpected token";
        if (d != null) {
          if (this.pos = d, this.options.locations) for (; this.pos < this.lineStart; ) this.lineStart = this.input.lastIndexOf(`
`, this.lineStart - 2) + 1, --this.curLine;
          this.nextToken();
        }
        this.end > this.start && (C += ` ${this.input.slice(this.start, this.end)}`), this.raise(this.start, C);
      }
      jsx_readString(d) {
        let C = super.jsx_readString(d);
        return this.type === P.string && (this[V].jsxAttrValueToken = true), C;
      }
      [k](d) {
        return d.type === "TemplateElement" && this[V].templateElements.push(d), d.type.includes("Function") && !d.generator && (d.generator = false), d;
      }
    };
  }, i = "9.4.1", S = { _regular: null, _jsx: null, get regular() {
    return this._regular === null && (this._regular = y.Parser.extend(O())), this._regular;
  }, get jsx() {
    return this._jsx === null && (this._jsx = y.Parser.extend(I.default(), O())), this._jsx;
  }, get(p) {
    return Boolean(p && p.ecmaFeatures && p.ecmaFeatures.jsx) ? this.jsx : this.regular;
  } };
  function F(p, P) {
    let _ = S.get(P);
    return (!P || P.tokens !== true) && (P = Object.assign({}, P, { tokens: true })), new _(P, p).tokenize();
  }
  function j(p, P) {
    let _ = S.get(P);
    return new _(P, p).parse();
  }
  var Z = i, ne2 = function() {
    return T.KEYS;
  }(), ee = void 0, ie = g(), Ne = w();
  a.Syntax = ee, a.VisitorKeys = ne2, a.latestEcmaVersion = ie, a.parse = j, a.supportedEcmaVersions = Ne, a.tokenize = F, a.version = Z;
} });
var Kh = Q({ "src/language-js/parse/espree.js"(a, u) {
  "use strict";
  J();
  var o = dr2(), l = ka2(), v = Ua2(), b = Gh(), y = Wa2(), I = { ecmaVersion: "latest", range: true, loc: true, comment: true, tokens: true, sourceType: "module", ecmaFeatures: { jsx: true, globalReturn: true, impliedStrict: false } };
  function T(R) {
    let { message: U, lineNumber: D, column: g } = R;
    return typeof D != "number" ? R : o(U, { start: { line: D, column: g } });
  }
  function x(R, U) {
    let D = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, { parse: g } = Hh(), w = b(R), { result: G, error: f } = l(() => g(w, Object.assign(Object.assign({}, I), {}, { sourceType: "module" })), () => g(w, Object.assign(Object.assign({}, I), {}, { sourceType: "script" })));
    if (!G) throw T(f);
    return D.originalText = R, y(G, D);
  }
  u.exports = v(x);
} });
var Xh = Q({ "src/language-js/parse/acorn-and-espree.js"(a, u) {
  J();
  var o = zh(), l = Kh();
  u.exports = { parsers: { acorn: o, espree: l } };
} });
var mc = Xh();

// src/stringify/acorn.ts
var stringifyPropsInline = (element2, field, imageCallback) => {
  return stringifyProps(element2, field, true, imageCallback);
};
function stringifyProps(element2, parentField, flatten2, imageCallback) {
  const attributes2 = [];
  const children = [];
  let template;
  let useDirective = false;
  let directiveType = "leaf";
  template = parentField.templates?.find((template2) => {
    if (typeof template2 === "string") {
      throw new Error("Global templates not supported");
    }
    return template2.name === element2.name;
  });
  if (!template) {
    template = parentField.templates?.find((template2) => {
      const templateName = template2?.match?.name;
      return templateName === element2.name;
    });
  }
  if (!template || typeof template === "string") {
    throw new Error(`Unable to find template for JSX element ${element2.name}`);
  }
  if (template.fields.find((f) => f.name === "children")) {
    directiveType = "block";
  }
  useDirective = !!template.match;
  Object.entries(element2.props).forEach(([name2, value]) => {
    if (typeof template === "string") {
      throw new Error(`Unable to find template for JSX element ${name2}`);
    }
    const field = template?.fields?.find((field2) => field2.name === name2);
    if (!field) {
      if (name2 === "children") {
        return;
      }
      return;
    }
    switch (field.type) {
      case "reference":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `"${item}"`).join(", ")}]`
              }
            });
          }
        } else {
          if (typeof value === "string") {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value
            });
          }
        }
        break;
      case "datetime":
      case "string":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `"${item}"`).join(", ")}]`
              }
            });
          }
        } else {
          if (typeof value === "string") {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value
            });
          } else {
            throw new Error(
              `Expected string for attribute on field ${field.name}`
            );
          }
        }
        break;
      case "image":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `"${imageCallback(item)}"`).join(", ")}]`
              }
            });
          }
        } else {
          attributes2.push({
            type: "mdxJsxAttribute",
            name: name2,
            value: imageCallback(String(value))
          });
        }
        break;
      case "number":
      case "boolean":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `${item}`).join(", ")}]`
              }
            });
          }
        } else {
          attributes2.push({
            type: "mdxJsxAttribute",
            name: name2,
            value: {
              type: "mdxJsxAttributeValueExpression",
              value: String(value)
            }
          });
        }
        break;
      case "object":
        const result = findAndTransformNestedRichText(
          field,
          value,
          imageCallback
        );
        attributes2.push({
          type: "mdxJsxAttribute",
          name: name2,
          value: {
            type: "mdxJsxAttributeValueExpression",
            value: stringifyObj(result, flatten2)
          }
        });
        break;
      case "rich-text":
        if (typeof value === "string") {
          throw new Error(
            `Unexpected string for rich-text, ensure the value has been properly parsed`
          );
        }
        if (field.list) {
          throw new Error(`Rich-text list is not supported`);
        } else {
          const joiner = flatten2 ? " " : "\n";
          let val = "";
          if (isPlainObject2(value) && Object.keys(value).length === 0) {
            return;
          }
          assertShape(
            value,
            (value2) => value2.type === "root" && Array.isArray(value2.children),
            `Nested rich-text element is not a valid shape for field ${field.name}`
          );
          if (field.name === "children") {
            const root2 = rootElement(value, field, imageCallback);
            root2.children.forEach((child) => {
              children.push(child);
            });
            return;
          } else {
            const stringValue = stringifyMDX(value, field, imageCallback);
            if (stringValue) {
              val = stringValue.trim().split("\n").map((str) => `  ${str.trim()}`).join(joiner);
            }
          }
          if (flatten2) {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `<>${val.trim()}</>`
              }
            });
          } else {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `<>
${val}
</>`
              }
            });
          }
        }
        break;
      default:
        throw new Error(`Stringify props: ${field.type} not yet supported`);
    }
  });
  if (template.match) {
    return {
      useDirective,
      directiveType,
      attributes: attributes2,
      children: children && children.length ? children : [
        {
          type: "paragraph",
          children: [
            {
              type: "text",
              value: ""
            }
          ]
        }
      ]
    };
  }
  return { attributes: attributes2, children, useDirective, directiveType };
}
function stringifyObj(obj, flatten2) {
  if (typeof obj === "object" && obj !== null) {
    const dummyFunc = `const dummyFunc = `;
    const res = Ty.format(`${dummyFunc}${JSON.stringify(obj)}`, {
      parser: "acorn",
      trailingComma: "none",
      semi: false,
      plugins: [mc]
    }).trim().replace(dummyFunc, "");
    return flatten2 ? res.replaceAll("\n", "").replaceAll("  ", " ") : res;
  } else {
    throw new Error(
      `stringifyObj must be passed an object or an array of objects, received ${typeof obj}`
    );
  }
}
function assertShape(value, callback, errorMessage) {
  if (!callback(value)) {
    throw new Error(errorMessage || `Failed to assert shape`);
  }
}
function isPlainObject2(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
var findAndTransformNestedRichText = (field, value, imageCallback, parentValue = {}) => {
  switch (field.type) {
    case "rich-text": {
      assertShape(
        value,
        (value2) => value2.type === "root" && Array.isArray(value2.children),
        `Nested rich-text element is not a valid shape for field ${field.name}`
      );
      parentValue[field.name] = stringifyMDX(value, field, imageCallback);
      break;
    }
    case "object": {
      if (field.list) {
        if (Array.isArray(value)) {
          value.forEach((item) => {
            Object.entries(item).forEach(([key, subValue]) => {
              if (field.fields) {
                const subField = field.fields.find(({ name: name2 }) => name2 === key);
                if (subField) {
                  findAndTransformNestedRichText(
                    subField,
                    subValue,
                    imageCallback,
                    item
                  );
                }
              }
            });
          });
        }
      } else {
        if (isObject(value)) {
          Object.entries(value).forEach(([key, subValue]) => {
            if (field.fields) {
              const subField = field.fields.find(({ name: name2 }) => name2 === key);
              if (subField) {
                findAndTransformNestedRichText(
                  subField,
                  subValue,
                  imageCallback,
                  value
                );
              }
            }
          });
        }
      }
      break;
    }
  }
  return value;
};
function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}

// src/stringify/marks.ts
var matches = (a, b) => {
  return a.some((v) => b.includes(v));
};
var replaceLinksWithTextNodes = (content3) => {
  const newItems = [];
  content3?.forEach((item) => {
    if (item.type === "a") {
      if (item.children.length === 1) {
        const firstChild = item.children[0];
        if (firstChild?.type === "text") {
          newItems.push({
            ...firstChild,
            linkifyTextNode: (a) => {
              return {
                type: "link",
                url: item.url,
                title: item.title,
                children: [a]
              };
            }
          });
        } else {
          newItems.push(item);
        }
      } else {
        newItems.push(item);
      }
    } else {
      newItems.push(item);
    }
  });
  return newItems;
};
var inlineElementExceptLink = (content3, field, imageCallback) => {
  switch (content3.type) {
    case "a":
      throw new Error(
        `Unexpected node of type "a", link elements should be processed after all inline elements have resolved`
      );
    case "img":
      return {
        type: "image",
        url: imageCallback(content3.url),
        alt: content3.alt,
        title: content3.caption
      };
    case "break":
      return {
        type: "break"
      };
    case "mdxJsxTextElement": {
      const { attributes: attributes2, children } = stringifyPropsInline(
        content3,
        field,
        imageCallback
      );
      return {
        type: "mdxJsxTextElement",
        name: content3.name,
        attributes: attributes2,
        children
      };
    }
    case "html_inline": {
      return {
        type: "html",
        value: content3.value
      };
    }
    default:
      if (!content3.type && typeof content3.text === "string") {
        return text5(content3);
      }
      throw new Error(`InlineElement: ${content3.type} is not supported`);
  }
};
var text5 = (content3) => {
  return {
    type: "text",
    value: content3.text
  };
};
var eat2 = (c, field, imageCallback) => {
  const content3 = replaceLinksWithTextNodes(c);
  const first = content3[0];
  if (!first) {
    return [];
  }
  if (first && first?.type !== "text") {
    if (first.type === "a") {
      return [
        {
          type: "link",
          url: first.url,
          title: first.title,
          children: eat2(
            first.children,
            field,
            imageCallback
          )
        },
        ...eat2(content3.slice(1), field, imageCallback)
      ];
    }
    return [
      inlineElementExceptLink(first, field, imageCallback),
      ...eat2(content3.slice(1), field, imageCallback)
    ];
  }
  const marks = getMarks(first);
  if (marks.length === 0) {
    if (first.linkifyTextNode) {
      return [
        first.linkifyTextNode(text5(first)),
        ...eat2(content3.slice(1), field, imageCallback)
      ];
    } else {
      return [text5(first), ...eat2(content3.slice(1), field, imageCallback)];
    }
  }
  let nonMatchingSiblingIndex = 0;
  if (content3.slice(1).every((content4, index2) => {
    if (matches(marks, getMarks(content4))) {
      return true;
    } else {
      nonMatchingSiblingIndex = index2;
      return false;
    }
  })) {
    nonMatchingSiblingIndex = content3.length - 1;
  }
  const matchingSiblings = content3.slice(1, nonMatchingSiblingIndex + 1);
  const markCounts = {};
  marks.forEach((mark) => {
    let count2 = 1;
    matchingSiblings.every((sibling, index2) => {
      if (getMarks(sibling).includes(mark)) {
        count2 = index2 + 1;
        return true;
      }
    });
    markCounts[mark] = count2;
  });
  let count = 0;
  let markToProcess = null;
  Object.entries(markCounts).forEach(([mark, markCount]) => {
    const m = mark;
    if (markCount > count) {
      count = markCount;
      markToProcess = m;
    }
  });
  if (!markToProcess) {
    return [text5(first), ...eat2(content3.slice(1), field, imageCallback)];
  }
  if (markToProcess === "inlineCode") {
    if (nonMatchingSiblingIndex) {
      throw new Error("Marks inside inline code are not supported");
    }
    const node2 = {
      type: markToProcess,
      value: first.text
    };
    return [
      first.linkifyTextNode?.(node2) ?? node2,
      ...eat2(content3.slice(nonMatchingSiblingIndex + 1), field, imageCallback)
    ];
  }
  return [
    {
      type: markToProcess,
      children: eat2(
        [
          ...[first, ...matchingSiblings].map(
            (sibling) => cleanNode(sibling, markToProcess)
          )
        ],
        field,
        imageCallback
      )
    },
    ...eat2(content3.slice(nonMatchingSiblingIndex + 1), field, imageCallback)
  ];
};
var cleanNode = (node2, mark) => {
  if (!mark) {
    return node2;
  }
  const cleanedNode = {};
  const markToClear = {
    strong: "bold",
    emphasis: "italic",
    inlineCode: "code",
    delete: "strikethrough"
  }[mark];
  Object.entries(node2).map(([key, value]) => {
    if (key !== markToClear) {
      cleanedNode[key] = value;
    }
  });
  if (node2.linkifyTextNode) {
    cleanedNode.callback = node2.linkifyTextNode;
  }
  return cleanedNode;
};

// src/extensions/tina-shortcodes/to-markdown.ts
var own6 = {}.hasOwnProperty;
var directiveToMarkdown = (patterns) => ({
  unsafe: [
    {
      character: "\r",
      inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
    },
    {
      character: "\n",
      inConstruct: ["leafDirectiveLabel", "containerDirectiveLabel"]
    },
    {
      before: "[^:]",
      character: ":",
      after: "[A-Za-z]",
      inConstruct: ["phrasing"]
    },
    { atBreak: true, character: ":", after: ":" }
  ],
  handlers: {
    containerDirective: handleDirective(patterns),
    leafDirective: handleDirective(patterns),
    textDirective: handleDirective(patterns)
  }
});
var handleDirective = function(patterns) {
  const handleDirective2 = function(node2, _, state, safeOptions) {
    const tracker = track(safeOptions);
    const exit3 = state.enter(node2.type);
    const pattern = patterns.find(
      (p) => p.name === node2.name || p.templateName === node2.name
    );
    if (!pattern) {
      console.log("no pattern found for directive", node2.name);
      exit3();
      return "";
    }
    const patternName = pattern.name || pattern.templateName;
    const sequence = pattern.start;
    let value = tracker.move(sequence + " " + patternName);
    let label;
    if (label && label.children && label.children.length > 0) {
      const exit4 = state.enter("label");
      const labelType = `${node2.type}Label`;
      const subexit = state.enter(labelType);
      value += tracker.move("[");
      value += tracker.move(
        containerPhrasing(label, state, {
          ...tracker.current(),
          before: value,
          after: "]"
        })
      );
      value += tracker.move("]");
      subexit();
      exit4();
    }
    value += tracker.move(" ");
    value += tracker.move(attributes(node2, state));
    value += tracker.move(pattern.end);
    if (node2.type === "containerDirective") {
      const head = (node2.children || [])[0];
      let shallow = node2;
      if (inlineDirectiveLabel(head)) {
        shallow = Object.assign({}, node2, { children: node2.children.slice(1) });
      }
      if (shallow && shallow.children && shallow.children.length > 0) {
        value += tracker.move("\n");
        value += tracker.move(containerFlow(shallow, state, tracker.current()));
      }
      value += tracker.move("\n" + sequence);
      value += tracker.move(" /" + patternName + " " + pattern.end);
    }
    exit3();
    return value;
  };
  handleDirective2.peek = peekDirective;
  return handleDirective2;
};
function peekDirective() {
  return ":";
}
function attributes(node2, state) {
  const quote = checkQuote(state);
  const subset = node2.type === "textDirective" ? [quote] : [quote, "\n", "\r"];
  const attrs = node2.attributes || {};
  const values2 = [];
  let key;
  for (key in attrs) {
    if (own6.call(attrs, key) && attrs[key] !== void 0 && attrs[key] !== null) {
      const value = String(attrs[key]);
      values2.push(quoted(key, value));
    }
  }
  return values2.length > 0 ? values2.join(" ") + " " : "";
  function quoted(key2, value) {
    const v = quote + stringifyEntitiesLight(value, { subset }) + quote;
    if (key2 === "_value") {
      return v;
    }
    return key2 + (value ? "=" + v : "");
  }
}
function inlineDirectiveLabel(node2) {
  return Boolean(
    node2 && node2.type === "paragraph" && node2.data && node2.data.directiveLabel
  );
}

// src/stringify/stringifyShortcode.ts
function stringifyShortcode(preprocessedString, template) {
  const match = template.match;
  const unkeyedAttributes = !!template.fields.find((t) => t.name == "_value");
  const regex = `<[\\s]*${template.name}[\\s]*${unkeyedAttributes ? "(?:_value=(.*?))?" : "(.+?)?"}[\\s]*>[\\s]*((?:.|
)*?)[\\s]*</[\\s]*${template.name}[\\s]*>`;
  const closingRegex = `
$2
${match.start} /${match.name || template.name} ${match.end}`;
  const replace3 = `${match.start} ${match.name || template.name} $1 ${match.end}${template.fields.find((t) => t.name == "children") ? closingRegex : ""}`;
  return replaceAll(preprocessedString, regex, replace3);
}

// src/stringify/index.ts
var stringifyMDX = (value, field, imageCallback) => {
  if (field.parser?.type === "markdown") {
    return stringifyMDX2(value, field, imageCallback);
  }
  if (!value) {
    return;
  }
  if (typeof value === "string") {
    throw new Error("Expected an object to stringify, but received a string");
  }
  if (value?.children[0]) {
    if (value?.children[0].type === "invalid_markdown") {
      return value.children[0].value;
    }
  }
  const tree = rootElement(value, field, imageCallback);
  const res = toTinaMarkdown2(tree, field);
  const templatesWithMatchers = field.templates?.filter(
    (template) => template.match
  );
  let preprocessedString = res;
  templatesWithMatchers?.forEach((template) => {
    if (typeof template === "string") {
      throw new Error("Global templates are not supported");
    }
    if (template.match) {
      preprocessedString = stringifyShortcode(preprocessedString, template);
    }
  });
  return preprocessedString;
};
var toTinaMarkdown2 = (tree, field) => {
  const patterns = [];
  field.templates?.forEach((template) => {
    if (typeof template === "string") {
      return;
    }
    if (template && template.match) {
      const pattern = template.match;
      pattern.templateName = template.name;
      patterns.push(pattern);
    }
  });
  const handlers = {};
  handlers["text"] = (node2, parent, context, safeOptions) => {
    context.unsafe = context.unsafe.filter((unsafeItem) => {
      if (unsafeItem.character === " " && unsafeItem.inConstruct === "phrasing") {
        return false;
      }
      return true;
    });
    if (field.parser?.type === "markdown") {
      if (field.parser.skipEscaping === "all") {
        return node2.value;
      }
      if (field.parser.skipEscaping === "html") {
        context.unsafe = context.unsafe.filter((unsafeItem) => {
          if (unsafeItem.character === "<") {
            return false;
          }
          return true;
        });
      }
    }
    return text3(node2, parent, context, safeOptions);
  };
  return toMarkdown(tree, {
    extensions: [
      directiveToMarkdown(patterns),
      mdxJsxToMarkdown(),
      gfmToMarkdown()
    ],
    listItemIndent: "one",
    handlers
  });
};
var rootElement = (content3, field, imageCallback) => {
  const children = [];
  content3.children?.forEach((child) => {
    const value = blockElement(child, field, imageCallback);
    if (value) {
      children.push(value);
    }
  });
  return {
    type: "root",
    children
  };
};
var blockElement = (content3, field, imageCallback) => {
  switch (content3.type) {
    case "h1":
    case "h2":
    case "h3":
    case "h4":
    case "h5":
    case "h6":
      return {
        type: "heading",
        // @ts-ignore Type 'number' is not assignable to type '1 | 2 | 3 | 4 | 5 | 6'
        depth: { h1: 1, h2: 2, h3: 3, h4: 4, h5: 5, h6: 6 }[content3.type],
        children: eat2(content3.children, field, imageCallback)
      };
    case "p":
      if (content3.children.length === 1) {
        const onlyChild = content3.children[0];
        if (onlyChild && // Slate text nodes don't get a `type` property for text nodes
        (onlyChild.type === "text" || !onlyChild.type) && onlyChild.text === "") {
          return null;
        }
      }
      return {
        type: "paragraph",
        children: eat2(content3.children, field, imageCallback)
      };
    case "mermaid":
      return {
        type: "code",
        lang: "mermaid",
        value: content3.value
      };
    case "code_block":
      return {
        type: "code",
        lang: content3.lang,
        value: content3.value
      };
    case "mdxJsxFlowElement":
      if (content3.name === "table") {
        const table2 = content3.props;
        return {
          type: "table",
          align: table2.align,
          children: table2.tableRows.map((tableRow) => {
            const tr2 = {
              type: "tableRow",
              children: tableRow.tableCells.map(({ value }) => {
                return {
                  type: "tableCell",
                  children: eat2(
                    value?.children?.at(0)?.children || [],
                    field,
                    imageCallback
                  )
                };
              })
            };
            return tr2;
          })
        };
      }
      const { children, attributes: attributes2, useDirective, directiveType } = stringifyProps(content3, field, false, imageCallback);
      if (useDirective) {
        const name2 = content3.name;
        if (!name2) {
          throw new Error(
            `Expective shortcode to have a name but it was not defined`
          );
        }
        const directiveAttributes = {};
        attributes2?.forEach((att) => {
          if (att.value && typeof att.value === "string") {
            directiveAttributes[att.name] = att.value;
          }
        });
        if (directiveType === "leaf") {
          return {
            type: "leafDirective",
            name: name2,
            attributes: directiveAttributes,
            children: []
          };
        } else {
          return {
            type: "containerDirective",
            name: name2,
            attributes: directiveAttributes,
            children
          };
        }
      }
      return {
        type: "mdxJsxFlowElement",
        name: content3.name,
        attributes: attributes2,
        children
      };
    case "blockquote":
      return {
        type: "blockquote",
        children: [
          {
            type: "paragraph",
            children: eat2(content3.children, field, imageCallback)
          }
        ]
      };
    case "hr":
      return {
        type: "thematicBreak"
      };
    case "ol":
    case "ul":
      return {
        type: "list",
        ordered: content3.type === "ol",
        spread: false,
        children: content3.children.map(
          (child) => listItemElement(child, field, imageCallback)
        )
      };
    case "html": {
      return {
        type: "html",
        value: content3.value
      };
    }
    case "img":
      return {
        // Slate editor treats `img` as a block-level element, wrap
        // it in an empty paragraph
        type: "paragraph",
        children: [
          {
            type: "image",
            url: imageCallback(content3.url),
            alt: content3.alt,
            title: content3.caption
          }
        ]
      };
    case "table":
      const table = content3.props;
      return {
        type: "table",
        align: table?.align,
        children: content3.children.map((tableRow) => {
          return {
            type: "tableRow",
            children: tableRow.children.map((tableCell) => {
              return {
                type: "tableCell",
                children: eat2(
                  tableCell.children?.at(0)?.children || [],
                  field,
                  imageCallback
                )
              };
            })
          };
        })
      };
    default:
      throw new Error(`BlockElement: ${content3.type} is not yet supported`);
  }
};
var listItemElement = (content3, field, imageCallback) => {
  return {
    type: "listItem",
    // spread is always false since we don't support block elements in list items
    // good explanation of the difference: https://stackoverflow.com/questions/43503528/extra-lines-appearing-between-list-items-in-github-markdown
    spread: false,
    children: content3.children.map((child) => {
      if (child.type === "lic") {
        return {
          type: "paragraph",
          children: eat2(child.children, field, imageCallback)
        };
      }
      return blockContentElement(child, field, imageCallback);
    })
  };
};
var blockContentElement = (content3, field, imageCallback) => {
  switch (content3.type) {
    case "blockquote":
      return {
        type: "blockquote",
        children: content3.children.map(
          (child) => (
            // FIXME: text nodes are probably passed in here by the rich text editor
            // @ts-ignore
            blockContentElement(child, field, imageCallback)
          )
        )
      };
    case "p":
      return {
        type: "paragraph",
        children: eat2(content3.children, field, imageCallback)
      };
    case "ol":
    case "ul":
      return {
        type: "list",
        ordered: content3.type === "ol",
        spread: false,
        children: content3.children.map(
          (child) => listItemElement(child, field, imageCallback)
        )
      };
    default:
      throw new Error(
        `BlockContentElement: ${content3.type} is not yet supported`
      );
  }
};
var getMarks = (content3) => {
  const marks = [];
  if (content3.type !== "text") {
    return [];
  }
  if (content3.bold) {
    marks.push("strong");
  }
  if (content3.italic) {
    marks.push("emphasis");
  }
  if (content3.code) {
    marks.push("inlineCode");
  }
  if (content3.strikethrough) {
    marks.push("delete");
  }
  return marks;
};

// src/next/stringify/acorn.ts
var stringifyPropsInline2 = (element2, field, imageCallback) => {
  return stringifyProps2(element2, field, true, imageCallback);
};
function stringifyProps2(element2, parentField, flatten2, imageCallback) {
  const attributes2 = [];
  const children = [];
  let template;
  let useDirective = false;
  let directiveType = "leaf";
  template = parentField.templates?.find((template2) => {
    if (typeof template2 === "string") {
      throw new Error("Global templates not supported");
    }
    return template2.name === element2.name;
  });
  if (!template) {
    template = parentField.templates?.find((template2) => {
      const templateName = template2?.match?.name;
      return templateName === element2.name;
    });
  }
  if (!template || typeof template === "string") {
    throw new Error(`Unable to find template for JSX element ${element2.name}`);
  }
  if (template.fields.find((f) => f.name === "children")) {
    directiveType = "block";
  }
  useDirective = !!template.match;
  Object.entries(element2.props).forEach(([name2, value]) => {
    if (typeof template === "string") {
      throw new Error(`Unable to find template for JSX element ${name2}`);
    }
    const field = template?.fields?.find((field2) => field2.name === name2);
    if (!field) {
      if (name2 === "children") {
        return;
      }
      return;
    }
    switch (field.type) {
      case "reference":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `"${item}"`).join(", ")}]`
              }
            });
          }
        } else {
          if (typeof value === "string") {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value
            });
          }
        }
        break;
      case "datetime":
      case "string":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `"${item}"`).join(", ")}]`
              }
            });
          }
        } else {
          if (typeof value === "string") {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value
            });
          } else {
            throw new Error(
              `Expected string for attribute on field ${field.name}`
            );
          }
        }
        break;
      case "image":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `"${imageCallback(item)}"`).join(", ")}]`
              }
            });
          }
        } else {
          attributes2.push({
            type: "mdxJsxAttribute",
            name: name2,
            value: imageCallback(String(value))
          });
        }
        break;
      case "number":
      case "boolean":
        if (field.list) {
          if (Array.isArray(value)) {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `[${value.map((item) => `${item}`).join(", ")}]`
              }
            });
          }
        } else {
          attributes2.push({
            type: "mdxJsxAttribute",
            name: name2,
            value: {
              type: "mdxJsxAttributeValueExpression",
              value: String(value)
            }
          });
        }
        break;
      case "object":
        attributes2.push({
          type: "mdxJsxAttribute",
          name: name2,
          value: {
            type: "mdxJsxAttributeValueExpression",
            value: stringifyObj2(value, flatten2)
          }
        });
        break;
      case "rich-text":
        if (typeof value === "string") {
          throw new Error(
            `Unexpected string for rich-text, ensure the value has been properly parsed`
          );
        }
        if (field.list) {
          throw new Error(`Rich-text list is not supported`);
        } else {
          const joiner = flatten2 ? " " : "\n";
          let val = "";
          assertShape2(
            value,
            (value2) => value2.type === "root" && Array.isArray(value2.children),
            `Nested rich-text element is not a valid shape for field ${field.name}`
          );
          if (field.name === "children") {
            const root2 = rootElement2(value, field, imageCallback);
            root2.children.forEach((child) => {
              children.push(child);
            });
            return;
          } else {
            const stringValue = stringifyMDX2(value, field, imageCallback);
            if (stringValue) {
              val = stringValue.trim().split("\n").map((str) => `  ${str.trim()}`).join(joiner);
            }
          }
          if (flatten2) {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `<>${val.trim()}</>`
              }
            });
          } else {
            attributes2.push({
              type: "mdxJsxAttribute",
              name: name2,
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: `<>
${val}
</>`
              }
            });
          }
        }
        break;
      default:
        throw new Error(`Stringify props: ${field.type} not yet supported`);
    }
  });
  if (template.match) {
    return {
      useDirective,
      directiveType,
      attributes: attributes2,
      children: children && children.length ? children : [
        {
          type: "paragraph",
          children: [
            {
              type: "text",
              value: ""
            }
          ]
        }
      ]
    };
  }
  return { attributes: attributes2, children, useDirective, directiveType };
}
function stringifyObj2(obj, flatten2) {
  if (typeof obj === "object" && obj !== null) {
    const dummyFunc = `const dummyFunc = `;
    const res = Ty.format(`${dummyFunc}${JSON.stringify(obj)}`, {
      parser: "acorn",
      trailingComma: "none",
      semi: false,
      plugins: [mc]
    }).trim().replace(dummyFunc, "");
    return flatten2 ? res.replaceAll("\n", "").replaceAll("  ", " ") : res;
  } else {
    throw new Error(
      `stringifyObj must be passed an object or an array of objects, received ${typeof obj}`
    );
  }
}
function assertShape2(value, callback, errorMessage) {
  if (!callback(value)) {
    throw new Error(errorMessage || `Failed to assert shape`);
  }
}

// src/next/stringify/marks.ts
var matches2 = (a, b) => {
  return a.some((v) => b.includes(v));
};
var replaceLinksWithTextNodes2 = (content3) => {
  const newItems = [];
  content3?.forEach((item) => {
    if (item.type === "a") {
      if (item.children.length === 1) {
        const firstChild = item.children[0];
        if (firstChild?.type === "text") {
          newItems.push({
            ...firstChild,
            linkifyTextNode: (a) => {
              return {
                type: "link",
                url: item.url,
                title: item.title,
                children: [a]
              };
            }
          });
        } else {
          newItems.push(item);
        }
      } else {
        newItems.push(item);
      }
    } else {
      newItems.push(item);
    }
  });
  return newItems;
};
var inlineElementExceptLink2 = (content3, field, imageCallback) => {
  switch (content3.type) {
    case "a":
      throw new Error(
        `Unexpected node of type "a", link elements should be processed after all inline elements have resolved`
      );
    case "img":
      return {
        type: "image",
        url: imageCallback(content3.url),
        alt: content3.alt,
        title: content3.caption
      };
    case "break":
      return {
        type: "break"
      };
    case "mdxJsxTextElement": {
      const { attributes: attributes2, children } = stringifyPropsInline2(
        content3,
        field,
        imageCallback
      );
      let c = children;
      if (children.length) {
        const firstChild = children[0];
        if (firstChild && firstChild.type === "paragraph") {
          c = firstChild.children;
        }
      }
      return {
        type: "mdxJsxTextElement",
        name: content3.name,
        attributes: attributes2,
        children: c
      };
    }
    case "html_inline": {
      return {
        type: "html",
        value: content3.value
      };
    }
    default:
      if (!content3.type && typeof content3.text === "string") {
        return text6(content3);
      }
      throw new Error(`InlineElement: ${content3.type} is not supported`);
  }
};
var text6 = (content3) => {
  return {
    type: "text",
    value: content3.text
  };
};
var eat3 = (c, field, imageCallback) => {
  const content3 = replaceLinksWithTextNodes2(c);
  const first = content3[0];
  if (!first) {
    return [];
  }
  if (first && first?.type !== "text") {
    if (first.type === "a") {
      return [
        {
          type: "link",
          url: first.url,
          title: first.title,
          children: eat3(
            first.children,
            field,
            imageCallback
          )
        },
        ...eat3(content3.slice(1), field, imageCallback)
      ];
    }
    return [
      inlineElementExceptLink2(first, field, imageCallback),
      ...eat3(content3.slice(1), field, imageCallback)
    ];
  }
  const marks = getMarks(first);
  if (marks.length === 0) {
    if (first.linkifyTextNode) {
      return [
        first.linkifyTextNode(text6(first)),
        ...eat3(content3.slice(1), field, imageCallback)
      ];
    } else {
      return [text6(first), ...eat3(content3.slice(1), field, imageCallback)];
    }
  }
  let nonMatchingSiblingIndex = 0;
  if (content3.slice(1).every((content4, index2) => {
    if (matches2(marks, getMarks(content4))) {
      return true;
    } else {
      nonMatchingSiblingIndex = index2;
      return false;
    }
  })) {
    nonMatchingSiblingIndex = content3.length - 1;
  }
  const matchingSiblings = content3.slice(1, nonMatchingSiblingIndex + 1);
  const markCounts = {};
  marks.forEach((mark) => {
    let count2 = 1;
    matchingSiblings.every((sibling, index2) => {
      if (getMarks(sibling).includes(mark)) {
        count2 = index2 + 1;
        return true;
      }
    });
    markCounts[mark] = count2;
  });
  let count = 0;
  let markToProcess = null;
  Object.entries(markCounts).forEach(([mark, markCount]) => {
    const m = mark;
    if (markCount > count) {
      count = markCount;
      markToProcess = m;
    }
  });
  if (!markToProcess) {
    return [text6(first), ...eat3(content3.slice(1), field, imageCallback)];
  }
  if (markToProcess === "inlineCode") {
    if (nonMatchingSiblingIndex) {
      throw new Error(`Marks inside inline code are not supported`);
    }
    const node2 = {
      type: markToProcess,
      value: first.text
    };
    return [
      first.linkifyTextNode?.(node2) ?? node2,
      ...eat3(content3.slice(nonMatchingSiblingIndex + 1), field, imageCallback)
    ];
  }
  return [
    {
      type: markToProcess,
      children: eat3(
        [
          ...[first, ...matchingSiblings].map(
            (sibling) => cleanNode2(sibling, markToProcess)
          )
        ],
        field,
        imageCallback
      )
    },
    ...eat3(content3.slice(nonMatchingSiblingIndex + 1), field, imageCallback)
  ];
};
var cleanNode2 = (node2, mark) => {
  if (!mark) {
    return node2;
  }
  const cleanedNode = {};
  const markToClear = {
    strong: "bold",
    emphasis: "italic",
    inlineCode: "code",
    delete: "strikethrough"
  }[mark];
  Object.entries(node2).map(([key, value]) => {
    if (key !== markToClear) {
      cleanedNode[key] = value;
    }
  });
  if (node2.linkifyTextNode) {
    cleanedNode.callback = node2.linkifyTextNode;
  }
  return cleanedNode;
};

// src/next/stringify/pre-processing.ts
var preProcess = (tree, field, imageCallback) => {
  const ast = rootElement2(tree, field, imageCallback);
  return ast;
};
var rootElement2 = (content3, field, imageCallback) => {
  const children = [];
  content3.children?.forEach((child) => {
    const value = blockElement2(child, field, imageCallback);
    if (value) {
      children.push(value);
    }
  });
  return {
    type: "root",
    children
  };
};
var blockElement2 = (content3, field, imageCallback) => {
  switch (content3.type) {
    case "h1":
    case "h2":
    case "h3":
    case "h4":
    case "h5":
    case "h6":
      return {
        type: "heading",
        // @ts-ignore Type 'number' is not assignable to type '1 | 2 | 3 | 4 | 5 | 6'
        depth: { h1: 1, h2: 2, h3: 3, h4: 4, h5: 5, h6: 6 }[content3.type],
        children: eat3(content3.children, field, imageCallback)
      };
    case "p":
      if (content3.children.length === 1) {
        const onlyChild = content3.children[0];
        if (onlyChild && // Slate text nodes don't get a `type` property for text nodes
        (onlyChild.type === "text" || !onlyChild.type) && onlyChild.text === "") {
          return null;
        }
      }
      return {
        type: "paragraph",
        children: eat3(content3.children, field, imageCallback)
      };
    case "mermaid":
      return {
        type: "code",
        lang: "mermaid",
        value: content3.value
      };
    case "code_block":
      return {
        type: "code",
        lang: content3.lang,
        value: content3.value
      };
    case "mdxJsxFlowElement":
      if (content3.name === "table") {
        const table2 = content3.props;
        return {
          type: "table",
          align: table2.align,
          children: table2.tableRows.map((tableRow) => {
            const tr2 = {
              type: "tableRow",
              children: tableRow.tableCells.map(({ value }) => {
                return {
                  type: "tableCell",
                  children: eat3(
                    value?.children?.at(0)?.children || [],
                    field,
                    imageCallback
                  )
                };
              })
            };
            return tr2;
          })
        };
      }
      const { children, attributes: attributes2, useDirective, directiveType } = stringifyProps2(content3, field, false, imageCallback);
      return {
        type: "mdxJsxFlowElement",
        name: content3.name,
        attributes: attributes2,
        children
      };
    case "blockquote":
      return {
        type: "blockquote",
        children: [
          {
            type: "paragraph",
            children: eat3(content3.children, field, imageCallback)
          }
        ]
      };
    case "hr":
      return {
        type: "thematicBreak"
      };
    case "ol":
    case "ul":
      return {
        type: "list",
        ordered: content3.type === "ol",
        spread: false,
        children: content3.children.map(
          (child) => listItemElement2(child, field, imageCallback)
        )
      };
    case "html": {
      return {
        type: "html",
        value: content3.value
      };
    }
    case "img":
      return {
        type: "paragraph",
        children: [
          {
            type: "image",
            url: imageCallback(content3.url),
            alt: content3.alt,
            title: content3.caption
          }
        ]
      };
    case "table":
      const table = content3.props;
      return {
        type: "table",
        align: table?.align,
        children: content3.children.map((tableRow) => {
          return {
            type: "tableRow",
            children: tableRow.children.map((tableCell) => {
              return {
                type: "tableCell",
                children: eat3(
                  tableCell.children?.at(0)?.children || [],
                  field,
                  imageCallback
                )
              };
            })
          };
        })
      };
    default:
      throw new Error(`BlockElement: ${content3.type} is not yet supported`);
  }
};
var listItemElement2 = (content3, field, imageCallback) => {
  return {
    type: "listItem",
    // spread is always false since we don't support block elements in list items
    // good explanation of the difference: https://stackoverflow.com/questions/43503528/extra-lines-appearing-between-list-items-in-github-markdown
    spread: false,
    children: content3.children.map((child) => {
      if (child.type === "lic") {
        return {
          type: "paragraph",
          children: eat3(child.children, field, imageCallback)
        };
      }
      return blockContentElement2(child, field, imageCallback);
    })
  };
};
var blockContentElement2 = (content3, field, imageCallback) => {
  switch (content3.type) {
    case "blockquote":
      return {
        type: "blockquote",
        children: content3.children.map(
          (child) => (
            // FIXME: text nodes are probably passed in here by the rich text editor
            // @ts-ignore
            blockContentElement2(child, field, imageCallback)
          )
        )
      };
    case "p":
      return {
        type: "paragraph",
        children: eat3(content3.children, field, imageCallback)
      };
    case "ol":
    case "ul":
      return {
        type: "list",
        ordered: content3.type === "ol",
        spread: false,
        children: content3.children.map(
          (child) => listItemElement2(child, field, imageCallback)
        )
      };
    default:
      throw new Error(
        `BlockContentElement: ${content3.type} is not yet supported`
      );
  }
};

// src/next/stringify/index.ts
var stringifyMDX2 = (value, field, imageCallback) => {
  if (!value) {
    return;
  }
  const mdTree = preProcess(value, field, imageCallback);
  return toTinaMarkdown(mdTree, field);
};

// ../../../node_modules/.pnpm/dequal@2.0.3/node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar)) return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar) return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len])) ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }
        if (!bar.has(tmp)) return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len)) ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len]) ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// ../../../node_modules/.pnpm/kleur@4.1.5/node_modules/kleur/index.mjs
var FORCE_COLOR;
var NODE_DISABLE_COLORS;
var NO_COLOR;
var TERM;
var isTTY = true;
if (typeof process !== "undefined") {
  ({ FORCE_COLOR, NODE_DISABLE_COLORS, NO_COLOR, TERM } = process.env || {});
  isTTY = process.stdout && process.stdout.isTTY;
}
var $ = {
  enabled: !NODE_DISABLE_COLORS && NO_COLOR == null && TERM !== "dumb" && (FORCE_COLOR != null && FORCE_COLOR !== "0" || isTTY),
  // modifiers
  reset: init(0, 0),
  bold: init(1, 22),
  dim: init(2, 22),
  italic: init(3, 23),
  underline: init(4, 24),
  inverse: init(7, 27),
  hidden: init(8, 28),
  strikethrough: init(9, 29),
  // colors
  black: init(30, 39),
  red: init(31, 39),
  green: init(32, 39),
  yellow: init(33, 39),
  blue: init(34, 39),
  magenta: init(35, 39),
  cyan: init(36, 39),
  white: init(37, 39),
  gray: init(90, 39),
  grey: init(90, 39),
  // background colors
  bgBlack: init(40, 49),
  bgRed: init(41, 49),
  bgGreen: init(42, 49),
  bgYellow: init(43, 49),
  bgBlue: init(44, 49),
  bgMagenta: init(45, 49),
  bgCyan: init(46, 49),
  bgWhite: init(47, 49)
};
function run(arr, str) {
  let i = 0, tmp, beg = "", end = "";
  for (; i < arr.length; i++) {
    tmp = arr[i];
    beg += tmp.open;
    end += tmp.close;
    if (!!~str.indexOf(tmp.close)) {
      str = str.replace(tmp.rgx, tmp.close + tmp.open);
    }
  }
  return beg + str + end;
}
function chain(has2, keys2) {
  let ctx = { has: has2, keys: keys2 };
  ctx.reset = $.reset.bind(ctx);
  ctx.bold = $.bold.bind(ctx);
  ctx.dim = $.dim.bind(ctx);
  ctx.italic = $.italic.bind(ctx);
  ctx.underline = $.underline.bind(ctx);
  ctx.inverse = $.inverse.bind(ctx);
  ctx.hidden = $.hidden.bind(ctx);
  ctx.strikethrough = $.strikethrough.bind(ctx);
  ctx.black = $.black.bind(ctx);
  ctx.red = $.red.bind(ctx);
  ctx.green = $.green.bind(ctx);
  ctx.yellow = $.yellow.bind(ctx);
  ctx.blue = $.blue.bind(ctx);
  ctx.magenta = $.magenta.bind(ctx);
  ctx.cyan = $.cyan.bind(ctx);
  ctx.white = $.white.bind(ctx);
  ctx.gray = $.gray.bind(ctx);
  ctx.grey = $.grey.bind(ctx);
  ctx.bgBlack = $.bgBlack.bind(ctx);
  ctx.bgRed = $.bgRed.bind(ctx);
  ctx.bgGreen = $.bgGreen.bind(ctx);
  ctx.bgYellow = $.bgYellow.bind(ctx);
  ctx.bgBlue = $.bgBlue.bind(ctx);
  ctx.bgMagenta = $.bgMagenta.bind(ctx);
  ctx.bgCyan = $.bgCyan.bind(ctx);
  ctx.bgWhite = $.bgWhite.bind(ctx);
  return ctx;
}
function init(open, close) {
  let blk = {
    open: `\x1B[${open}m`,
    close: `\x1B[${close}m`,
    rgx: new RegExp(`\\x1b\\[${close}m`, "g")
  };
  return function(txt) {
    if (this !== void 0 && this.has !== void 0) {
      !!~this.has.indexOf(open) || (this.has.push(open), this.keys.push(blk));
      return txt === void 0 ? this : $.enabled ? run(this.keys, txt + "") : txt + "";
    }
    return txt === void 0 ? chain([open], [blk]) : $.enabled ? run([blk], txt + "") : txt + "";
  };
}
var kleur_default = $;

// ../../../node_modules/.pnpm/diff@5.2.0/node_modules/diff/lib/index.mjs
function Diff() {
}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var _options$timeout;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    this.options = options;
    var self2 = this;
    function done(value) {
      if (callback) {
        setTimeout(function() {
          callback(void 0, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos + 1 < addPath.oldPos) {
          basePath = self2.addToPath(addPath, true, void 0, 0);
        } else {
          basePath = self2.addToPath(removePath, void 0, true, 1);
        }
        newPos = self2.extractCommon(basePath, newString, oldString, diagonalPath);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self2, basePath.lastComponent, newString, oldString, self2.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  addToPath: function addToPath(path3, added, removed, oldPosInc) {
    var last = path3.lastComponent;
    if (last && last.added === added && last.removed === removed) {
      return {
        oldPos: path3.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path3.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last
        }
      };
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }
    if (commonCount) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split("");
  },
  join: function join3(chars2) {
    return chars2.join("");
  }
};
function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff2.join(value);
      } else {
        component.value = diff2.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff2.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  }
  var finalComponent = components[componentLen - 1];
  if (componentLen > 1 && typeof finalComponent.value === "string" && (finalComponent.added || finalComponent.removed) && diff2.equals("", finalComponent.value)) {
    components[componentLen - 2].value += finalComponent.value;
    components.pop();
  }
  return components;
}
var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();
wordDiff.equals = function(left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};
wordDiff.tokenize = function(value) {
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
  for (var i = 0; i < tokens.length - 1; i++) {
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }
  return tokens;
};
var lineDiff = new Diff();
lineDiff.tokenize = function(value) {
  if (this.options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line2 = linesAndNewlines[i];
    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line2;
    } else {
      if (this.options.ignoreWhitespace) {
        line2 = line2.trim();
      }
      retLines.push(line2);
    }
  }
  return retLines;
};
function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value) {
  var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void 0 ? function(k, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _this$options$stringi;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"));
};
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};
function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}

// ../../../node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/diff/index.mjs
var colors = {
  "--": kleur_default.red,
  "\xB7\xB7": kleur_default.grey,
  "++": kleur_default.green
};
var TITLE = kleur_default.dim().italic;
var TAB = kleur_default.dim("\u2192");
var SPACE = kleur_default.dim("\xB7");
var NL = kleur_default.dim("\u21B5");
var LOG = (sym, str) => colors[sym](sym + PRETTY(str)) + "\n";
var LINE = (num, x) => kleur_default.dim("L" + String(num).padStart(x, "0") + " ");
var PRETTY = (str) => str.replace(/[ ]/g, SPACE).replace(/\t/g, TAB).replace(/(\r?\n)/g, NL);
function line(obj, prev, pad) {
  let char = obj.removed ? "--" : obj.added ? "++" : "\xB7\xB7";
  let arr = obj.value.replace(/\r?\n$/, "").split("\n");
  let i = 0, tmp, out = "";
  if (obj.added) out += colors[char]().underline(TITLE("Expected:")) + "\n";
  else if (obj.removed) out += colors[char]().underline(TITLE("Actual:")) + "\n";
  for (; i < arr.length; i++) {
    tmp = arr[i];
    if (tmp != null) {
      if (prev) out += LINE(prev + i, pad);
      out += LOG(char, tmp || "\n");
    }
  }
  return out;
}
function arrays(input, expect) {
  let arr = diffArrays(input, expect);
  let i = 0, j = 0, k = 0, tmp, val, char, isObj, str;
  let out = LOG("\xB7\xB7", "[");
  for (; i < arr.length; i++) {
    char = (tmp = arr[i]).removed ? "--" : tmp.added ? "++" : "\xB7\xB7";
    if (tmp.added) {
      out += colors[char]().underline(TITLE("Expected:")) + "\n";
    } else if (tmp.removed) {
      out += colors[char]().underline(TITLE("Actual:")) + "\n";
    }
    for (j = 0; j < tmp.value.length; j++) {
      isObj = tmp.value[j] && typeof tmp.value[j] === "object";
      val = stringify(tmp.value[j]).split(/\r?\n/g);
      for (k = 0; k < val.length; ) {
        str = "  " + val[k++] + (isObj ? "" : ",");
        if (isObj && k === val.length && j + 1 < tmp.value.length) str += ",";
        out += LOG(char, str);
      }
    }
  }
  return out + LOG("\xB7\xB7", "]");
}
function lines(input, expect, linenum = 0) {
  let i = 0, tmp, output = "";
  let arr = diffLines(input, expect);
  let pad = String(expect.split(/\r?\n/g).length - linenum).length;
  for (; i < arr.length; i++) {
    output += line(tmp = arr[i], linenum, pad);
    if (linenum && !tmp.removed) linenum += tmp.count;
  }
  return output;
}
function chars(input, expect) {
  let arr = diffChars(input, expect);
  let i = 0, output = "", tmp;
  let l1 = input.length;
  let l2 = expect.length;
  let p1 = PRETTY(input);
  let p2 = PRETTY(expect);
  tmp = arr[i];
  if (l1 === l2) {
  } else if (tmp.removed && arr[i + 1]) {
    let del = tmp.count - arr[i + 1].count;
    if (del == 0) {
    } else if (del > 0) {
      expect = " ".repeat(del) + expect;
      p2 = " ".repeat(del) + p2;
      l2 += del;
    } else if (del < 0) {
      input = " ".repeat(-del) + input;
      p1 = " ".repeat(-del) + p1;
      l1 += -del;
    }
  }
  output += direct(p1, p2, l1, l2);
  if (l1 === l2) {
    for (tmp = "  "; i < l1; i++) {
      tmp += input[i] === expect[i] ? " " : "^";
    }
  } else {
    for (tmp = "  "; i < arr.length; i++) {
      tmp += (arr[i].added || arr[i].removed ? "^" : " ").repeat(Math.max(arr[i].count, 0));
      if (i + 1 < arr.length && (arr[i].added && arr[i + 1].removed || arr[i].removed && arr[i + 1].added)) {
        arr[i + 1].count -= arr[i].count;
      }
    }
  }
  return output + kleur_default.red(tmp);
}
function direct(input, expect, lenA = String(input).length, lenB = String(expect).length) {
  let gutter = 4;
  let lenC = Math.max(lenA, lenB);
  let typeA = typeof input, typeB = typeof expect;
  if (typeA !== typeB) {
    gutter = 2;
    let delA = gutter + lenC - lenA;
    let delB = gutter + lenC - lenB;
    input += " ".repeat(delA) + kleur_default.dim(`[${typeA}]`);
    expect += " ".repeat(delB) + kleur_default.dim(`[${typeB}]`);
    lenA += delA + typeA.length + 2;
    lenB += delB + typeB.length + 2;
    lenC = Math.max(lenA, lenB);
  }
  let output = colors["++"]("++" + expect + " ".repeat(gutter + lenC - lenB) + TITLE("(Expected)")) + "\n";
  return output + colors["--"]("--" + input + " ".repeat(gutter + lenC - lenA) + TITLE("(Actual)")) + "\n";
}
function sort(input, expect) {
  var k, i = 0, tmp, isArr = Array.isArray(input);
  var keys2 = [], out = isArr ? Array(input.length) : {};
  if (isArr) {
    for (i = 0; i < out.length; i++) {
      tmp = input[i];
      if (!tmp || typeof tmp !== "object") out[i] = tmp;
      else out[i] = sort(tmp, expect[i]);
    }
  } else {
    for (k in expect)
      keys2.push(k);
    for (; i < keys2.length; i++) {
      if (Object.prototype.hasOwnProperty.call(input, k = keys2[i])) {
        if (!(tmp = input[k]) || typeof tmp !== "object") out[k] = tmp;
        else out[k] = sort(tmp, expect[k]);
      }
    }
    for (k in input) {
      if (!out.hasOwnProperty(k)) {
        out[k] = input[k];
      }
    }
  }
  return out;
}
function circular() {
  var cache = /* @__PURE__ */ new Set();
  return function print(key, val) {
    if (val === void 0) return "[__VOID__]";
    if (typeof val === "number" && val !== val) return "[__NAN__]";
    if (typeof val === "bigint") return val.toString();
    if (!val || typeof val !== "object") return val;
    if (cache.has(val)) return "[Circular]";
    cache.add(val);
    return val;
  };
}
function stringify(input) {
  return JSON.stringify(input, circular(), 2).replace(/"\[__NAN__\]"/g, "NaN").replace(/"\[__VOID__\]"/g, "undefined");
}
function compare(input, expect) {
  if (Array.isArray(expect) && Array.isArray(input)) return arrays(input, expect);
  if (expect instanceof RegExp) return chars("" + input, "" + expect);
  let isA = input && typeof input == "object";
  let isB = expect && typeof expect == "object";
  if (isA && isB) input = sort(input, expect);
  if (isB) expect = stringify(expect);
  if (isA) input = stringify(input);
  if (expect && typeof expect == "object") {
    input = stringify(sort(input, expect));
    expect = stringify(expect);
  }
  isA = typeof input == "string";
  isB = typeof expect == "string";
  if (isA && /\r?\n/.test(input)) return lines(input, "" + expect);
  if (isB && /\r?\n/.test(expect)) return lines("" + input, expect);
  if (isA && isB) return chars(input, expect);
  return direct(input, expect);
}

// ../../../node_modules/.pnpm/uvu@0.5.6/node_modules/uvu/assert/index.mjs
function dedent(str) {
  str = str.replace(/\r?\n/g, "\n");
  let arr = str.match(/^[ \t]*(?=\S)/gm);
  let i = 0, min = 1 / 0, len = (arr || []).length;
  for (; i < len; i++) min = Math.min(min, arr[i].length);
  return len && min ? str.replace(new RegExp(`^[ \\t]{${min}}`, "gm"), "") : str;
}
var Assertion = class extends Error {
  constructor(opts = {}) {
    super(opts.message);
    this.name = "Assertion";
    this.code = "ERR_ASSERTION";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.details = opts.details || false;
    this.generated = !!opts.generated;
    this.operator = opts.operator;
    this.expects = opts.expects;
    this.actual = opts.actual;
  }
};
function assert(bool, actual, expects, operator, detailer, backup, msg) {
  if (bool) return;
  let message = msg || backup;
  if (msg instanceof Error) throw msg;
  let details = detailer && detailer(actual, expects);
  throw new Assertion({ actual, expects, operator, message, details, generated: !msg });
}
function ok2(val, msg) {
  assert(!!val, false, true, "ok", false, "Expected value to be truthy", msg);
}
function is2(val, exp, msg) {
  assert(val === exp, val, exp, "is", compare, "Expected values to be strictly equal:", msg);
}
function not(val, msg) {
  assert(!val, true, false, "not", false, "Expected value to be falsey", msg);
}
not.ok = not;
is2.not = function(val, exp, msg) {
  assert(val !== exp, val, exp, "is.not", false, "Expected values not to be strictly equal", msg);
};
not.equal = function(val, exp, msg) {
  assert(!dequal(val, exp), val, exp, "not.equal", false, "Expected values not to be deeply equal", msg);
};
not.type = function(val, exp, msg) {
  let tmp = typeof val;
  assert(tmp !== exp, tmp, exp, "not.type", false, `Expected "${tmp}" not to be "${exp}"`, msg);
};
not.instance = function(val, exp, msg) {
  let name2 = "`" + (exp.name || exp.constructor.name) + "`";
  assert(!(val instanceof exp), val, exp, "not.instance", false, `Expected value not to be an instance of ${name2}`, msg);
};
not.snapshot = function(val, exp, msg) {
  val = dedent(val);
  exp = dedent(exp);
  assert(val !== exp, val, exp, "not.snapshot", false, "Expected value not to match snapshot", msg);
};
not.fixture = function(val, exp, msg) {
  val = dedent(val);
  exp = dedent(exp);
  assert(val !== exp, val, exp, "not.fixture", false, "Expected value not to match fixture", msg);
};
not.match = function(val, exp, msg) {
  if (typeof exp === "string") {
    assert(!val.includes(exp), val, exp, "not.match", false, `Expected value not to include "${exp}" substring`, msg);
  } else {
    assert(!exp.test(val), val, exp, "not.match", false, `Expected value not to match \`${String(exp)}\` pattern`, msg);
  }
};
not.throws = function(blk, exp, msg) {
  if (!msg && typeof exp === "string") {
    msg = exp;
    exp = null;
  }
  try {
    blk();
  } catch (err) {
    if (typeof exp === "function") {
      assert(!exp(err), true, false, "not.throws", false, "Expected function not to throw matching exception", msg);
    } else if (exp instanceof RegExp) {
      assert(!exp.test(err.message), true, false, "not.throws", false, `Expected function not to throw exception matching \`${String(exp)}\` pattern`, msg);
    } else if (!exp) {
      assert(false, true, false, "not.throws", false, "Expected function not to throw", msg);
    }
  }
};

// ../../../node_modules/.pnpm/micromark-util-symbol@1.0.1/node_modules/micromark-util-symbol/codes.js
var codes = {
  carriageReturn: -5,
  lineFeed: -4,
  carriageReturnLineFeed: -3,
  horizontalTab: -2,
  virtualSpace: -1,
  eof: null,
  nul: 0,
  soh: 1,
  stx: 2,
  etx: 3,
  eot: 4,
  enq: 5,
  ack: 6,
  bel: 7,
  bs: 8,
  ht: 9,
  // `\t`
  lf: 10,
  // `\n`
  vt: 11,
  // `\v`
  ff: 12,
  // `\f`
  cr: 13,
  // `\r`
  so: 14,
  si: 15,
  dle: 16,
  dc1: 17,
  dc2: 18,
  dc3: 19,
  dc4: 20,
  nak: 21,
  syn: 22,
  etb: 23,
  can: 24,
  em: 25,
  sub: 26,
  esc: 27,
  fs: 28,
  gs: 29,
  rs: 30,
  us: 31,
  space: 32,
  exclamationMark: 33,
  // `!`
  quotationMark: 34,
  // `"`
  numberSign: 35,
  // `#`
  dollarSign: 36,
  // `$`
  percentSign: 37,
  // `%`
  ampersand: 38,
  // `&`
  apostrophe: 39,
  // `'`
  leftParenthesis: 40,
  // `(`
  rightParenthesis: 41,
  // `)`
  asterisk: 42,
  // `*`
  plusSign: 43,
  // `+`
  comma: 44,
  // `,`
  dash: 45,
  // `-`
  dot: 46,
  // `.`
  slash: 47,
  // `/`
  digit0: 48,
  // `0`
  digit1: 49,
  // `1`
  digit2: 50,
  // `2`
  digit3: 51,
  // `3`
  digit4: 52,
  // `4`
  digit5: 53,
  // `5`
  digit6: 54,
  // `6`
  digit7: 55,
  // `7`
  digit8: 56,
  // `8`
  digit9: 57,
  // `9`
  colon: 58,
  // `:`
  semicolon: 59,
  // `;`
  lessThan: 60,
  // `<`
  equalsTo: 61,
  // `=`
  greaterThan: 62,
  // `>`
  questionMark: 63,
  // `?`
  atSign: 64,
  // `@`
  uppercaseA: 65,
  // `A`
  uppercaseB: 66,
  // `B`
  uppercaseC: 67,
  // `C`
  uppercaseD: 68,
  // `D`
  uppercaseE: 69,
  // `E`
  uppercaseF: 70,
  // `F`
  uppercaseG: 71,
  // `G`
  uppercaseH: 72,
  // `H`
  uppercaseI: 73,
  // `I`
  uppercaseJ: 74,
  // `J`
  uppercaseK: 75,
  // `K`
  uppercaseL: 76,
  // `L`
  uppercaseM: 77,
  // `M`
  uppercaseN: 78,
  // `N`
  uppercaseO: 79,
  // `O`
  uppercaseP: 80,
  // `P`
  uppercaseQ: 81,
  // `Q`
  uppercaseR: 82,
  // `R`
  uppercaseS: 83,
  // `S`
  uppercaseT: 84,
  // `T`
  uppercaseU: 85,
  // `U`
  uppercaseV: 86,
  // `V`
  uppercaseW: 87,
  // `W`
  uppercaseX: 88,
  // `X`
  uppercaseY: 89,
  // `Y`
  uppercaseZ: 90,
  // `Z`
  leftSquareBracket: 91,
  // `[`
  backslash: 92,
  // `\`
  rightSquareBracket: 93,
  // `]`
  caret: 94,
  // `^`
  underscore: 95,
  // `_`
  graveAccent: 96,
  // `` ` ``
  lowercaseA: 97,
  // `a`
  lowercaseB: 98,
  // `b`
  lowercaseC: 99,
  // `c`
  lowercaseD: 100,
  // `d`
  lowercaseE: 101,
  // `e`
  lowercaseF: 102,
  // `f`
  lowercaseG: 103,
  // `g`
  lowercaseH: 104,
  // `h`
  lowercaseI: 105,
  // `i`
  lowercaseJ: 106,
  // `j`
  lowercaseK: 107,
  // `k`
  lowercaseL: 108,
  // `l`
  lowercaseM: 109,
  // `m`
  lowercaseN: 110,
  // `n`
  lowercaseO: 111,
  // `o`
  lowercaseP: 112,
  // `p`
  lowercaseQ: 113,
  // `q`
  lowercaseR: 114,
  // `r`
  lowercaseS: 115,
  // `s`
  lowercaseT: 116,
  // `t`
  lowercaseU: 117,
  // `u`
  lowercaseV: 118,
  // `v`
  lowercaseW: 119,
  // `w`
  lowercaseX: 120,
  // `x`
  lowercaseY: 121,
  // `y`
  lowercaseZ: 122,
  // `z`
  leftCurlyBrace: 123,
  // `{`
  verticalBar: 124,
  // `|`
  rightCurlyBrace: 125,
  // `}`
  tilde: 126,
  // `~`
  del: 127,
  // Unicode Specials block.
  byteOrderMarker: 65279,
  // Unicode Specials block.
  replacementCharacter: 65533
  // `�`
};

// ../../../node_modules/.pnpm/micromark-util-symbol@1.0.1/node_modules/micromark-util-symbol/constants.js
var constants = {
  attentionSideBefore: 1,
  // Symbol to mark an attention sequence as before content: `*a`
  attentionSideAfter: 2,
  // Symbol to mark an attention sequence as after content: `a*`
  atxHeadingOpeningFenceSizeMax: 6,
  // 6 number signs is fine, 7 isn’t.
  autolinkDomainSizeMax: 63,
  // 63 characters is fine, 64 is too many.
  autolinkSchemeSizeMax: 32,
  // 32 characters is fine, 33 is too many.
  cdataOpeningString: "CDATA[",
  // And preceded by `<![`.
  characterGroupWhitespace: 1,
  // Symbol used to indicate a character is whitespace
  characterGroupPunctuation: 2,
  // Symbol used to indicate a character is punctuation
  characterReferenceDecimalSizeMax: 7,
  // `&#9999999;`.
  characterReferenceHexadecimalSizeMax: 6,
  // `&#xff9999;`.
  characterReferenceNamedSizeMax: 31,
  // `&CounterClockwiseContourIntegral;`.
  codeFencedSequenceSizeMin: 3,
  // At least 3 ticks or tildes are needed.
  contentTypeDocument: "document",
  contentTypeFlow: "flow",
  contentTypeContent: "content",
  contentTypeString: "string",
  contentTypeText: "text",
  hardBreakPrefixSizeMin: 2,
  // At least 2 trailing spaces are needed.
  htmlRaw: 1,
  // Symbol for `<script>`
  htmlComment: 2,
  // Symbol for `<!---->`
  htmlInstruction: 3,
  // Symbol for `<?php?>`
  htmlDeclaration: 4,
  // Symbol for `<!doctype>`
  htmlCdata: 5,
  // Symbol for `<![CDATA[]]>`
  htmlBasic: 6,
  // Symbol for `<div`
  htmlComplete: 7,
  // Symbol for `<x>`
  htmlRawSizeMax: 8,
  // Length of `textarea`.
  linkResourceDestinationBalanceMax: 32,
  // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>
  linkReferenceSizeMax: 999,
  // See: <https://spec.commonmark.org/0.30/#link-label>
  listItemValueSizeMax: 10,
  // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>
  numericBaseDecimal: 10,
  numericBaseHexadecimal: 16,
  tabSize: 4,
  // Tabs have a hard-coded size of 4, per CommonMark.
  thematicBreakMarkerCountMin: 3,
  // At least 3 asterisks, dashes, or underscores are needed.
  v8MaxSafeChunkSize: 1e4
  // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.
};

// ../../../node_modules/.pnpm/micromark-util-symbol@1.0.1/node_modules/micromark-util-symbol/types.js
var types2 = {
  // Generic type for data, such as in a title, a destination, etc.
  data: "data",
  // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).
  // Such as, between a fenced code fence and an info string.
  whitespace: "whitespace",
  // Generic type for line endings (line feed, carriage return, carriage return +
  // line feed).
  lineEnding: "lineEnding",
  // A line ending, but ending a blank line.
  lineEndingBlank: "lineEndingBlank",
  // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a
  // line.
  linePrefix: "linePrefix",
  // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a
  // line.
  lineSuffix: "lineSuffix",
  // Whole ATX heading:
  //
  // ```markdown
  // #
  // ## Alpha
  // ### Bravo ###
  // ```
  //
  // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.
  atxHeading: "atxHeading",
  // Sequence of number signs in an ATX heading (`###`).
  atxHeadingSequence: "atxHeadingSequence",
  // Content in an ATX heading (`alpha`).
  // Includes text.
  atxHeadingText: "atxHeadingText",
  // Whole autolink (`<https://example.com>` or `<admin@example.com>`)
  // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.
  autolink: "autolink",
  // Email autolink w/o markers (`admin@example.com`)
  autolinkEmail: "autolinkEmail",
  // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).
  autolinkMarker: "autolinkMarker",
  // Protocol autolink w/o markers (`https://example.com`)
  autolinkProtocol: "autolinkProtocol",
  // A whole character escape (`\-`).
  // Includes `escapeMarker` and `characterEscapeValue`.
  characterEscape: "characterEscape",
  // The escaped character (`-`).
  characterEscapeValue: "characterEscapeValue",
  // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).
  // Includes `characterReferenceMarker`, an optional
  // `characterReferenceMarkerNumeric`, in which case an optional
  // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.
  characterReference: "characterReference",
  // The start or end marker (`&` or `;`).
  characterReferenceMarker: "characterReferenceMarker",
  // Mark reference as numeric (`#`).
  characterReferenceMarkerNumeric: "characterReferenceMarkerNumeric",
  // Mark reference as numeric (`x` or `X`).
  characterReferenceMarkerHexadecimal: "characterReferenceMarkerHexadecimal",
  // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).
  characterReferenceValue: "characterReferenceValue",
  // Whole fenced code:
  //
  // ````markdown
  // ```js
  // alert(1)
  // ```
  // ````
  codeFenced: "codeFenced",
  // A fenced code fence, including whitespace, sequence, info, and meta
  // (` ```js `).
  codeFencedFence: "codeFencedFence",
  // Sequence of grave accent or tilde characters (` ``` `) in a fence.
  codeFencedFenceSequence: "codeFencedFenceSequence",
  // Info word (`js`) in a fence.
  // Includes string.
  codeFencedFenceInfo: "codeFencedFenceInfo",
  // Meta words (`highlight="1"`) in a fence.
  // Includes string.
  codeFencedFenceMeta: "codeFencedFenceMeta",
  // A line of code.
  codeFlowValue: "codeFlowValue",
  // Whole indented code:
  //
  // ```markdown
  //     alert(1)
  // ```
  //
  // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.
  codeIndented: "codeIndented",
  // A text code (``` `alpha` ```).
  // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include
  // `codeTextPadding`.
  codeText: "codeText",
  codeTextData: "codeTextData",
  // A space or line ending right after or before a tick.
  codeTextPadding: "codeTextPadding",
  // A text code fence (` `` `).
  codeTextSequence: "codeTextSequence",
  // Whole content:
  //
  // ```markdown
  // [a]: b
  // c
  // =
  // d
  // ```
  //
  // Includes `paragraph` and `definition`.
  content: "content",
  // Whole definition:
  //
  // ```markdown
  // [micromark]: https://github.com/micromark/micromark
  // ```
  //
  // Includes `definitionLabel`, `definitionMarker`, `whitespace`,
  // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.
  definition: "definition",
  // Destination of a definition (`https://github.com/micromark/micromark` or
  // `<https://github.com/micromark/micromark>`).
  // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.
  definitionDestination: "definitionDestination",
  // Enclosed destination of a definition
  // (`<https://github.com/micromark/micromark>`).
  // Includes `definitionDestinationLiteralMarker` and optionally
  // `definitionDestinationString`.
  definitionDestinationLiteral: "definitionDestinationLiteral",
  // Markers of an enclosed definition destination (`<` or `>`).
  definitionDestinationLiteralMarker: "definitionDestinationLiteralMarker",
  // Unenclosed destination of a definition
  // (`https://github.com/micromark/micromark`).
  // Includes `definitionDestinationString`.
  definitionDestinationRaw: "definitionDestinationRaw",
  // Text in an destination (`https://github.com/micromark/micromark`).
  // Includes string.
  definitionDestinationString: "definitionDestinationString",
  // Label of a definition (`[micromark]`).
  // Includes `definitionLabelMarker` and `definitionLabelString`.
  definitionLabel: "definitionLabel",
  // Markers of a definition label (`[` or `]`).
  definitionLabelMarker: "definitionLabelMarker",
  // Value of a definition label (`micromark`).
  // Includes string.
  definitionLabelString: "definitionLabelString",
  // Marker between a label and a destination (`:`).
  definitionMarker: "definitionMarker",
  // Title of a definition (`"x"`, `'y'`, or `(z)`).
  // Includes `definitionTitleMarker` and optionally `definitionTitleString`.
  definitionTitle: "definitionTitle",
  // Marker around a title of a definition (`"`, `'`, `(`, or `)`).
  definitionTitleMarker: "definitionTitleMarker",
  // Data without markers in a title (`z`).
  // Includes string.
  definitionTitleString: "definitionTitleString",
  // Emphasis (`*alpha*`).
  // Includes `emphasisSequence` and `emphasisText`.
  emphasis: "emphasis",
  // Sequence of emphasis markers (`*` or `_`).
  emphasisSequence: "emphasisSequence",
  // Emphasis text (`alpha`).
  // Includes text.
  emphasisText: "emphasisText",
  // The character escape marker (`\`).
  escapeMarker: "escapeMarker",
  // A hard break created with a backslash (`\\n`).
  // Includes `escapeMarker` (does not include the line ending)
  hardBreakEscape: "hardBreakEscape",
  // A hard break created with trailing spaces (`  \n`).
  // Does not include the line ending.
  hardBreakTrailing: "hardBreakTrailing",
  // Flow HTML:
  //
  // ```markdown
  // <div
  // ```
  //
  // Inlcudes `lineEnding`, `htmlFlowData`.
  htmlFlow: "htmlFlow",
  htmlFlowData: "htmlFlowData",
  // HTML in text (the tag in `a <i> b`).
  // Includes `lineEnding`, `htmlTextData`.
  htmlText: "htmlText",
  htmlTextData: "htmlTextData",
  // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or
  // `![alpha]`).
  // Includes `label` and an optional `resource` or `reference`.
  image: "image",
  // Whole link label (`[*alpha*]`).
  // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.
  label: "label",
  // Text in an label (`*alpha*`).
  // Includes text.
  labelText: "labelText",
  // Start a link label (`[`).
  // Includes a `labelMarker`.
  labelLink: "labelLink",
  // Start an image label (`![`).
  // Includes `labelImageMarker` and `labelMarker`.
  labelImage: "labelImage",
  // Marker of a label (`[` or `]`).
  labelMarker: "labelMarker",
  // Marker to start an image (`!`).
  labelImageMarker: "labelImageMarker",
  // End a label (`]`).
  // Includes `labelMarker`.
  labelEnd: "labelEnd",
  // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).
  // Includes `label` and an optional `resource` or `reference`.
  link: "link",
  // Whole paragraph:
  //
  // ```markdown
  // alpha
  // bravo.
  // ```
  //
  // Includes text.
  paragraph: "paragraph",
  // A reference (`[alpha]` or `[]`).
  // Includes `referenceMarker` and an optional `referenceString`.
  reference: "reference",
  // A reference marker (`[` or `]`).
  referenceMarker: "referenceMarker",
  // Reference text (`alpha`).
  // Includes string.
  referenceString: "referenceString",
  // A resource (`(https://example.com "alpha")`).
  // Includes `resourceMarker`, an optional `resourceDestination` with an optional
  // `whitespace` and `resourceTitle`.
  resource: "resource",
  // A resource destination (`https://example.com`).
  // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.
  resourceDestination: "resourceDestination",
  // A literal resource destination (`<https://example.com>`).
  // Includes `resourceDestinationLiteralMarker` and optionally
  // `resourceDestinationString`.
  resourceDestinationLiteral: "resourceDestinationLiteral",
  // A resource destination marker (`<` or `>`).
  resourceDestinationLiteralMarker: "resourceDestinationLiteralMarker",
  // A raw resource destination (`https://example.com`).
  // Includes `resourceDestinationString`.
  resourceDestinationRaw: "resourceDestinationRaw",
  // Resource destination text (`https://example.com`).
  // Includes string.
  resourceDestinationString: "resourceDestinationString",
  // A resource marker (`(` or `)`).
  resourceMarker: "resourceMarker",
  // A resource title (`"alpha"`, `'alpha'`, or `(alpha)`).
  // Includes `resourceTitleMarker` and optionally `resourceTitleString`.
  resourceTitle: "resourceTitle",
  // A resource title marker (`"`, `'`, `(`, or `)`).
  resourceTitleMarker: "resourceTitleMarker",
  // Resource destination title (`alpha`).
  // Includes string.
  resourceTitleString: "resourceTitleString",
  // Whole setext heading:
  //
  // ```markdown
  // alpha
  // bravo
  // =====
  // ```
  //
  // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and
  // `setextHeadingLine`.
  setextHeading: "setextHeading",
  // Content in a setext heading (`alpha\nbravo`).
  // Includes text.
  setextHeadingText: "setextHeadingText",
  // Underline in a setext heading, including whitespace suffix (`==`).
  // Includes `setextHeadingLineSequence`.
  setextHeadingLine: "setextHeadingLine",
  // Sequence of equals or dash characters in underline in a setext heading (`-`).
  setextHeadingLineSequence: "setextHeadingLineSequence",
  // Strong (`**alpha**`).
  // Includes `strongSequence` and `strongText`.
  strong: "strong",
  // Sequence of strong markers (`**` or `__`).
  strongSequence: "strongSequence",
  // Strong text (`alpha`).
  // Includes text.
  strongText: "strongText",
  // Whole thematic break:
  //
  // ```markdown
  // * * *
  // ```
  //
  // Includes `thematicBreakSequence` and `whitespace`.
  thematicBreak: "thematicBreak",
  // A sequence of one or more thematic break markers (`***`).
  thematicBreakSequence: "thematicBreakSequence",
  // Whole block quote:
  //
  // ```markdown
  // > a
  // >
  // > b
  // ```
  //
  // Includes `blockQuotePrefix` and flow.
  blockQuote: "blockQuote",
  // The `>` or `> ` of a block quote.
  blockQuotePrefix: "blockQuotePrefix",
  // The `>` of a block quote prefix.
  blockQuoteMarker: "blockQuoteMarker",
  // The optional ` ` of a block quote prefix.
  blockQuotePrefixWhitespace: "blockQuotePrefixWhitespace",
  // Whole unordered list:
  //
  // ```markdown
  // - a
  //   b
  // ```
  //
  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
  // lines.
  listOrdered: "listOrdered",
  // Whole ordered list:
  //
  // ```markdown
  // 1. a
  //    b
  // ```
  //
  // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further
  // lines.
  listUnordered: "listUnordered",
  // The indent of further list item lines.
  listItemIndent: "listItemIndent",
  // A marker, as in, `*`, `+`, `-`, `.`, or `)`.
  listItemMarker: "listItemMarker",
  // The thing that starts a list item, such as `1. `.
  // Includes `listItemValue` if ordered, `listItemMarker`, and
  // `listItemPrefixWhitespace` (unless followed by a line ending).
  listItemPrefix: "listItemPrefix",
  // The whitespace after a marker.
  listItemPrefixWhitespace: "listItemPrefixWhitespace",
  // The numerical value of an ordered item.
  listItemValue: "listItemValue",
  // Internal types used for subtokenizers, compiled away
  chunkDocument: "chunkDocument",
  chunkContent: "chunkContent",
  chunkFlow: "chunkFlow",
  chunkText: "chunkText",
  chunkString: "chunkString"
};

// ../../../node_modules/.pnpm/micromark-util-symbol@1.0.1/node_modules/micromark-util-symbol/values.js
var values = {
  ht: "	",
  lf: "\n",
  cr: "\r",
  space: " ",
  exclamationMark: "!",
  quotationMark: '"',
  numberSign: "#",
  dollarSign: "$",
  percentSign: "%",
  ampersand: "&",
  apostrophe: "'",
  leftParenthesis: "(",
  rightParenthesis: ")",
  asterisk: "*",
  plusSign: "+",
  comma: ",",
  dash: "-",
  dot: ".",
  slash: "/",
  digit0: "0",
  digit1: "1",
  digit2: "2",
  digit3: "3",
  digit4: "4",
  digit5: "5",
  digit6: "6",
  digit7: "7",
  digit8: "8",
  digit9: "9",
  colon: ":",
  semicolon: ";",
  lessThan: "<",
  equalsTo: "=",
  greaterThan: ">",
  questionMark: "?",
  atSign: "@",
  uppercaseA: "A",
  uppercaseB: "B",
  uppercaseC: "C",
  uppercaseD: "D",
  uppercaseE: "E",
  uppercaseF: "F",
  uppercaseG: "G",
  uppercaseH: "H",
  uppercaseI: "I",
  uppercaseJ: "J",
  uppercaseK: "K",
  uppercaseL: "L",
  uppercaseM: "M",
  uppercaseN: "N",
  uppercaseO: "O",
  uppercaseP: "P",
  uppercaseQ: "Q",
  uppercaseR: "R",
  uppercaseS: "S",
  uppercaseT: "T",
  uppercaseU: "U",
  uppercaseV: "V",
  uppercaseW: "W",
  uppercaseX: "X",
  uppercaseY: "Y",
  uppercaseZ: "Z",
  leftSquareBracket: "[",
  backslash: "\\",
  rightSquareBracket: "]",
  caret: "^",
  underscore: "_",
  graveAccent: "`",
  lowercaseA: "a",
  lowercaseB: "b",
  lowercaseC: "c",
  lowercaseD: "d",
  lowercaseE: "e",
  lowercaseF: "f",
  lowercaseG: "g",
  lowercaseH: "h",
  lowercaseI: "i",
  lowercaseJ: "j",
  lowercaseK: "k",
  lowercaseL: "l",
  lowercaseM: "m",
  lowercaseN: "n",
  lowercaseO: "o",
  lowercaseP: "p",
  lowercaseQ: "q",
  lowercaseR: "r",
  lowercaseS: "s",
  lowercaseT: "t",
  lowercaseU: "u",
  lowercaseV: "v",
  lowercaseW: "w",
  lowercaseX: "x",
  lowercaseY: "y",
  lowercaseZ: "z",
  leftCurlyBrace: "{",
  verticalBar: "|",
  rightCurlyBrace: "}",
  tilde: "~",
  replacementCharacter: "\uFFFD"
};

// src/next/shortcodes/lib/util.ts
var findValue = (string3) => {
  let lookupValue = null;
  Object.entries(values).forEach(([key, value]) => {
    if (value === string3) {
      lookupValue = key;
    }
  });
  return lookupValue;
};
var findCode = (string3) => {
  if (!string3) {
    return null;
  }
  const lookup = findValue(string3);
  let lookupValue = null;
  if (lookup) {
    Object.entries(codes).forEach(([key, value]) => {
      if (key === lookup) {
        lookupValue = value;
      }
    });
  }
  return lookupValue;
};

// src/next/shortcodes/lib/factory-tag.ts
function factoryTag2(effects, ok3, nok, acorn, acornOptions, addResult, allowLazy, tagType, tagMarkerType, tagClosingMarkerType, tagSelfClosingMarker, tagNameType, tagNamePrimaryType, tagNameMemberMarkerType, tagNameMemberType, tagNamePrefixMarkerType, tagNameLocalType, tagExpressionAttributeType, tagExpressionAttributeMarkerType, tagExpressionAttributeValueType, tagAttributeType, tagAttributeNameType, tagAttributeNamePrimaryType, tagAttributeNamePrefixMarkerType, tagAttributeNameLocalType, tagAttributeInitializerMarkerType, tagAttributeValueLiteralType, tagAttributeValueLiteralMarkerType, tagAttributeValueLiteralValueType, tagAttributeValueExpressionType, tagAttributeValueExpressionMarkerType, tagAttributeValueExpressionValueType, pattern) {
  const self2 = this;
  let returnState;
  let marker;
  let startPoint;
  let tagOpenerIndex = 1;
  let tagCloserIndex = 1;
  let nameIndex = 1;
  const start3 = function(code3) {
    startPoint = self2.now();
    effects.enter(tagType);
    effects.enter(tagMarkerType);
    effects.consume(code3);
    if (pattern.start.length === 1) {
      effects.exit(tagMarkerType);
      return afterStart;
    }
    return tagOpenerSequence;
  };
  const tagOpenerSequence = function(code3) {
    const character = findCode(pattern.start[tagOpenerIndex]);
    if (code3 === character) {
      effects.consume(code3);
      if (pattern.start.length - 1 === tagOpenerIndex) {
        effects.exit(tagMarkerType);
        return afterStart;
      }
      tagOpenerIndex++;
      return tagOpenerSequence;
    }
    return nok;
  };
  const afterStart = function(code3) {
    returnState = beforeName;
    return optionalEsWhitespace(code3);
  };
  const beforeName = function(code3) {
    if (code3 === codes.slash) {
      effects.enter(tagClosingMarkerType);
      effects.consume(code3);
      effects.exit(tagClosingMarkerType);
      returnState = beforeClosingTagName;
      return optionalEsWhitespace;
    }
    if (code3 === codes.greaterThan) {
      return tagEnd(code3);
    }
    if (code3 !== codes.eof && start2(code3) && findCode(pattern.name[0]) === code3) {
      effects.enter(tagNameType);
      effects.enter(tagNamePrimaryType);
      effects.consume(code3);
      return primaryName;
    }
    return nok(code3);
  };
  const beforeClosingTagName = function(code3) {
    if (code3 === codes.greaterThan) {
      return tagEnd(code3);
    }
    if (code3 !== codes.eof && start2(code3)) {
      effects.enter(tagNameType);
      effects.enter(tagNamePrimaryType);
      effects.consume(code3);
      return primaryName;
    }
    return nok(code3);
  };
  const primaryName = function(code3) {
    const nextCharacterInName = pattern.name[nameIndex];
    const nextCodeInName = nextCharacterInName ? findCode(nextCharacterInName) : null;
    if (nextCodeInName === code3) {
      effects.consume(code3);
      nameIndex++;
      return primaryName;
    }
    nameIndex = 0;
    if (code3 === codes.dot || code3 === codes.slash || code3 === codes.colon || code3 === codes.greaterThan || code3 === findCode(pattern.end[0]) || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagNamePrimaryType);
      returnState = afterPrimaryName;
      return optionalEsWhitespace(code3);
    }
    return nok(code3);
  };
  const afterPrimaryName = function(code3) {
    if (code3 === codes.dot) {
      effects.enter(tagNameMemberMarkerType);
      effects.consume(code3);
      effects.exit(tagNameMemberMarkerType);
      returnState = beforeMemberName;
      return optionalEsWhitespace;
    }
    if (code3 === codes.colon) {
      effects.enter(tagNamePrefixMarkerType);
      effects.consume(code3);
      effects.exit(tagNamePrefixMarkerType);
      returnState = beforeLocalName;
      return optionalEsWhitespace;
    }
    if (code3 === findCode(pattern.end[0])) {
      const tagCloserSequence = function(code4) {
        const character = findCode(pattern.end[tagCloserIndex]);
        if (code4 === character) {
          if (pattern.end.length - 1 === tagCloserIndex) {
            effects.exit(tagNameType);
            return beforeAttribute(code4);
          }
          tagCloserIndex++;
          effects.consume(code4);
          return tagCloserSequence;
        }
        tagCloserIndex = 0;
        return nok;
      };
      if (pattern.end.length === 1) {
        effects.exit(tagNameType);
        return beforeAttribute(code3);
      } else {
        effects.consume(code3);
        return tagCloserSequence;
      }
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || code3 !== codes.eof && start2(code3)) {
      effects.exit(tagNameType);
      return beforeAttribute(code3);
    }
    if (code3 === codes.quotationMark) {
      effects.exit(tagNameType);
      effects.enter(tagAttributeType);
      effects.enter(tagAttributeNameType);
      effects.enter(tagAttributeNamePrimaryType);
      effects.exit(tagAttributeNamePrimaryType);
      effects.exit(tagAttributeNameType);
      effects.enter(tagAttributeInitializerMarkerType);
      effects.exit(tagAttributeInitializerMarkerType);
      return beforeAttributeValue(code3);
    }
    return nok(code3);
    crash(
      code3,
      "after name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  };
  const beforeMemberName = function(code3) {
    if (code3 !== codes.eof && start2(code3)) {
      effects.enter(tagNameMemberType);
      effects.consume(code3);
      return memberName;
    }
    return nok(code3);
    crash(
      code3,
      "before member name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  };
  const memberName = function(code3) {
    if (code3 === codes.dash || code3 !== codes.eof && cont2(code3)) {
      effects.consume(code3);
      return memberName;
    }
    if (code3 === codes.dot || code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagNameMemberType);
      returnState = afterMemberName;
      return optionalEsWhitespace(code3);
    }
    crash(
      code3,
      "in member name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (code3 === codes.atSign ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  };
  const afterMemberName = function(code3) {
    if (code3 === codes.dot) {
      effects.enter(tagNameMemberMarkerType);
      effects.consume(code3);
      effects.exit(tagNameMemberMarkerType);
      returnState = beforeMemberName;
      return optionalEsWhitespace;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || code3 !== codes.eof && start2(code3)) {
      effects.exit(tagNameType);
      return beforeAttribute(code3);
    }
    return nok(code3);
  };
  const beforeLocalName = function(code3) {
    if (code3 !== codes.eof && start2(code3)) {
      effects.enter(tagNameLocalType);
      effects.consume(code3);
      return localName;
    }
    crash(
      code3,
      "before local name",
      "a character that can start a name, such as a letter, `$`, or `_`" + (code3 === codes.plusSign || code3 !== null && code3 > codes.dot && code3 < codes.colon ? " (note: to create a link in MDX, use `[text](url)`)" : "")
    );
  };
  const localName = function(code3) {
    if (code3 === codes.dash || code3 !== codes.eof && cont2(code3)) {
      effects.consume(code3);
      return localName;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagNameLocalType);
      returnState = afterLocalName;
      return optionalEsWhitespace(code3);
    }
    crash(
      code3,
      "in local name",
      "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  };
  const afterLocalName = function(code3) {
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || code3 !== codes.eof && start2(code3)) {
      effects.exit(tagNameType);
      return beforeAttribute(code3);
    }
    if (code3 === findCode(pattern.end)) {
      effects.exit(tagNameType);
      return beforeAttribute(code3);
    }
    crash(
      code3,
      "after local name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag"
    );
  };
  const beforeAttribute = function(code3) {
    if (code3 === findCode(pattern.end[0])) {
      const tagCloserSequence = function(code4) {
        const character = findCode(pattern.end[tagCloserIndex]);
        if (code4 === character) {
          if (pattern.end.length - 1 === tagCloserIndex) {
            return beforeAttribute(code4);
          }
          tagCloserIndex++;
          effects.consume(code4);
          return tagCloserSequence;
        }
        tagCloserIndex = 0;
        return nok;
      };
      if (pattern.end.length === 1) {
        if (pattern.leaf) {
          effects.enter(tagSelfClosingMarker);
          effects.exit(tagSelfClosingMarker);
          returnState = selfClosing;
          return optionalEsWhitespace;
        } else {
          return tagEnd(code3);
        }
      } else {
        effects.consume(code3);
        return tagCloserSequence;
      }
    }
    if (code3 === findCode(pattern.end[pattern.end.length - 1])) {
      if (pattern.leaf) {
        effects.enter(tagSelfClosingMarker);
        effects.exit(tagSelfClosingMarker);
        returnState = selfClosing;
        return optionalEsWhitespace;
      } else {
        return tagEnd(code3);
      }
    }
    if (code3 === codes.greaterThan) {
      return tagEnd(code3);
    }
    if (code3 === codes.leftCurlyBrace) {
      ok2(startPoint, "expected `startPoint` to be defined");
      return factoryMdxExpression.call(
        self2,
        effects,
        afterAttributeExpression,
        tagExpressionAttributeType,
        tagExpressionAttributeMarkerType,
        tagExpressionAttributeValueType,
        acorn,
        acornOptions,
        addResult,
        true,
        false,
        allowLazy,
        startPoint.column
      )(code3);
    }
    if (code3 !== codes.eof && start2(code3)) {
      effects.enter(tagAttributeType);
      effects.enter(tagAttributeNameType);
      effects.enter(tagAttributeNamePrimaryType);
      effects.consume(code3);
      return attributePrimaryName;
    }
    return nok;
  };
  const afterAttributeExpression = function(code3) {
    returnState = beforeAttribute;
    return optionalEsWhitespace(code3);
  };
  const attributePrimaryName = function(code3) {
    if (code3 === codes.dash || code3 !== codes.eof && cont2(code3)) {
      effects.consume(code3);
      return attributePrimaryName;
    }
    if (code3 === codes.slash || code3 === codes.colon || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagAttributeNamePrimaryType);
      returnState = afterAttributePrimaryName;
      return optionalEsWhitespace(code3);
    }
    return nok(code3);
  };
  const afterAttributePrimaryName = function(code3) {
    if (code3 === codes.colon) {
      effects.enter(tagAttributeNamePrefixMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeNamePrefixMarkerType);
      returnState = beforeAttributeLocalName;
      return optionalEsWhitespace;
    }
    if (code3 === codes.equalsTo) {
      effects.exit(tagAttributeNameType);
      effects.enter(tagAttributeInitializerMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeInitializerMarkerType);
      returnState = beforeAttributeValue;
      return optionalEsWhitespace;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || code3 !== codes.eof && start2(code3)) {
      effects.exit(tagAttributeNameType);
      effects.exit(tagAttributeType);
      returnState = beforeAttribute;
      return optionalEsWhitespace(code3);
    }
    return nok(code3);
  };
  const beforeAttributeLocalName = function(code3) {
    if (code3 !== codes.eof && start2(code3)) {
      effects.enter(tagAttributeNameLocalType);
      effects.consume(code3);
      return attributeLocalName;
    }
    crash(
      code3,
      "before local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  };
  const attributeLocalName = function(code3) {
    if (code3 === codes.dash || code3 !== codes.eof && cont2(code3)) {
      effects.consume(code3);
      return attributeLocalName;
    }
    if (code3 === codes.slash || code3 === codes.equalsTo || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
      effects.exit(tagAttributeNameLocalType);
      effects.exit(tagAttributeNameType);
      returnState = afterAttributeLocalName;
      return optionalEsWhitespace(code3);
    }
    crash(
      code3,
      "in local attribute name",
      "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag"
    );
  };
  const afterAttributeLocalName = function(code3) {
    if (code3 === codes.equalsTo) {
      effects.enter(tagAttributeInitializerMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeInitializerMarkerType);
      returnState = beforeAttributeValue;
      return optionalEsWhitespace;
    }
    if (code3 === codes.slash || code3 === codes.greaterThan || code3 === codes.leftCurlyBrace || code3 !== codes.eof && start2(code3)) {
      effects.exit(tagAttributeType);
      return beforeAttribute(code3);
    }
    crash(
      code3,
      "after local attribute name",
      "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag"
    );
  };
  const beforeAttributeValue = function(code3) {
    if (code3 === codes.quotationMark || code3 === codes.apostrophe) {
      effects.enter(tagAttributeValueLiteralType);
      effects.enter(tagAttributeValueLiteralMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeValueLiteralMarkerType);
      marker = code3;
      return attributeValueQuotedStart;
    }
    if (code3 === codes.leftCurlyBrace) {
      ok2(startPoint, "expected `startPoint` to be defined");
      return factoryMdxExpression.call(
        self2,
        effects,
        afterAttributeValueExpression,
        tagAttributeValueExpressionType,
        tagAttributeValueExpressionMarkerType,
        tagAttributeValueExpressionValueType,
        acorn,
        acornOptions,
        addResult,
        false,
        false,
        allowLazy,
        startPoint.column
      )(code3);
    }
    return nok(code3);
  };
  const afterAttributeValueExpression = function(code3) {
    effects.exit(tagAttributeType);
    returnState = beforeAttribute;
    return optionalEsWhitespace(code3);
  };
  const attributeValueQuotedStart = function(code3) {
    ok2(marker !== void 0, "expected `marker` to be defined");
    if (code3 === codes.eof) {
      return nok(code3);
    }
    if (code3 === marker) {
      effects.enter(tagAttributeValueLiteralMarkerType);
      effects.consume(code3);
      effects.exit(tagAttributeValueLiteralMarkerType);
      effects.exit(tagAttributeValueLiteralType);
      effects.exit(tagAttributeType);
      marker = void 0;
      returnState = beforeAttribute;
      return optionalEsWhitespace;
    }
    if (markdownLineEnding(code3)) {
      returnState = attributeValueQuotedStart;
      return optionalEsWhitespace(code3);
    }
    effects.enter(tagAttributeValueLiteralValueType);
    return attributeValueQuoted(code3);
  };
  const attributeValueQuoted = function(code3) {
    if (code3 === codes.eof || code3 === marker || markdownLineEnding(code3)) {
      effects.exit(tagAttributeValueLiteralValueType);
      return attributeValueQuotedStart(code3);
    }
    effects.consume(code3);
    return attributeValueQuoted;
  };
  const selfClosing = function(code3) {
    if (code3 === findCode(pattern.end[pattern.end.length - 1])) {
      return tagEnd(code3);
    }
    crash(
      code3,
      "after self-closing slash",
      "`>` to end the tag" + (code3 === codes.asterisk || code3 === codes.slash ? " (note: JS comments in JSX tags are not supported in MDX)" : "")
    );
  };
  const tagEnd = function(code3) {
    effects.enter(tagMarkerType);
    effects.consume(code3);
    effects.exit(tagMarkerType);
    effects.exit(tagType);
    return ok3;
  };
  const optionalEsWhitespace = function(code3) {
    if (markdownLineEnding(code3)) {
      if (allowLazy) {
        effects.enter(types2.lineEnding);
        effects.consume(code3);
        effects.exit(types2.lineEnding);
        return factorySpace(
          effects,
          optionalEsWhitespace,
          types2.linePrefix,
          constants.tabSize
        );
      }
      return effects.attempt(
        lazyLineEnd,
        factorySpace(
          effects,
          optionalEsWhitespace,
          types2.linePrefix,
          constants.tabSize
        ),
        crashEol
      )(code3);
    }
    if (markdownSpace(code3) || unicodeWhitespace(code3)) {
      effects.enter("esWhitespace");
      return optionalEsWhitespaceContinue(code3);
    }
    return returnState(code3);
  };
  const optionalEsWhitespaceContinue = function(code3) {
    if (markdownLineEnding(code3) || !(markdownSpace(code3) || unicodeWhitespace(code3))) {
      effects.exit("esWhitespace");
      return optionalEsWhitespace(code3);
    }
    effects.consume(code3);
    return optionalEsWhitespaceContinue;
  };
  function crashEol() {
    throw new VFileMessage(
      "Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
      self2.now(),
      "micromark-extension-mdx-jsx:unexpected-eof"
    );
  }
  function crash(code3, at3, expect) {
    throw new VFileMessage(
      "Unexpected " + (code3 === codes.eof ? "end of file" : "character `" + (code3 === codes.graveAccent ? "` ` `" : String.fromCodePoint(code3)) + "` (" + serializeCharCode2(code3) + ")") + " " + at3 + ", expected " + expect,
      self2.now(),
      "micromark-extension-mdx-jsx:unexpected-" + (code3 === codes.eof ? "eof" : "character")
    );
  }
  return start3;
}
var tokenizeLazyLineEnd = function(effects, ok3, nok) {
  const self2 = this;
  const start3 = function(code3) {
    ok2(markdownLineEnding(code3), "expected eol");
    effects.enter(types2.lineEnding);
    effects.consume(code3);
    effects.exit(types2.lineEnding);
    return lineStart;
  };
  const lineStart = function(code3) {
    return self2.parser.lazy[self2.now().line] ? nok(code3) : ok3(code3);
  };
  return start3;
};
var serializeCharCode2 = function(code3) {
  return "U+" + code3.toString(constants.numericBaseHexadecimal).toUpperCase().padStart(4, "0");
};
var lazyLineEnd = { tokenize: tokenizeLazyLineEnd, partial: true };

// src/next/shortcodes/lib/jsx-text.ts
var jsxText2 = function(acorn, acornOptions, addResult, pattern) {
  const tokenizeJsxText = function(effects, ok3, nok) {
    const self2 = this;
    return factoryTag2.call(
      self2,
      effects,
      ok3,
      nok,
      acorn,
      acornOptions,
      addResult,
      true,
      "mdxJsxTextTag",
      "mdxJsxTextTagMarker",
      "mdxJsxTextTagClosingMarker",
      "mdxJsxTextTagSelfClosingMarker",
      "mdxJsxTextTagName",
      "mdxJsxTextTagNamePrimary",
      "mdxJsxTextTagNameMemberMarker",
      "mdxJsxTextTagNameMember",
      "mdxJsxTextTagNamePrefixMarker",
      "mdxJsxTextTagNameLocal",
      "mdxJsxTextTagExpressionAttribute",
      "mdxJsxTextTagExpressionAttributeMarker",
      "mdxJsxTextTagExpressionAttributeValue",
      "mdxJsxTextTagAttribute",
      "mdxJsxTextTagAttributeName",
      "mdxJsxTextTagAttributeNamePrimary",
      "mdxJsxTextTagAttributeNamePrefixMarker",
      "mdxJsxTextTagAttributeNameLocal",
      "mdxJsxTextTagAttributeInitializerMarker",
      "mdxJsxTextTagAttributeValueLiteral",
      "mdxJsxTextTagAttributeValueLiteralMarker",
      "mdxJsxTextTagAttributeValueLiteralValue",
      "mdxJsxTextTagAttributeValueExpression",
      "mdxJsxTextTagAttributeValueExpressionMarker",
      "mdxJsxTextTagAttributeValueExpressionValue",
      pattern
    );
  };
  return { tokenize: tokenizeJsxText };
};

// src/next/shortcodes/lib/jsx-flow.ts
var jsxFlow2 = function(acorn, acornOptions, addResult, pattern) {
  const tokenizeJsxFlow = function(effects, ok3, nok) {
    const self2 = this;
    const start3 = function(code3) {
      return factoryTag2.call(
        self2,
        effects,
        factorySpace(effects, after, types2.whitespace),
        nok,
        acorn,
        acornOptions,
        addResult,
        false,
        "mdxJsxFlowTag",
        "mdxJsxFlowTagMarker",
        "mdxJsxFlowTagClosingMarker",
        "mdxJsxFlowTagSelfClosingMarker",
        "mdxJsxFlowTagName",
        "mdxJsxFlowTagNamePrimary",
        "mdxJsxFlowTagNameMemberMarker",
        "mdxJsxFlowTagNameMember",
        "mdxJsxFlowTagNamePrefixMarker",
        "mdxJsxFlowTagNameLocal",
        "mdxJsxFlowTagExpressionAttribute",
        "mdxJsxFlowTagExpressionAttributeMarker",
        "mdxJsxFlowTagExpressionAttributeValue",
        "mdxJsxFlowTagAttribute",
        "mdxJsxFlowTagAttributeName",
        "mdxJsxFlowTagAttributeNamePrimary",
        "mdxJsxFlowTagAttributeNamePrefixMarker",
        "mdxJsxFlowTagAttributeNameLocal",
        "mdxJsxFlowTagAttributeInitializerMarker",
        "mdxJsxFlowTagAttributeValueLiteral",
        "mdxJsxFlowTagAttributeValueLiteralMarker",
        "mdxJsxFlowTagAttributeValueLiteralValue",
        "mdxJsxFlowTagAttributeValueExpression",
        "mdxJsxFlowTagAttributeValueExpressionMarker",
        "mdxJsxFlowTagAttributeValueExpressionValue",
        pattern
      )(code3);
    };
    const after = function(code3) {
      const character = findCode(pattern.start[0]);
      if (code3 === character) {
        return start3(code3);
      }
      if (code3 === codes.eof) {
        return ok3(code3);
      }
      if (markdownLineEndingOrSpace(code3)) {
        return ok3(code3);
      }
      return nok(code3);
    };
    return start3;
  };
  return {
    tokenize: tokenizeJsxFlow,
    concrete: true
  };
};

// src/next/shortcodes/lib/syntax.ts
function mdxJsx2(options = {}) {
  const acorn = options.acorn;
  let acornOptions;
  if (acorn) {
    if (!acorn.parse || !acorn.parseExpressionAt) {
      throw new Error(
        "Expected a proper `acorn` instance passed in as `options.acorn`"
      );
    }
    acornOptions = Object.assign(
      { ecmaVersion: 2020, sourceType: "module" },
      options.acornOptions,
      { locations: true }
    );
  } else if (options.acornOptions || options.addResult) {
    throw new Error(
      "Expected an `acorn` instance passed in as `options.acorn`"
    );
  }
  const patterns = options.patterns || [];
  const flowRules = {};
  const textRules = {};
  patterns.forEach((pattern) => {
    const firstCharacter = findCode(pattern.start[0])?.toString();
    if (!firstCharacter) {
      return;
    }
    if (pattern.type === "flow") {
      const existing = flowRules[firstCharacter];
      flowRules[firstCharacter] = existing ? [
        ...existing,
        jsxFlow2(acorn, acornOptions, options.addResult, pattern)
      ] : [jsxFlow2(acorn, acornOptions, options.addResult, pattern)];
    } else {
      const existing = textRules[firstCharacter];
      textRules[firstCharacter] = existing ? [
        ...existing,
        jsxText2(acorn, acornOptions, options.addResult, pattern)
      ] : [jsxText2(acorn, acornOptions, options.addResult, pattern)];
    }
  });
  let disabledTokens = [];
  if (options.skipHTML) {
    disabledTokens = ["htmlFlow", "htmlText"];
  }
  return {
    flow: flowRules,
    text: textRules,
    disable: { null: disabledTokens }
  };
}

// src/next/parse/markdown.ts
var fromMarkdown2 = (value, field) => {
  const patterns = getFieldPatterns(field);
  const acornDefault = acorn_exports;
  const skipHTML = false;
  const tree = fromMarkdown(value, {
    extensions: [
      gfm(),
      mdxJsx2({ acorn: acornDefault, patterns, addResult: true, skipHTML })
    ],
    mdastExtensions: [gfmFromMarkdown(), mdxJsxFromMarkdown2({ patterns })]
  });
  return tree;
};

// ../../../node_modules/.pnpm/mdast-util-compact@4.1.1/node_modules/mdast-util-compact/lib/index.js
function compact(tree) {
  visit(tree, function(child, index2, parent) {
    if (parent && index2 && (child.type === "text" || child.type === "blockquote")) {
      const previous3 = parent.children[index2 - 1];
      if (previous3.type === child.type) {
        if ("value" in child) {
          previous3.value += child.value;
        }
        if ("children" in child) {
          previous3.children = previous3.children.concat(child.children);
        }
        parent.children.splice(index2, 1);
        if (previous3.position && child.position) {
          previous3.position.end = child.position.end;
        }
        return index2;
      }
    }
  });
  return tree;
}

// src/parse/remarkToPlate.ts
var import_lodash = __toESM(require_lodash());

// src/parse/acorn.ts
var extractAttributes = (attributes2, fields, imageCallback) => {
  const properties = {};
  attributes2?.forEach((attribute) => {
    assertType(attribute, "mdxJsxAttribute");
    const field = fields.find((field2) => field2.name === attribute.name);
    if (!field) {
      throw new Error(
        `Unable to find field definition for property "${attribute.name}"`
      );
    }
    try {
      properties[attribute.name] = extractAttribute(
        attribute,
        field,
        imageCallback
      );
    } catch (e) {
      if (e instanceof Error) {
        throw new Error(
          `Unable to parse field value for field "${field.name}" (type: ${field.type}). ${e.message}`
        );
      }
      throw e;
    }
  });
  return properties;
};
var extractAttribute = (attribute, field, imageCallback) => {
  switch (field.type) {
    case "boolean":
    case "number":
      return extractScalar(extractExpression(attribute), field);
    case "datetime":
    case "string":
      if (field.list) {
        return extractScalar(extractExpression(attribute), field);
      } else {
        return extractString(attribute, field);
      }
    case "image":
      if (field.list) {
        const values2 = extractScalar(
          extractExpression(attribute),
          field
        );
        return values2.split(",").map((value) => imageCallback(value));
      } else {
        const value = extractString(attribute, field);
        return imageCallback(value);
      }
    case "reference":
      if (field.list) {
        return extractScalar(extractExpression(attribute), field);
      } else {
        return extractString(attribute, field);
      }
    case "object":
      return extractObject(extractExpression(attribute), field, imageCallback);
    case "rich-text":
      const JSXString = extractRaw(attribute);
      if (JSXString) {
        return parseMDX(JSXString, field, imageCallback);
      } else {
        return {};
      }
    default:
      throw new Error(`Extract attribute: Unhandled field type ${field.type}`);
  }
};
var extractScalar = (attribute, field) => {
  if (field.list) {
    assertType(attribute.expression, "ArrayExpression");
    return attribute.expression.elements.map((element2) => {
      assertHasType(element2);
      assertType(element2, "Literal");
      return element2.value;
    });
  } else {
    assertType(attribute.expression, "Literal");
    return attribute.expression.value;
  }
};
var extractObject = (attribute, field, imageCallback) => {
  if (field.list) {
    assertType(attribute.expression, "ArrayExpression");
    return attribute.expression.elements.map((element2) => {
      assertHasType(element2);
      assertType(element2, "ObjectExpression");
      return extractObjectExpression(element2, field, imageCallback);
    });
  } else {
    assertType(attribute.expression, "ObjectExpression");
    return extractObjectExpression(attribute.expression, field, imageCallback);
  }
};
var extractObjectExpression = (expression, field, imageCallback) => {
  const properties = {};
  expression.properties?.forEach((property) => {
    assertType(property, "Property");
    const { key, value } = extractKeyValue(property, field, imageCallback);
    properties[key] = value;
  });
  return properties;
};
var getField = (objectField, name2) => {
  if (objectField.fields) {
    if (typeof objectField.fields === "string") {
      throw new Error("Global templates not supported");
    }
    return objectField.fields.find((f) => f.name === name2);
  }
};
var extractKeyValue = (property, parentField, imageCallback) => {
  assertType(property.key, "Identifier");
  const key = property.key.name;
  const field = getField(parentField, key);
  if (field?.type === "object") {
    if (field.list) {
      assertType(property.value, "ArrayExpression");
      const value = property.value.elements.map((element2) => {
        assertHasType(element2);
        assertType(element2, "ObjectExpression");
        return extractObjectExpression(element2, field, imageCallback);
      });
      return { key, value };
    } else {
      assertType(property.value, "ObjectExpression");
      const value = extractObjectExpression(
        property.value,
        field,
        imageCallback
      );
      return { key, value };
    }
  } else if (field?.list) {
    assertType(property.value, "ArrayExpression");
    const value = property.value.elements.map((element2) => {
      assertHasType(element2);
      assertType(element2, "Literal");
      return element2.value;
    });
    return { key, value };
  } else if (field?.type === "rich-text") {
    assertType(property.value, "Literal");
    const raw = property.value.value;
    if (typeof raw === "string") {
      return { key, value: parseMDX(raw, field, imageCallback) };
    }
    throw new Error(`Unable to parse rich-text`);
  } else {
    assertType(property.value, "Literal");
    return { key, value: property.value.value };
  }
};
var extractStatement = (attribute) => {
  const body = attribute.data?.estree?.body;
  if (body) {
    if (body[0]) {
      assertType(body[0], "ExpressionStatement");
      return body[0];
    }
  }
  throw new Error(`Unable to extract body from expression`);
};
var extractString = (attribute, field) => {
  if (attribute.type === "mdxJsxAttribute") {
    if (typeof attribute.value === "string") {
      return attribute.value;
    }
  }
  return extractScalar(extractExpression(attribute), field);
};
var extractExpression = (attribute) => {
  assertType(attribute, "mdxJsxAttribute");
  assertHasType(attribute.value);
  assertType(attribute.value, "mdxJsxAttributeValueExpression");
  return extractStatement(attribute.value);
};
var extractRaw = (attribute) => {
  assertType(attribute, "mdxJsxAttribute");
  assertHasType(attribute.value);
  assertType(attribute.value, "mdxJsxAttributeValueExpression");
  const rawValue = attribute.value.value;
  return trimFragments(rawValue);
};
function assertType(val, type) {
  if (val.type !== type) {
    throw new Error(
      `Expected type to be ${type} but received ${val.type}. ${MDX_PARSE_ERROR_MSG}`
    );
  }
}
function assertHasType(val) {
  if (val) {
    if (typeof val !== "string") {
      return;
    }
  }
  throw new Error(`Expect value to be an object with property "type"`);
}
var trimFragments = (string3) => {
  const rawArr = string3.split("\n");
  let openingFragmentIndex = null;
  let closingFragmentIndex = null;
  rawArr.forEach((item, index2) => {
    if (item.trim() === "<>") {
      if (!openingFragmentIndex) {
        openingFragmentIndex = index2 + 1;
      }
    }
  });
  rawArr.reverse().forEach((item, index2) => {
    if (item.trim() === "</>") {
      const length = rawArr.length - 1;
      if (!closingFragmentIndex) {
        closingFragmentIndex = length - index2;
      }
    }
  });
  const value = rawArr.reverse().slice(openingFragmentIndex || 0, closingFragmentIndex || rawArr.length - 1).join("\n");
  return value;
};

// ../../../node_modules/.pnpm/vfile-location@4.1.0/node_modules/vfile-location/lib/index.js
function location(file) {
  const value = String(file);
  const indices = [];
  const search3 = /\r?\n|\r/g;
  while (search3.test(value)) {
    indices.push(search3.lastIndex);
  }
  indices.push(value.length + 1);
  return { toPoint, toOffset };
  function toPoint(offset2) {
    let index2 = -1;
    if (typeof offset2 === "number" && offset2 > -1 && offset2 < indices[indices.length - 1]) {
      while (++index2 < indices.length) {
        if (indices[index2] > offset2) {
          return {
            line: index2 + 1,
            column: offset2 - (index2 > 0 ? indices[index2 - 1] : 0) + 1,
            offset: offset2
          };
        }
      }
    }
    return { line: void 0, column: void 0, offset: void 0 };
  }
  function toOffset(point3) {
    const line2 = point3 && point3.line;
    const column = point3 && point3.column;
    if (typeof line2 === "number" && typeof column === "number" && !Number.isNaN(line2) && !Number.isNaN(column) && line2 - 1 in indices) {
      const offset2 = (indices[line2 - 2] || 0) + column - 1 || 0;
      if (offset2 > -1 && offset2 < indices[indices.length - 1]) {
        return offset2;
      }
    }
    return -1;
  }
}

// ../../../node_modules/.pnpm/unist-util-source@4.0.2/node_modules/unist-util-source/lib/index.js
var search2 = /\r?\n|\r/g;
function source(value, file) {
  const doc = String(file);
  const loc = location(file);
  const position2 = value && typeof value === "object" ? "type" in value ? value.position : value : void 0;
  if (!position2 || !position2.start || !position2.end) {
    return null;
  }
  const endOffset = loc.toOffset(position2.end);
  let startOffset = loc.toOffset(position2.start);
  if (endOffset === -1 || startOffset === -1) {
    return null;
  }
  const results = [];
  while (startOffset < endOffset) {
    search2.lastIndex = startOffset;
    const match = search2.exec(doc);
    const end = match && match.index < endOffset ? match.index : endOffset;
    results.push(doc.slice(startOffset, end));
    startOffset = end;
    if (match && match.index < endOffset) {
      startOffset += match[0].length;
      results.push(match[0]);
    }
  }
  return results.join("");
}

// src/parse/mdx.ts
function mdxJsxElement(node2, field, imageCallback) {
  try {
    const template = field.templates?.find((template2) => {
      const templateName = typeof template2 === "string" ? template2 : template2.name;
      return templateName === node2.name;
    });
    if (typeof template === "string") {
      throw new Error("Global templates not yet supported");
    }
    if (!template) {
      const string3 = toTinaMarkdown2({ type: "root", children: [node2] }, field);
      return {
        type: node2.type === "mdxJsxFlowElement" ? "html" : "html_inline",
        value: string3.trim(),
        children: [{ type: "text", text: "" }]
      };
    }
    const props = extractAttributes(
      node2.attributes,
      template.fields,
      imageCallback
    );
    const childField = template.fields.find(
      (field2) => field2.name === "children"
    );
    if (childField) {
      if (childField.type === "rich-text") {
        if (node2.type === "mdxJsxTextElement") {
          node2.children = [{ type: "paragraph", children: node2.children }];
        }
        props.children = remarkToSlate(node2, childField, imageCallback);
      }
    }
    return {
      type: node2.type,
      name: node2.name,
      children: [{ type: "text", text: "" }],
      props
    };
  } catch (e) {
    if (e instanceof Error) {
      throw new RichTextParseError(e.message, node2.position);
    }
    throw e;
  }
}
var directiveElement = (node2, field, imageCallback, raw) => {
  let template;
  template = field.templates?.find((template2) => {
    const templateName = typeof template2 === "string" ? template2 : template2.name;
    return templateName === node2.name;
  });
  if (typeof template === "string") {
    throw new Error("Global templates not yet supported");
  }
  if (!template) {
    template = field.templates?.find((template2) => {
      const templateName = template2?.match?.name;
      return templateName === node2.name;
    });
  }
  if (!template) {
    return {
      type: "p",
      children: [{ type: "text", text: source(node2, raw || "") || "" }]
    };
  }
  if (typeof template === "string") {
    throw new Error(`Global templates not supported`);
  }
  const props = node2.attributes || {};
  const childField = template.fields.find((field2) => field2.name === "children");
  if (childField) {
    if (childField.type === "rich-text") {
      if (node2.type === "containerDirective") {
        props.children = remarkToSlate(node2, childField, imageCallback, raw);
      }
    }
  }
  return {
    type: "mdxJsxFlowElement",
    name: template.name,
    props,
    children: [{ type: "text", text: "" }]
  };
};

// src/parse/remarkToPlate.ts
var remarkToSlate = (root2, field, imageCallback, raw, skipMDXProcess) => {
  const mdxJsxElement2 = skipMDXProcess ? (node2) => node2 : mdxJsxElement;
  const content3 = (content4) => {
    switch (content4.type) {
      case "table": {
        return {
          type: "table",
          children: content4.children.map((tableRow) => {
            return {
              type: "tr",
              children: tableRow.children.map((tableCell) => {
                return {
                  type: "td",
                  children: [
                    {
                      type: "p",
                      children: (0, import_lodash.default)(
                        tableCell.children.map(
                          (child) => phrasingContent(child)
                        )
                      )
                    }
                  ]
                };
              })
            };
          }),
          props: {
            align: content4.align?.filter((item) => !!item)
          }
        };
      }
      case "blockquote":
        const children = [];
        content4.children.map((child) => {
          const inlineElements = unwrapBlockContent(child);
          inlineElements.forEach((child2) => {
            children.push(child2);
          });
        });
        return {
          type: "blockquote",
          children
        };
      case "heading":
        return heading2(content4);
      case "code":
        return parseCode(content4);
      case "paragraph":
        return paragraph2(content4);
      case "mdxJsxFlowElement":
        return mdxJsxElement2(content4, field, imageCallback);
      case "thematicBreak":
        return {
          type: "hr",
          children: [{ type: "text", text: "" }]
        };
      case "listItem":
        return {
          type: "li",
          children: [
            {
              type: "lic",
              children: (0, import_lodash.default)(
                content4.children.map((child) => unwrapBlockContent(child))
              )
            }
          ]
        };
      case "list":
        return list3(content4);
      case "html":
        return html2(content4);
      // @ts-ignore
      case "mdxFlowExpression":
      // @ts-ignore
      case "mdxjsEsm":
        throw new RichTextParseError(
          // @ts-ignore
          `Unexpected expression ${content4.value}.`,
          // @ts-ignore
          content4.position
        );
      case "leafDirective": {
        return directiveElement(content4, field, imageCallback, raw);
      }
      case "containerDirective": {
        return directiveElement(content4, field, imageCallback, raw);
      }
      default:
        throw new RichTextParseError(
          `Content: ${content4.type} is not yet supported`,
          // @ts-ignore
          content4.position
        );
    }
  };
  const html2 = (content4) => {
    return {
      type: "html",
      value: content4.value,
      children: [{ type: "text", text: "" }]
    };
  };
  const html_inline = (content4) => {
    return {
      type: "html_inline",
      value: content4.value,
      children: [{ type: "text", text: "" }]
    };
  };
  const list3 = (content4) => {
    return {
      type: content4.ordered ? "ol" : "ul",
      children: content4.children.map((child) => listItem2(child))
    };
  };
  const listItem2 = (content4) => {
    return {
      type: "li",
      // @ts-ignore
      children: content4.children.map((child) => {
        switch (child.type) {
          case "list":
            return list3(child);
          case "heading":
          case "paragraph":
            return {
              type: "lic",
              children: (0, import_lodash.default)(
                child.children.map((child2) => phrasingContent(child2))
              )
            };
          case "blockquote": {
            return {
              ...blockquote2(child),
              type: "lic"
            };
          }
          case "mdxJsxFlowElement":
            return {
              type: "lic",
              children: [
                // @ts-ignore casting a flow element to a paragraph
                mdxJsxElement2(
                  { ...child, type: "mdxJsxTextElement" },
                  field,
                  imageCallback
                )
              ]
            };
          case "html":
            return {
              type: "lic",
              children: html_inline(child)
            };
          /**
           * This wouldn't be supported right now, but since formatting
           * under a list item can get scooped up incorrectly, we support it
           *
           * ```
           * - my list item
           *
           *   {{% my-shortcode %}}
           */
          case "leafDirective": {
            return {
              type: "lic",
              children: [directiveElement(child, field, imageCallback)]
            };
          }
          case "code":
          case "thematicBreak":
          case "table":
            throw new RichTextParseError(
              `${child.type} inside list item is not supported`,
              child.position
            );
          default:
            let position2;
            if (child.type !== "containerDirective") {
              position2 = child.position;
            }
            throw new RichTextParseError(
              `Unknown list item of type ${child.type}`,
              position2
            );
        }
      })
    };
  };
  const unwrapBlockContent = (content4) => {
    const flattenPhrasingContent = (children) => {
      const children2 = children.map((child) => phrasingContent(child));
      return (0, import_lodash.default)(Array.isArray(children2) ? children2 : [children2]);
    };
    switch (content4.type) {
      case "heading":
      case "paragraph":
        return flattenPhrasingContent(content4.children);
      /**
       * Eg.
       *
       * >>> my content
       */
      case "html":
        return [html_inline(content4)];
      case "blockquote":
      // TODO
      default:
        throw new RichTextParseError(
          // @ts-ignore
          `UnwrapBlock: Unknown block content of type ${content4.type}`,
          // @ts-ignore
          content4.position
        );
    }
  };
  const parseCode = (content4) => {
    if (content4.lang === "mermaid") {
      return mermaid(content4);
    }
    return code3(content4);
  };
  const mermaid = (content4) => {
    return {
      type: "mermaid",
      value: content4.value,
      children: [{ type: "text", text: "" }]
    };
  };
  const code3 = (content4) => {
    const extra = {};
    if (content4.lang) extra["lang"] = content4.lang;
    return {
      type: "code_block",
      ...extra,
      value: content4.value,
      children: [{ type: "text", text: "" }]
    };
  };
  const link2 = (content4) => {
    return {
      type: "a",
      url: sanitizeUrl(content4.url),
      title: content4.title,
      children: (0, import_lodash.default)(
        content4.children.map((child) => staticPhrasingContent(child))
      )
    };
  };
  const heading2 = (content4) => {
    return {
      type: ["h1", "h2", "h3", "h4", "h5", "h6"][content4.depth - 1],
      children: (0, import_lodash.default)(content4.children.map(phrasingContent))
    };
  };
  const staticPhrasingContent = (content4) => {
    switch (content4.type) {
      case "mdxJsxTextElement":
        return mdxJsxElement2(content4, field, imageCallback);
      case "text":
        return text7(content4);
      case "inlineCode":
      case "emphasis":
      case "image":
      case "strong":
        return phrashingMark(content4);
      case "html":
        return html_inline(content4);
      default:
        throw new Error(
          `StaticPhrasingContent: ${content4.type} is not yet supported`
        );
    }
  };
  const phrasingContent = (content4) => {
    switch (content4.type) {
      case "text":
        return text7(content4);
      case "delete":
        return phrashingMark(content4);
      case "link":
        return link2(content4);
      case "image":
        return image2(content4);
      case "mdxJsxTextElement":
        return mdxJsxElement2(content4, field, imageCallback);
      case "emphasis":
        return phrashingMark(content4);
      case "strong":
        return phrashingMark(content4);
      case "break":
        return breakContent();
      case "inlineCode":
        return phrashingMark(content4);
      case "html":
        return html_inline(content4);
      // @ts-ignore
      case "mdxTextExpression":
        throw new RichTextParseError(
          // @ts-ignore
          `Unexpected expression ${content4.value}.`,
          // @ts-ignore
          content4.position
        );
      default:
        throw new Error(
          `PhrasingContent: ${content4.type} is not yet supported`
        );
    }
  };
  const breakContent = () => {
    return {
      type: "break",
      children: [
        {
          type: "text",
          text: ""
        }
      ]
    };
  };
  const phrashingMark = (node2, marks = []) => {
    const accum = [];
    switch (node2.type) {
      case "emphasis": {
        const children = (0, import_lodash.default)(
          node2.children.map(
            (child) => phrashingMark(child, [...marks, "italic"])
          )
        );
        children.forEach((child) => {
          accum.push(child);
        });
        break;
      }
      case "inlineCode": {
        const markProps2 = {};
        marks.forEach((mark) => markProps2[mark] = true);
        accum.push({
          type: "text",
          text: node2.value,
          code: true,
          ...markProps2
        });
        break;
      }
      case "delete": {
        const children = (0, import_lodash.default)(
          node2.children.map(
            (child) => phrashingMark(child, [...marks, "strikethrough"])
          )
        );
        children.forEach((child) => {
          accum.push(child);
        });
        break;
      }
      case "strong": {
        const children = (0, import_lodash.default)(
          node2.children.map((child) => phrashingMark(child, [...marks, "bold"]))
        );
        children.forEach((child) => {
          accum.push(child);
        });
        break;
      }
      case "image": {
        accum.push(image2(node2));
        break;
      }
      case "link": {
        const children = (0, import_lodash.default)(
          node2.children.map((child) => phrashingMark(child, marks))
        );
        accum.push({
          type: "a",
          url: sanitizeUrl(node2.url),
          title: node2.title,
          children
        });
        break;
      }
      case "text":
        const markProps = {};
        marks.forEach((mark) => markProps[mark] = true);
        accum.push({ type: "text", text: node2.value, ...markProps });
        break;
      /**
       * Eg. this is a line break
       *                 vv
       * _Some italicized
       * text on 2 lines_
       */
      case "break":
        accum.push(breakContent());
        break;
      default:
        throw new RichTextParseError(
          `Unexpected inline element of type ${node2.type}`,
          // @ts-ignore
          node2?.position
        );
    }
    return accum;
  };
  const image2 = (content4) => {
    return {
      type: "img",
      url: imageCallback(content4.url),
      alt: content4.alt || void 0,
      // alt cannot be `null`
      caption: content4.title,
      children: [{ type: "text", text: "" }]
    };
  };
  const text7 = (content4) => {
    return {
      type: "text",
      text: content4.value
    };
  };
  const blockquote2 = (content4) => {
    const children = [];
    content4.children.map((child) => {
      const inlineElements = unwrapBlockContent(child);
      inlineElements.forEach((child2) => {
        children.push(child2);
      });
    });
    return {
      type: "blockquote",
      children
    };
  };
  const paragraph2 = (content4) => {
    const children = (0, import_lodash.default)(content4.children.map(phrasingContent));
    if (children.length === 1) {
      if (children[0]) {
        if (children[0].type === "html_inline") {
          return {
            ...children[0],
            type: "html"
          };
        }
      }
    }
    return {
      type: "p",
      children
    };
  };
  return {
    type: "root",
    children: root2.children.map((child) => {
      return content3(child);
    })
  };
};
var RichTextParseError = class _RichTextParseError extends Error {
  constructor(message, position2) {
    super(message);
    __publicField(this, "position");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _RichTextParseError);
    }
    this.name = "RichTextParseError";
    this.position = position2;
  }
};
var sanitizeUrl = (url) => {
  const allowedSchemes = ["http", "https", "mailto", "tel", "xref"];
  if (!url) return "";
  let parsedUrl = null;
  try {
    parsedUrl = new URL(url);
  } catch (error) {
    return url;
  }
  const scheme = parsedUrl.protocol.slice(0, -1);
  if (allowedSchemes && !allowedSchemes.includes(scheme)) {
    console.warn(`Invalid URL scheme detected ${scheme}`);
    return "";
  }
  if (parsedUrl.pathname === "/") {
    if (url.endsWith("/")) {
      return parsedUrl.href;
    }
    return `${parsedUrl.origin}${parsedUrl.search}${parsedUrl.hash}`;
  } else {
    return parsedUrl.href;
  }
};

// src/next/parse/post-processing.ts
var postProcessor = (tree, field, imageCallback) => {
  const addPropsToMdxFlow = (node2) => {
    const props = {};
    node2.attributes.forEach((attribute) => {
      if (attribute.type === "mdxJsxAttribute") {
        props[attribute.name] = attribute.value;
      } else {
        throw new Error("HANDLE mdxJsxExpressionAttribute");
      }
    });
    if (node2.children.length) {
      let tree2;
      if (node2.type === "mdxJsxTextElement") {
        tree2 = postProcessor(
          {
            type: "root",
            children: [{ type: "paragraph", children: node2.children }]
          },
          field,
          imageCallback
        );
      } else {
        tree2 = postProcessor(
          { type: "root", children: node2.children },
          field,
          imageCallback
        );
      }
      props.children = tree2;
    }
    node2.props = props;
    delete node2.attributes;
    node2.children = [{ type: "text", text: "" }];
  };
  visit(tree, "mdxJsxFlowElement", addPropsToMdxFlow);
  visit(tree, "mdxJsxTextElement", addPropsToMdxFlow);
  return remarkToSlate(tree, field, imageCallback, "", true);
};

// src/next/parse/index.ts
var parseMDX2 = (value, field, imageCallback) => {
  const backup = (v) => v;
  const callback = imageCallback || backup;
  const tree = fromMarkdown2(value, field);
  return postProcess(tree, field, callback);
};
var postProcess = (tree, field, imageCallback) => {
  return postProcessor(compact(tree), field, imageCallback);
};

// src/parse/parseShortcode.ts
function parseShortcode(preprocessedString, template) {
  const match = template.match;
  const unkeyedAttributes = !!template.fields.find((t) => t.name === "_value");
  const hasChildren = !!template.fields.find((t) => t.name == "children");
  const replacement = `<${template.name} ${unkeyedAttributes ? '_value="$1"' : "$1"}>${hasChildren ? "$2" : "\n"}</${template.name}>`;
  const endRegex = `((?:.|\\n)*)${match.start}\\s/\\s*${match.name || template.name}[\\s]*${match.end}`;
  const regex = `${match.start}\\s*${match.name || template.name}[\\s]+${unkeyedAttributes ? `['"]?(.*?)['"]?` : "(.*?)"}[\\s]*${match.end}${hasChildren ? endRegex : ""}`;
  return replaceAll(preprocessedString, regex, replacement);
}

// src/parse/index.ts
var mdxToAst = (value) => {
  return remark().use(remarkMdx).use(remarkGfm).parse(value);
};
var MDX_PARSE_ERROR_MSG = "TinaCMS supports a stricter version of markdown and a subset of MDX. https://tina.io/docs/editing/mdx/#differences-from-other-mdx-implementations";
var parseMDX = (value, field, imageCallback) => {
  if (!value) {
    return { type: "root", children: [] };
  }
  let tree;
  try {
    if (field.parser?.type === "markdown") {
      return parseMDX2(value, field, imageCallback);
    }
    let preprocessedString = value;
    const templatesWithMatchers = field.templates?.filter(
      (template) => template.match
    );
    templatesWithMatchers?.forEach((template) => {
      if (typeof template === "string") {
        throw new Error("Global templates are not supported");
      }
      if (template.match) {
        if (preprocessedString) {
          preprocessedString = parseShortcode(preprocessedString, template);
        }
      }
    });
    tree = mdxToAst(preprocessedString);
    if (tree) {
      return remarkToSlate(tree, field, imageCallback, value);
    } else {
      return { type: "root", children: [] };
    }
  } catch (e) {
    if (e instanceof RichTextParseError) {
      return invalidMarkdown(e, value);
    }
    return invalidMarkdown(new RichTextParseError(e.message), value);
  }
};
var invalidMarkdown = (e, value) => {
  const extra = {};
  if (e.position && Object.keys(e.position).length) {
    extra["position"] = e.position;
  }
  return {
    type: "root",
    children: [
      {
        type: "invalid_markdown",
        value,
        message: e.message || `Error parsing markdown ${MDX_PARSE_ERROR_MSG}`,
        children: [{ type: "text", text: "" }],
        ...extra
      }
    ]
  };
};
var replaceAll = (string3, target, value) => {
  const regex = new RegExp(target, "g");
  return string3.valueOf().replace(regex, value);
};
export {
  parseMDX,
  stringifyMDX
};
/*! Bundled license information:

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
*/
